// import genesezMM metamodel
import gcore;

extension de::genesez::platforms::common::log::Log;
extension de::genesez::platforms::common::AccessHelper;
extension de::genesez::platforms::common::GlobalStore;

////////////////////////////////////////////////////////////////////////////////
// public extend functions
////////////////////////////////////////////////////////////////////////////////


// process all packages
MModel makeAspects(MModel m): 
	saveModel(m)->
	m.nestedPackage.processPackage()
	;

// process all packages recursively, only consider taged values belonging to <<mdsd>>
private MPackage processPackage(MPackage p) :
	p.classifier.select(sc|sc.stereotype.name.contains("mdsd")).processClassifier()->
	p.nestedPackage.processPackage()->
	p.classifier.aspect._mapClassAspect();
	
// transform tagged values of stereotype <<mdsd>> to aspects
private MClassifier processClassifier(MClassifier c) :
	c.setAspect(
		c.taggedValue.reject(
			tv|(tv.value.toLowerCase() == "false") || (tv.tag.type.toLowerCase() != "boolean")
		).makeAspect()
	)->
	c.property.typeSelect(MAttribute).select(attr|attr.hasStereotype("key")).makeAspect("generate", "key")->
	c.property.typeSelect(MAttribute).select(attr|attr.hasStereotype("key")).makeAspect("generate", "immutable")
	;
	
private create MAspect makeAspect(MTaggedValue tv) :
	tv.owningElement.aspect.add(this)->
	setDomain(tv._getDomain())->
	setName(tv._getName());
	
private create MAspect makeAspect(MElement e, String domain, String name) :
	e.aspect.add(this)->
	setDomain(domain)->
	setName(name);

// helper for tagged value processing	
private _getDomain(MTaggedValue tv) :
	tv.tag.name.split("\\.").first();
	
// helper for tagged value processing	
private _getName(MTaggedValue tv) :
	let l = tv.tag.name.split("\\.") :
	 l.size > 1 ? l.get(1) : tv.tag.name;
	
// this is THE START of interesting functions because aspects define
// pim to psm mapping in our concept
private _mapClassAspect(MAspect aspect) :
	aspect.domain == "persistent" ?
		aspect._mapPersistence() :
	(aspect.domain == "ui" ?
		aspect._mapUi() :
		aspect);
		
private _mapPersistence(MAspect aspect) :
	let c = (MClass) aspect.element :
	c._hasNoPersistentSupertype() ?
		(
			c.property.add(
				makeAttribute(c, "PersistId_", "persistId", "Hibernate Object Identifier")
			)->
			c.property.add(
				makeAttribute(c, "PersistVersion_", "persistVersion", "Hibernate Object Version")
			)->
			makeAttribute(c, "PersistId_", "persistId", "Hibernate Object Identifier").makeAspect("persistent", "id")->
			makeAttribute(c, "PersistVersion_", "persistVersion", "Hibernate Object Version").makeAspect("persistent", "version")
		) : null
		;

private _hasNoPersistentSupertype(MClass c) :
	(c.supertype.size == 0) || (c.supertype.typeSelect(MClassifier).select(s|s.hasAspect("persistent")).isEmpty);


private _mapUi(MAspect aspect) :
	aspect.element;

create MOperation makeOperation() :
	this;
	
create MAttribute makeAttribute(MClassifier c, String xid, String name, String comment) :
	setXmiGuid(xid + c.xmiGuid)->
	setName(name)->
	c.property.add(this)->
	setMultiplicity(1)->
	setType(retrieveModel().primitiveTypes.selectFirst(ty|ty.name.startsWith("Integer")))->
	setVisibility("private")->
	setFinal(false)->
	ownedComment.add(
			makeComment("c_" + xid + c.xmiGuid).setAnnotation(comment)
		)->
	setAspect({makeAspect(this, "generate", "immutable")})->
//	info(this.name + ": " + this.aspect)->
	this;

create MComment makeComment(String xid) :
	setXmiGuid(xid)->
	this;
		