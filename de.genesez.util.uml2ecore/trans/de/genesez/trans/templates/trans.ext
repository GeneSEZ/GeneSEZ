// this is the transformation that transforms UML2 
// class models into code generation models.

// this imports the ecore metamodel; since we want to 
// transform into an instance of ecore, we need to load 
// this metamodel
import ecore;
// import the UML2 metamodel - this is what we transform from
import uml;

import codegenMm;
    
// and we also load the io extensions, for the purpose of
// debugging, in case we need it   
extension org::openarchitectureware::uml2ecore::io;   
    
// on top level, we transform a UML model into an EPackage. A 
// create extension is used for this. Create extensions have
// the sideeffect of creating an instance of the type given
// after the create keyword. Note that the newly created 
// EPackage can be accessed by "this" inside the function
MModel transform(Model m): 
	let mm = makeModel(m) :
	// start descending package tree
	mm.setOwnedPackage(m.ownedElement.typeSelect(Package).reject(e|((Package) e).name == ignoredPackage())
	.processPackage().setModel(mm))->mm;
	
create MModel makeModel(Model m):
	// set the unique xmiId
	setXmiGuid(xmiId(m))->
 	// the name of the new package should be the same as the UML model
	setName(m.name);

// create new MPackage from uml2 package
create MPackage makePackage( Package p) :
	// set the unique xmiId
	setXmiGuid(xmiId(p))->
	setName(p.name);

// only packages are contained in the model element
// they can contain more packages or classes
private MPackage processPackage( Package p) :
	let mp = makePackage(p) :
	// recursively descend package tree
	mp.setNestedPackage(p.ownedElement.typeSelect(Package).processPackage())->
	// add classes in package
	mp.setClassifier(p.ownedElement.typeSelect(Classifier)
		.reject(e|e.metaType == Association)
		.processClassifier().setOwningPackage(mp)) ->
	// map associations in package 
	p.ownedMember.typeSelect( Association ).processAssociation(mp) ->
	mp;
	
// create new MClass from uml2 class
create MClass makeClassifier( Class c ) :
	// set the unique xmiId
	setXmiGuid(xmiId(c))->
	setName(c.name)->
	setAbstract(c.isAbstract)
	->info()
	;

// classes are contained in packages. 
// they own attributes and association ends
private MClass processClassifier( Classifier c) :
	let mc = makeClassifier(c) :
	// add attributes
	mc.setProperty(c.attribute.reject(p|p.association != null).makeAttribute().setClassifier(mc))->
	// add association ends
	mc.property.addAll(c.attribute.select(p|p.association != null).makeAssociationRole().setClassifier(mc))->
	// add operations
	mc.setOperation(c.getOperations().makeOperation())->
	// add superclasses
	mc.setSupertype(c.general.makeClassifier())->
	mc.supertype.addAll(c.clientDependency.typeSelect(InterfaceRealization).contract.makeClassifier())->
	mc;
	
create MOperation makeOperation(Operation op) :
	// set the unique xmiId
	setXmiGuid(xmiId(op))->
	setName(op.name)->
	setAbstract(op.isAbstract)->
	setStatic(op.isStatic)->
	setVisibility(op.visibility.toString())->
	setFinal(op.isLeaf)->
	setReturnType(op.type.makeClassifier())->
	setRaisedException(op.raisedException.makeClassifier())->
	setParameter(op.ownedParameter
		.reject(p|p.direction.toString() == "return")
		.makeParameter().setOperation(this))
//	->info()
	;

create MParameter makeParameter(Parameter p) :
	// set the unique xmiId
	setXmiGuid(p.xmiId())->
	setName(p.name)->
	setDirection(p.direction.toString())->
	setType(p.type.makeClassifier())
//	->info()
	;

// create new MAttribute from uml2 Property
create MAttribute makeAttribute( Property p ) :
	// set the unique xmiId
	setXmiGuid(xmiId(p))->
	setName(p.name)->
	setVisibility(p.visibility.toString())->
	setMultiplicity(p.getUpper())->
	setDerived(p.isDerived)->
	setType(p.type.makeClassifier())->
	setFinal(p.isReadOnly)->
	setDefaultvalue(p.getDefault())->
	setStatic(p.isStatic);

// attributes at the moment are leafs in the model tree, so do nearly nothing here.
private MAttribute processAttribute( Property p) :
	let ma = makeAttribute(p) :
	ma;

// create new MAssociation from uml2 Association
create MAssociation makeAssociation( Association a ) :
	// set the unique xmiId
	setXmiGuid(xmiId(a))->
	setName(assocName(a))->
//	info()->
	this;

// associations are contained in packages and contain their ends
private MAssociation processAssociation(Association a, MPackage owningPackage): 
	let ma = makeAssociation(a) :
	ma.setOwningPackage(owningPackage)->
	ma.setEnd(a.memberEnd.select(e|e.class != null).makeAssociationRole())->
	ma.end.setAssociation(ma).setDerived(a.isDerived)->
	ma.linkEnds()->
//	info(ma.name + "(" + ma.end.name + ")")->
	ma;
	
private String assocName(Association a):
	(a.name == null || a.name == "") ?
		"" :
		a.name ;

create MAssociationRole makeAssociationRole(Property aend) :
	// set the unique xmiId
	setXmiGuid(xmiId(aend))->
	setClassifier(assocEndClass(aend))->
	setDerived(aend.isDerived)->
	setMultiplicity(aend.getUpper())->
	setType(aend.type.makeClassifier())->
	setName(assocEndName(aend))->
//	info()->
	this;
	
private MClass assocEndClass(Property a):
	// Note: we can call makeClassifier() as often as we want, since create
	// extensions are cached and, when invoked several times with the 
	// same arguments are executed only upon first invocation. Subsequent
	// invocations return the cached result of the first invocation
		a.class == null ? null : makeClassifier(a.class);
	
private MAssociation linkEnds(MAssociation ma) :
	let mend = ma.end :
	mend.size == 2 ?
		(mend.get(0).setOpposite(mend.get(1))->
		mend.get(1).setOpposite(mend.get(0))-> ma) :
		ma;

private String assocEndName(Property a):
	(a.name == null || a.name == "") ?
		a.type.name.toFirstLower() :
		a.name ;
		
create MInterface makeClassifier( Interface c ):
	// set the unique xmiId
	setXmiGuid(xmiId(c))->
	setName(c.name)
//	->info()
	;

create MEnumeration makeClassifier( Enumeration c ):
	// set the unique xmiId
	setXmiGuid(xmiId(c))->
	setName(c.name);

create MPrimitiveType makeClassifier( PrimitiveType c ):
	// set the unique xmiId
	setXmiGuid(xmiId(c))->
	setName(c.name)->
	makeModel(getUml2Model()).primitiveTypes.add(this)
//	->info()
	;

create MPrimitiveType makeClassifier( Void c ):
	// set the unique xmiId
	setXmiGuid("void")->
	setName("void")->
	makeModel(getUml2Model()).primitiveTypes.add(this)
//	->info()
	;

create MClassifier makeClassifier( Type c ):
	// set the unique xmiId
	setXmiGuid(xmiId(c))->
	setName(c.name)
//	->info()
	;

// get unique xmiId from ecore file, requires Java method
private String xmiId (Element obj) : 
	JAVA de.genesez.util.TransUtils.getXmiId(org.eclipse.emf.ecore.EObject);

// externally configure packages to ignore, e.g. UML standard profile :-)
private String ignoredPackage(): GLOBALVAR excludePackage;

// the model is passed in as a global variable
private Model getUml2Model() : GLOBALVAR uml2model;
		
	
	
  