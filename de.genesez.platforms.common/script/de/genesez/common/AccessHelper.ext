/*
	simplifies access to genesez models | working with genesez meta model
*/

//	based on genesez meta model
import genesezMM;

extension de::genesez::io::io;

/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	public extend functions
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	associations
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

/**
 * checks if an association role belongs to an association class or not
 * @param	aend	an association role
 * @return	true, if it's a plain association role and doesn't belongs to an association class and 
 * 			false, if the association role belongs to an association class
 */
boolean isPlainAssociation(MAssociationRole aend) :
	aend.association.associationClass == null;

/**
 * getter for the association class of an association role
 * @param	aend	an association role
 * @return	the association class of an association role (or null)
 * @see		isPlainAssociation
 */
MClass assocClass(MAssociationRole aend) :
	aend.association.associationClass;

/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	attributes
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

/**
 * getter for a list with all attributes including inherited
 * @param	c	a classifier
 * @return	a list with attributes or an empty list
 */
List[MAttribute] getAllAttributes(MClassifier c) :
	{}.add(c.getOwnAttributes()).add(c.getParentAttributes()).flatten();

/**
 * getter for a list with all owned member attributes excluding final and derived
 * @param	c	a classifier
 * @return	a list with attributes or an empty list
 */
List[MAttribute] getOwnAttributes(MClassifier c) :
	c.property.typeSelect(MAttribute).select(a|!a.final && !a.derived);

/**
 * getter for a list of all inherited attributes of the first supertype
 * @param	c	a classifier
 * @return	a list with attributes or an empty list
 */
List[MAttribute] getParentAttributes(MClassifier c) :
	c.supertype.isEmpty
		? {}
		: c.supertype.first().getAllAttributes();

/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	classifiers
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/


/**
 * getter for the model element using a classifier
 * @param	classifier	a classifier
 * @return	the model element
 */
MModel getModel(MClassifier this) :
	owningPackage.metaType == MModel
		? owningPackage
		: owningPackage.getModel()
	;
	
/**
 * getter for the model element using a package
 * @param	package		a package
 * @return	the model element
 */
MModel getModel(MPackage this) :
	metaType == MModel
		? this
		: nestingPackage.getModel()
	;

/**
 * getter for a class by it's full qualified name which is separed by dot's
 * @param	model				a model
 * @param	fullQualifiedName	full qualified name of the class
 * @return	the class or Void
 */
MClass getClass(MModel model, String fullQualifiedName) :
	let c = model.getClassifier(fullQualifiedName) :
		c.metaType == MClass
			? c
			: Void;

/**
 * getter for a classifier by it's full qualified name which is separed by dot's
 * @param	model				a model
 * @param	fullQualifiedName	full qualified name of the classifier
 * @return	the classifier with the full qualified name or null
 */
MClassifier getClassifier(MModel model, String fullQualifiedName) :
	getClassifier(model.nestedPackage, fullQualifiedName);

/**
 * getter for a package by it's full qualified name, which is separated by dot's
 * @param	model						a model
 * @param	fullQualifiedPackageName	full qualified name of a package
 * @return	the package with the full qualified name or null
 */
MPackage getPackage(MModel this, String fullQualifiedPackageName) :
	info(name) ->
	info("package count = " + nestedPackage.size) ->
	getPackage({this}, fullQualifiedPackageName);

/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	comments
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

/**
 * checks if an element has comment(s) or not
 * @param	e	an element
 * @return	true if the element has at least one comment, otherwise false
 */
boolean hasComment(MElement e) :
	e.ownedComment.size > 0;

/**
 * getter for the comment text of a list of comments
 * @param	l	list of comments of an element
 * @return	the comment text as a string or an empty string
 */
String getCommentText(List l) :
	l.size > 0
		? getComment((MComment) l.first()).replaceAll("\n", "; ")
		: "";

/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	generics
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

/**
 * checks if an classifier has generic parameter(s) or not
 * @param	c	an classifier
 * @return	true if the classifier has at least one generic parameter, otherwise false
 */
boolean hasGenericParameter(MClassifier c) :
	c.genericParameter.size > 0;

/**
 * checks if an operation has generic parameter(s) or not
 * @param	o	an operation
 * @return	true if the operation has at least one generic parameter, otherwise false
 */
boolean hasGenericParameter(MOperation o) :
	o.genericParameter.size > 0;

/**
 * checks if an attribute has generic realization(s) or not
 * @param	o	an attribute
 * @return	true if the attribute has at least one generic realization, otherwise false
 */
boolean hasGenericRealization(MAttribute a) :
	a.genericRealization.size > 0;

/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	types
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

/**
 * getter for the name of a type or the specification of a generic
 * @param	type	type element
 * @return	name of the type
 */
String name(MType type) :
	type.metaType == MGeneric
		? ((MGeneric)type).specification
		: ((MClassifier)type).name;
	
/**
 * getter for owned comments of a type
 * @param	type	type element
 * @return	list with owned comments
 */
List[MComment] ownedComment(MType type) :
	type.metaType == MGeneric
		? {}
		: ((MClassifier)type).ownedComment;

/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	stereotypes + tagged values
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

/**
 * checks if an element has a stereotype or not
 * @param	elem		an element
 * @param	stereotype	name of a stereotype
 * @return	true, if the element has the stereotype, otherwise false
 */
boolean hasStereotype(MElement elem, String stereotype) :
	//!e.stereotype.typeSelect(MStereotype).select(e|e.name == stereotype).isEmpty;
	elem.stereotype.name.contains(stereotype);

/**
 * checks if an element has a tagged value or not, ignoring the stereotype, which allows definition of the tagged value
 * @param	elem	an element
 * @param	tag		the name of a tagged value
 * @param	value	the value of a tagged value
 * @return	true, if the element has a tag with the given value, otherwise false
 */
boolean hasTaggedValue(MElement elem, String tag, String value) :
	elem.taggedValue.exists(e|e.tag.name == tag && e.value == value);

/**
 * checks if an element has a tagged value of a specific stereotype or not
 * @param	elem		an element
 * @param	sterotype	name of a stereotype
 * @param	tag			the name of a tagged value
 * @param	value		the value of a tagged value
 * @return	true, if the element has a tag with the given value, otherwise false
 */
boolean hasTaggedValue(MElement e, String stereotype, String tag, String value) :
	!e.taggedValue.typeSelect(MTaggedValue).
		select(e|e.value == value && e.tag.name == tag && e.tag.stereotype.name == stereotype).
		isEmpty;

/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	aspects
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

/**
 * checks if an element has an aspect with the specified name and domain name or not
 * @param	e		an element
 * @param	domain	the name of a domain
 * @param	name	the name of an aspect
 * @return	true, if an element has an aspect with a specified name and domain name, otherwise false
 */
boolean hasAspect(MElement e, String domain, String name) :
	!e.aspect.select(a|a.domain == domain && a.name == name).isEmpty;

/**
 * checks if an element has an aspect with a specified domain name or not
 * @param	e		an element
 * @param	domain	the name of a domain
 * @return	true, if an element has an aspect with a specified domain name, otherwise false
 */
boolean hasAspect(MElement e, String domain) :
	!e.aspect.select(a|a.domain == domain).isEmpty;

/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	public java functions
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	private extend functions
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

/**
 * getter for a string representation of a comment
 * @param	c	a comment
 * @return	string representation of a comment
 */
private String getComment(MComment c) :
	c.annotation != "null"
		? c.annotation
		: "";

/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	private java functions
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

/**
 * getter for a class by it's full qualified name from a list of classes
 * note: should actually only work, if the list contains the package, which is the first in the full qualified name
 * @param	packages			list of packages
 * @param	fullQualifiedName	full qualified name of a class
 * @return	class with the specified full qualified name or null
 */
private MClassifier getClassifier(List[MClass] packages, String fullQualifiedName) :
	JAVA de.genesez.common.AccessHelper.getClassifier(java.util.List, java.lang.String);

/**
 * getter for a package by it's full qualified name from a list of packages
 * note: should actually only work, if the list contains the package, which is the first in the full qualified name
 * @param	packages					list of packages
 * @param	fullQualifiedPackageName	full qualifed name of a package
 * @return	package with the specified full qualified name or null
 */
private MPackage getPackage(List[MPackage] packages, String fullQualifiedPackageName) :
	JAVA de.genesez.common.AccessHelper.getPackage(java.util.List, java.lang.String);
