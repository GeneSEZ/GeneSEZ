<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>XSD Adapter</title><link rel="stylesheet" href="../book.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.72.0"><link rel="start" href="index.html" title="openArchitectureWare User Guide"><link rel="up" href="reference.html" title="Part&nbsp;II.&nbsp;Reference"><link rel="prev" href="r50.html" title="UML2 Adapter"><link rel="next" href="r52.html" title="EMF Validation Adapter"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="xsd_reference"></a>XSD Adapter</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="xsd_reference.html#xsd_reference_prerequisites">Prerequisites</a></span></dt><dt><span class="section"><a href="xsd_reference.html#xsd_reference_overview">Overview</a></span></dt><dt><span class="section"><a href="xsd_reference.html#xsd_reference_workflow_components">Workflow Components</a></span></dt><dt><span class="section"><a href="xsd_reference.html#xsd_reference_xsd2ecore">Behind the scenes: Transforming XSD to Ecore</a></span></dt><dt><span class="section"><a href="xsd_reference.html#xsd_reference_declare_xsd">How to declare XML Schemas</a></span></dt></dl></div><p>The XSD <a class="indexterm" name="d0e11157"></a>Adapter
  allows oAW to read/write XML files as models and to
  use XML Schemas (XSDs) as meta models. This reference provides in-depth
  details, for a quick and pragmatic introduction see <a href="xsd_tutorial.html" title="XSD Tutorial"><i xmlns:xlink="http://www.w3.org/1999/xlink">XSD Tutorial</i></a> .</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xsd_reference_prerequisites"></a>Prerequisites</h2></div></div></div>

     Please take a look at 

    <a href="xsd_tutorial.html#xsd_tutorial_setup" title="Setup">the section called &#8220;Setup&#8221;</a>

     . 
  </div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xsd_reference_overview"></a>Overview</h2></div></div></div><p>The XSD Adapter performs two major tasks:</p><div class="orderedlist"><ol type="1"><li><p>It converts XML Schemas (XSDs) to Ecore models in a transparent
        manner, so that the Ecore models are hidden from the user. This is
        done in the workflow as well as in the IDE (to allow XSD-aware code
        completion for Xtend/Xpand/Check). For details about the mapping see
        <a href="xsd_reference.html#xsd_reference_xsd2ecore" title="Behind the scenes: Transforming XSD to Ecore">the section called &#8220;Behind the scenes: Transforming XSD to Ecore&#8221;</a> . For details about the
        workflow integration see <a href="xsd_reference.html#xsd_reference_workflow_components" title="Workflow Components">the section called &#8220;Workflow Components&#8221;</a></p></li><li><p>It extends the EmfMetaModel <a class="indexterm" name="d0e11190"></a>with concepts that are needed for
        XSDs. Theses are, for example, support for feature maps (needed to
        handle comments, nested text, CDATA and processing instructions),
        QNames, EMaps and composed Simpletypes.</p></li></ol></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xsd_reference_workflow_components"></a>Workflow Components</h2></div></div></div>

     The XSD Adapter provides the following workflow components: 

    <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xsd_reference_workflow_components_xsdmetamodel"></a>
        <code class="classname">XSDMetaModel</code>
      </h3></div></div></div><p>The XSDMetaModel <a class="indexterm" name="d0e11210"></a>loads
      the specified XSD, transforms them to Ecore
      models and makes them available for the other oAW components. If XSDs
      include/import other XSDs or if XML files reference XSDs via
      <span class="property">schemaLocation</span>, theses XSDs are also loaded
      (details: <a href="xsd_reference.html#xsd_reference_declare_xsd" title="How to declare XML Schemas">the section called &#8220;How to declare XML Schemas&#8221;</a> ). The most
      common scenario is to declare the <code class="classname">XSDMetaModel</code>
      within an <code class="classname">XMLReader</code>:</p><pre class="programlisting">&lt;component class="org.openarchitectureware.xsd.XMLReader"&gt;
  &lt;modelSlot value="model" /&gt;
  &lt;uri value="model.xml" /&gt;
  &lt;metaModel id="mm" class="org.openarchitectureware.xsd.XSDMetaModel"&gt;
    &lt;schemaFile value="metamodel.xsd" /&gt;
    &lt;registerPackagesGlobally value="true" /&gt;
  &lt;/metaModel&gt;
&lt;/component&gt;</pre><p>Another option is to specify an
      <code class="classname">XSDMetaModel</code> independently of other components as
      a bean:</p><pre class="programlisting">&lt;bean id="<span class="bold"><strong>mymetamodel</strong></span>" class="org.openarchitectureware.xsd.XSDMetaModel"&gt;
  &lt;schemaFile value="metamodel.xsd" /&gt;
&lt;/bean&gt;
&lt;component class="org.openarchitectureware.xsd.XMLReader"&gt;
  &lt;modelSlot value="model" /&gt;
  &lt;uri value="model.xml" /&gt;
  &lt;metaModel <span class="bold"><strong>idRef="mymetamodel"</strong></span> /&gt;
&lt;/component&gt;</pre><p>Attention: It can lead to errors when XSDs are loaded multiple
      times, which can only happen when using multiple
      <code class="classname">XSDMetaModels</code> within one workflow. The safe way
      to go is to declare just one <code class="classname">XSDMetaModel</code> per
      workflow and reference it from all components that need it.</p><p>Properties:</p><div class="itemizedlist"><ul type="disc"><li><p><span class="property">schemaFile</span>: optional, allowed multiple
          times: Specifies an XSD file which is being loaded. The path can be
          a complete URI, or relative to the project root or classpath.</p></li><li><p><span class="property">registerPackagesGlobally</span>: optional,
          default "<span class="property">false</span>": If <span class="property">true</span>,
          generated EPackages are registered to
          <code class="classname">org.eclipse.emf.ecore.EPackage.Registry.INSTANCE</code>,
          EMF's global package registry. Warning: when running workflows from
          your own java code, make sure to remove the generated packages from
          the registry before the next run!</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xsd_reference_workflow_components_xmlreader"></a>
        <code class="classname">XMLReader</code>
      </h3></div></div></div><p>The <code class="classname">XMLReader</code> reads one XML file which is
      valid according to the XSDs loaded by the
      <code class="classname">XSDMetaModel</code>. The XML file is loaded as a model
      and stored in the specified slot. Example:</p><pre class="programlisting">&lt;component class="org.openarchitectureware.xsd.XMLReader"&gt;
  &lt;modelSlot value="model" /&gt;
  &lt;uri value="model.xml" /&gt;
  &lt;metaModel idRef="mymetamodel" /&gt;
&lt;/component&gt;</pre><p>Properties:</p><div class="itemizedlist"><ul type="disc"><li><p><span class="property">slot</span>: required: The name of the slot
          which in which the loaded model is stored. Other workflow components
          can access the model via referring to this slot.</p></li><li><p><span class="property">uri</span>: required: The file name of the XML
          file which should be read. Absolute URIs, and pathnames relative to
          the project root or to the classpath are valid.</p></li><li><p><span class="property">metaModel</span>: optional: Specifies the
          <code class="classname">XSDMetaModel</code> (see <a href="xsd_reference.html#xsd_reference_workflow_components_xsdmetamodel" title="XSDMetaModel">the section called &#8220;
        <code class="classname">XSDMetaModel</code>
      &#8221;</a>) for the
          <code class="classname">XMLReader</code>. In case no
          <code class="classname">XSDMetaModel</code> is specified, an
          <code class="classname">XSDMetaModel</code> with default configuration is
          instantiated implicitly. It is important to pay attention that all
          needed XSDs can be found while the loading process: <a href="xsd_reference.html#xsd_reference_declare_xsd" title="How to declare XML Schemas">the section called &#8220;How to declare XML Schemas&#8221;</a>.</p></li><li><p><span class="property">useDocumentRoot</span>: optional, default
          "<span class="property">false</span>": Dealing with XML files as models, most
          people think of the XML's root element as the model's root object.
          This is the default used by the <code class="classname">XMLReader</code>.
          But the XML's root element actually has a parent, the so-called
          DocumentRoot. Additionally the DocumentRoot contains
          comments/processing instructions and CDATA section which appears
          before or after the XML's root element, and, most notably, the
          DocumentRoot contains information about the used namespaces. If
          <span class="property">useDocumentRoot</span> is set to
          <span class="property">true</span>, the <code class="classname">XMLReader</code>
          stores the DocumentRoot-Object instead the XML's root element's
          object to the specified slot.</p></li><li><p><span class="property">option</span>: optional, can be specified
          multiple times: Option specifies a key-value-pair, which is handed
          on to the EMF's XMLResource in the loading process. Valid options
          are documented via JavaDoc in interface <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://help.eclipse.org/ganymede/topic/org.eclipse.emf.doc/references/javadoc/org/eclipse/emf/ecore/xmi/XMLResource.html" target="_top">
              <code class="classname">org.eclipse.emf.ecore.xmi.XMLResource</code>
            </a>. Additionally, the <code class="classname">XMLReader</code>
          supports these options:</p><div class="itemizedlist"><ul type="circle"><li><p><span class="property">DEFAULT_NAMESPACE</span>: Specifies a
              default namespace, in case the XML file does not declare
              one:</p><pre class="programlisting">&lt;option key="DEFAULT_NAMESPACE" val="http://www.dlese.org/Metadata/opml" /&gt;</pre></li><li><p><span class="property">NAMESPACE_MAP</span>: Specifies a mapping
              for namespaces, which is applied when loading XML files.</p><pre class="programlisting">&lt;option key="NAMESPACE_MAP"&gt;
  &lt;val class="org.openarchitectureware.xsd.lib.MapBean"&gt;
    &lt;mapping from="http://www.openarchitectureware.org/example/model/wrong"
             to="http://www.openarchitectureware.org/example/model/loadcurve" /&gt;
  &lt;/val&gt;
&lt;/option&gt;</pre></li></ul></div></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xsd_reference_workflow_components_xmlwriter"></a>
        <code class="classname">XMLWriter</code>
      </h3></div></div></div><p>The <code class="classname">XMLWriter</code> writes the model stored in a
      slot to an XML file. If the slot contains a collection of models, each
      one is written to a separate file. The model(s) must have been
      instantiated using an XSD-based meta model. Example:</p><pre class="programlisting">&lt;component class="org.openarchitectureware.xsd.XMLWriter"&gt;
  &lt;metaModel idRef="svgmm" /&gt;
  &lt;modelSlot value="svgmodel" /&gt;
  &lt;uri value="src-gen/mycurve.svg" /&gt;
&lt;/component&gt;</pre><p>Properties:</p><div class="itemizedlist"><ul type="disc"><li><p><span class="property">slot</span>: required: The name of the slot
          which holds the model or the collection of models which shall be
          serialized to XML.</p></li><li><p><span class="property">metaModel</span>: required: The instance of
          <code class="classname">XSDMetaModel</code>, which holds the XSD that the
          supplied models are based on. Also see <a href="xsd_reference.html#xsd_reference_workflow_components_xsdmetamodel" title="XSDMetaModel">the section called &#8220;
        <code class="classname">XSDMetaModel</code>
      &#8221;</a></p></li><li><p><span class="property">uri</span>: required if no
          <span class="property">uriExpression</span> is specified: The file name of
          the XML file which should be written. Absolute URIs are valid. Use
          relative path names on your own risk.</p></li><li><p><span class="property">uriExpression</span>: required if no
          <span class="property">uri</span> is specified: In the scenario where
          multiple XML files are written, this provides a mechanism to
          determine the file name for each of them. The oAW-expression
          specified in <code class="classname">expression</code> is evaluated for each
          file and has to return a file name. The model that is going to be
          written is accessible in the expression via a variable that has the
          name specified in <code class="classname">varName</code>. Example:
          </p><pre class="programlisting">&lt;uriExpression varName="docroot" expression="'src-gen/'+ecore2xsd::getFileName(docroot)" /&gt;</pre></li><li><p><span class="property">option</span>: optional, can be specified
          multiple times: Option specifies a key-value-pair, which is handed
          on to the EMF's XMLResource in the writing process. Valid options
          are documented via JavaDoc in interface <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://help.eclipse.org/ganymede/topic/org.eclipse.emf.doc/references/javadoc/org/eclipse/emf/ecore/xmi/XMLResource.html" target="_top">
              <code class="classname">org.eclipse.emf.ecore.xmi.XMLResource</code>
            </a>.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xsd_reference_workflow_components_xmlbeautifier"></a>
        <code class="classname">XMLBeautifier</code>
      </h3></div></div></div><p>The <code class="classname">XMLBeautifier</code> uses EMF to load the XML
      file, formats the mixed content (elements and text contained by the same
      element) and writes the file back to disk applying a nice indentation
      for the elements. The <code class="classname">XMLBeautifier</code> is not
      intended to be used in combination with the
      <code class="classname">XMLWriter</code>, since the
      <code class="classname">XMLWriter</code> cares about indentation by itself.
      Instead, use it for "manually" constructed XML files using Xpand. Since
      the frameworks for loading/storing XML always load the whole file into a
      complex data structure in memory, this approach does not scale well for
      huge XML files. Example:</p><pre class="programlisting">&lt;component class="org.openarchitectureware.xpand2.Generator"&gt;
  &lt;metaModel idRef="mm" /&gt;
  &lt;expand value="${src-pkg}::${file}::Root FOR '${out}'" /&gt;
  &lt;outlet path="${src-gen-dir}" /&gt;
  &lt;beautifier class="org.openarchitectureware.xsd.XMLBeautifier"&gt;
    &lt;maxLineWidth value="60" /&gt;
    &lt;formatComments value="true" /&gt;
    &lt;fileExtensions value=".xml, .html" /&gt;
  &lt;/beautifier&gt;
&lt;/component&gt;</pre><p>Properties:</p><div class="itemizedlist"><ul type="disc"><li><p><span class="property">maxLineWidth</span>: optional: Specifies the
          number of character after which a linewrap should be
          performed.</p></li><li><p><span class="property">formatComments</span>: optional, default
          <span class="property">true</span>: Specifies if formatting should also be
          applied to comments.</p></li><li><p><span class="property">fileExtensions</span>: optional, default
          "<span class="property">.xml, .xsl, .xsd, .wsdd, .wsdl</span>": Specifies a
          filter for which files formatting should be applied. Only files that
          match one of the specified file extensions are processed.</p></li><li><p><span class="property">loadOption</span>: optional, can be specified
          multiple times: Option specifies a key-value-pair, which is handed
          on to the EMF's XMLResource in the loading process. Valid options
          are documented via JavaDoc in interface <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://help.eclipse.org/ganymede/topic/org.eclipse.emf.doc/references/javadoc/org/eclipse/emf/ecore/xmi/XMLResource.html" target="_top">
              <code class="classname">org.eclipse.emf.ecore.xmi.XMLResource</code>
            </a>.</p></li><li><p><span class="property">saveOption</span>: optional, can be specified
          multiple times: Same as <span class="property">loadOption</span>, except for
          the difference that these options are applied while the writing
          process. Example: </p><pre class="programlisting">&lt;saveOption key="XML_VERSION" val="1.1" /&gt;
&lt;saveOption key="ENCODING" val="ASCII" /&gt;</pre></li></ul></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xsd_reference_xsd2ecore"></a>Behind the scenes: Transforming XSD to Ecore</h2></div></div></div><p>In the code generation process an XML Schema is transformed to an
    EMF Ecore model, which is then used as a meta model by EMF. XSD complex
    data types are mapped to EClasses, XSD simple data types are mapped to EMF
    data types defined in <code class="classname">
    org.eclipse.emf.ecore.xml.type.XMLTypePackage </code> and <code class="classname">
    org.openarchitectureware.xsd.XSDMetaModel </code> maps them to oAW
    data types. The document <span class="emphasis"><em><a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.eclipse.org/modeling/emf/docs/overviews/XMLSchemaToEcoreMapping.pdf" target="_top">XML
    Schema to Ecore Mapping</a></em></span> explains the mapping's details.
    <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.eclipse.org/modeling/emf/docs/overviews/XMLSchemaToEcoreMapping.pdf" target="_top">http://www.eclipse.org/modeling/emf/docs/overviews/XMLSchemaToEcoreMapping.pdf</a></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xsd_reference_declare_xsd"></a>How to declare XML Schemas</h2></div></div></div><p>There are three different ways to declare your XSDs. It does not
    matter which way you choose, or how you combine them, as long as the XSD
    Adapter can find all needed schemas.</p><div class="orderedlist"><ol type="1"><li><p>Within the Workflow: <code class="classname">
        org.openarchitectureware.xsd.XSDMetaModel </code> can have any
        amount of <code class="classname">schemaFile</code> elements.</p><pre class="programlisting">&lt;component class="org.openarchitectureware.xsd.XMLReader"&gt;
  &lt;modelSlot value="model" /&gt;
  &lt;uri value="${file}" /&gt;
  &lt;metaModel id="mm" class="org.openarchitectureware.xsd.XSDMetaModel"&gt;
    &lt;schemaFile value="model/loadcurve.xsd" /&gt;
    &lt;schemaFile value="model/device.xsd" /&gt;
  &lt;/metaModel&gt;
&lt;/component&gt;</pre></li><li><p>Within the XML file: XML files can contain
        <code class="classname">schemaLocation</code> attributes which associate the
        schema's namespace with the schema's filename. If the schema is
        created using WTP like described in <a href="xsd_tutorial.html#xsd_tutorial_model" title="Step 3: Create a Model using XML">the section called &#8220;Step 3: Create a Model using XML&#8221;</a> , the
        <code class="classname">schemaLocation</code> attribute is created
        automatically.</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;device:Device
  xmlns:device="http://www.openarchitectureware.org/example/model/device"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.openarchitectureware.org/example/model/device device.xsd"&gt;
  &lt;device:Name&gt;MyLaptop&lt;/device:Name&gt;
&lt;/device:Device&gt;</pre></li><li><p>Within an XSD: If one schema imports another, the
        <code class="classname">import</code> element can have a
        <code class="classname">schemaLocation</code> attribute, too.</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;schema
  targetNamespace="http://www.openarchitectureware.org/example/model/device"
  elementFormDefault="qualified" xmlns="http://www.w3.org/2001/XMLSchema"
  xmlns:tns="http://www.openarchitectureware.org/example/model/device"
  xmlns:lc="http://www.openarchitectureware.org/example/model/loadcurve"
  xmlns:ecore="http://www.eclipse.org/emf/2002/Ecore"&gt;

  &lt;import
    namespace="http://www.openarchitectureware.org/example/model/loadcurve"
    schemaLocation="loadcurve.xsd"&gt;
  &lt;/import&gt;

  &lt;complexType name="Device"&gt;
    &lt;sequence&gt;
      &lt;element name="Name" type="string" /&gt;
      &lt;element name="LoadCurve" type="lc:LoadCurve" /&gt;
    &lt;/sequence&gt;
  &lt;/complexType&gt;

  &lt;element name="Device" type="tns:Device"&gt;&lt;/element&gt;
&lt;/schema&gt;</pre></li></ol></div></div></div></body></html>