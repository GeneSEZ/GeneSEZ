/*
 * (c) GeneSEZ Research Group
 * All rights reserved.
 *
 * Licensed according to GeneSEZ License Terms <http://www.genesez.org/en/license>
 */

import gcore;


/**
 * Helper scripts to simplifies access to GeneSEZ Core meta model elements and
 * makes working with them more easier.
 * 
 * @author	Tobias Haubold <tobias.haubold@fh-zwickau.de> (maintainer)
 * @author	Nico Herbig <nico.herbig@fh-zwickau.de> (maintainer)
 * @author	Andre Pfl√ºger <andre.pflueger@fh-zwickau.de>
 */

extension org::genesez::util::logging::Logging;
extension org::genesez::metamodel::core::util::m2m::CreateElement;


// -- Multiplicity Elements (Properties, Parameters, Operations) --------------------------------------------


// -- Property --


/**
 * Checks if a property has a single-valued type.
 * 
 * @return	True if the property has a single-valued type, otherwise false.
 * @api
 */
boolean isSingleValuedType(MProperty this) :
	upperBoundMultiplicity == 0 || upperBoundMultiplicity == 1;


/**
 * Checks if a property has a multi-valued type.
 * 
 * @return	True if the property has a multi-valued type, otherwise false.
 * @api
 */
boolean isMultiValuedType(MProperty this) :
	upperBoundMultiplicity == -1 || upperBoundMultiplicity > 1;


/**
 * Checks if a property has a fixed lower count of values.
 * 
 * @return	True if the property has a fixed lower count of values, otherwise false.
 * @api
 */
boolean hasFixedLowerBoundMultiplicity(MProperty this) : 
	lowerBoundMultiplicity > -1;


/**
 * Checks if a property has a fixed upper count of values.
 * @return	True if the property has a fixed upper count of values, otherwise false.
 * @api
 */
boolean hasFixedUpperBoundMultiplicity(MProperty this) : 
	upperBoundMultiplicity > -1;


// -- Association Role --
	

/**
 * Checks if a qualified association role has a single-valued qualifier.
 * 
 * @return	True if the qualified association role has a single-valued qualifier, otherwise false.
 * @api
 */
boolean isSingleValuedQualifier(MAssociationRole this) :
	qualifierMultiplicity == 0 || qualifierMultiplicity == 1;


/**
 * Checks if a qualified association role has a multi-valued qualifier.
 * 
 * @return	True if the qualified association role has a multi-valued qualifier, otherwise false.
 * @api
 */
boolean isMultiValuedQualifier(MAssociationRole this) :
	qualifierMultiplicity == -1 || qualifierMultiplicity > 1;


/**
 * Checks if a qualified association role has a fixed count of values.
 * 
 * @return	True if the qualified association role has a fixed count of values, otherwise false.
 * @api
 * @todo: use Xtend script hasReturnParameter
 * @deprecated
 */
boolean hasFixedQualifierMultiplicity(MAssociationRole this) : 
	qualifierMultiplicity > -1;


// -- Parameter --


/**
 * Checks if the parameter has a single-valued type.
 * 
 * @return	True if the parameter has a single-valued type, otherwise false.
 * @api
 */
boolean isSingleValuedType(MParameter this) :
	upperBoundMultiplicity == 0 || upperBoundMultiplicity == 1;


/**
 * Checks if the parameter has a multi-valued type.
 * 
 * @return	True if the parameter has a multi-valued type, otherwise false.
 * @api
 */
boolean isMultiValuedType(MParameter this) :
	upperBoundMultiplicity == -1 || upperBoundMultiplicity > 1;


/**
 * Checks if a parameter has a fixed lower count of values.
 * 
 * @return	True if the parameter has a fixed lower count of values, otherwise false.
 * @api
 */
boolean hasFixedLowerBoundMultiplicity(MParameter this) : 
	lowerBoundMultiplicity > -1;


/**
 * Checks if a parameter has a fixed upper count of values.
 * 
 * @return	True if the parameter has a fixed upper count of values, otherwise false.
 * @api
 */
boolean hasFixedUpperBoundMultiplicity(MParameter this) : 
	upperBoundMultiplicity > -1;


// -- Operation --


/**
 * Checks if the return parameter of an operation has a single-valued type.
 * 
 * @return	True if the return parameter of the operation has a single-valued type, otherwise false.
 * @api
 * @todo: use Xtend script hasReturnParameter
 * @deprecated
 */
boolean isSingleValuedType(MOperation this) :
	return != null
		? return.isSingleValuedType()
		: false;


/**
 * Checks if the return parameter of an operation has a multi-valued type.
 * 
 * @return	True if the return parameter of the operation has a multi-valued type, otherwise false.
 * @api
 * @todo: use Xtend script hasReturnParameter
 * @deprecated
 */
boolean isMultiValuedType(MOperation this) :
	return != null
		? !return.isSingleValuedType()
		: false;


/**
 * Checks if the return parameter of an operation has a fixed lower count of values.
 * 
 * @return	True if the return parameter of the operation has a fixed lower count of values, otherwise false.
 * @api
 * @todo: use Xtend script hasReturnParameter
 * @deprecated
 */
boolean hasFixedLowerBoundMultiplicity(MOperation this) : 
	return != null
		? !return.hasFixedLowerBoundMultiplicity()
		: false;


/**
 * Checks if the return parameter of an operation has a fixed upper count of values.
 * 
 * @return	True if the return parameter of the operation has a fixed upper count of values, otherwise false.
 * @api
 * @todo: use Xtend script hasReturnParameter
 * @deprecated
 */
boolean hasFixedUpperBoundMultiplicity(MOperation this) : 
	return != null
		? !return.hasFixedUpperBoundMultiplicity()
		: false;


// -- Properties --------------------------------------------------------------------------------------------


// -- Attributes --------------------------------------------------------------------------------------------


// -- Checks for a Classifier --

/**
 * Checks if a classifier has attributes.
 * 
 * @return	True if the classifier has attributes, otherwise false.
 * @api
 */
boolean hasAttributes(MClassifier this) : 
	property.typeSelect( MAttribute ).size > 0;


/**
 * Checks if a classifier has initializable attributes.
 *
 * @return	True if the classifier has initializable attributes, otherwise false.
 */
boolean hasInitializableAttributes(MClassifier this) : 
	!allInitializableAttributes().isEmpty;


/**
 * Checks if a classifier has derived attributes.
 * 
 * @return	True if the classifier has derived attributes, otherwise false.
 * @api
 */
boolean hasDerivedAttributes(MClassifier this) : 
	property.typeSelect( MAttribute ).exists( a | a.derived );


// -- Checks for an Attribute --

/**
 * Checks if an attribute has a default value
 * 
 * @return	True if the attribute has a default value, otherwise false.
 * @api
 */
boolean hasDefaultValue(MAttribute this) :
	defaultvalue.length > 0;


// -- Getter for a Classifier --


/**
 * Returns the list of attributes of an classifier including inherited,
 * whereas inherited attributes are first in the list.
 *
 * @return 	The list of attributes of the classifier, otherwise an empty list.
 * @api
 */
List[MAttribute] allAttributes(MClassifier this):
	{}.addAll(
		generalization.allAttributes()
	).addAll(
		realization.allAttributes()
	).addAll( property.typeSelect( MAttribute) );


/**
 * Just there for error free templates.
 * Just called if a generalization or realization of a classifier is no classifier.
 * 
 * @return	An empty list.
 * @see		allAttributes(MClassifier)
 */
private List[MAttribute] allAttributes(MType this) : 
	{};


/**
 * Returns the list of initializable attributes of an classifier including inherited which 
 * are neither final nor derived, whereas inherited initializable attributes are first in the list.
 *
 * @return	The list of initializable attributes of the classifier, otherwise an empty list.
 * @api
 */
List[MAttribute] allInitializableAttributes(MClassifier this):
	{}.addAll(
		generalization.allInitializableAttributes()
	).addAll( owningInitializableAttributes() );


/**
 * Just there for error free templates.
 * Just called if a generalization of a classifier is no classifier.
 * 
 * @return	An empty list.
 * @see		allInitializableAttributes(MClassifier)
 */
private List[MAttribute] allInitializableAttributes(MType this) : 
	{};


/**
 * Returns the list of owning initializable attributes of an classifier which
 * are neither final nor derived.
 * 
 * @return	The list of initializable attributes of the classifier, otherwise an empty list.
 */
List[MAttribute] owningInitializableAttributes(MClassifier this) :
	property.typeSelect(MAttribute).select( e | 
		!e.static && !e.derived && !( e.final && e.hasDefaultValue() )
	);


// -- Association Roles -------------------------------------------------------------------------------------







/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	properties
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

/**
 * Getter for a list of all initializable properties. 
 * Excluding final and derived for MAttribute and derived for MAssociationRole.
 * 
 * @return	a list of initializable properties or an empty list
 */
List[MProperty] owningInitializableProperties(MClassifier this) :
	{}.addAll(
		owningInitializableAttributes()
	).addAll(
		owningInitializableAssociationRoles() 
	);

/**
 * Returns the a list of all initializable properties.
 * Excluding final and derived for MAttribute and derived for MAssociationRole.
 * 
 * @return	the list of of initializable properties or an empty list
 */
List[MProperty] allInitializableProperties(MClassifier this) :
	{}.addAll(
		allInitializableAttributes()
	).addAll(
		allInitializableAssociationRoles()
	);

/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	attributes
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/




/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	association + association roles
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

/**
 * checks if a classifier has association roles
 * @return	true if the classifier has association roles, otherwise false
 */
boolean hasAssociationRoles(MClassifier this) : 
	property.typeSelect(MAssociationRole).size > 0;

/**
 * checks if an association role has an opposite or not
 * @return	true, if the association role has an opposite
 */
boolean hasOpposite(MAssociationRole this) : opposite != null;

/**
 * checks if the opposite of an association role has a simple valued type
 * @return	true if the opposite of an association role has a simple valued type, otherwise false
 */
boolean isOppositeSingleValuedType(MAssociationRole this) :
	oppositeUpperBoundMultiplicity == 1;

/**
 * checks if the opposite of an association role has a multi-valued type
 * @return	true if the opposite of an association role has a multi-valued type, otherwise false
 */
boolean isOppositeMultiValuedType(MAssociationRole this) :
	oppositeUpperBoundMultiplicity != 1;

/**
 * checks if an association role has a qualifier
 * @return	true, if the association role has a qualifier
 */
boolean hasQualifier(MAssociationRole this) : qualifier != null;

/**
 * checks if an association role is qualified
 * @return	true, if the association role has a qualifier
 * @see		hasQualifier(MAssociationRole)
 */
boolean isQualified(MAssociationRole this) : hasQualifier();

/**
 * checks if the opposite of an association role is qualified
 * @return	true, if the opposite has a qualifier, otherwise false
 */
boolean hasQualifiedOpposite(MAssociationRole this) :
	hasOpposite() ? opposite.isQualified() : false;

/**
 * checks if the opposite of an association role is qualified
 * @return	true, if the opposite has a qualifier, otherwise false
 */
boolean isOppositeQualified(MAssociationRole this) :
	hasOpposite() && opposite.isQualified();

/**
 * checks if an association role belongs to an association class or not
 * @return	true, if it's a plain association role and doesn't belongs to an association class and 
 * 			false, if the association role belongs to an association class
 */
boolean hasAssociationClass(MAssociationRole this) :
	association.associationClass != null;

/**
 * check if a class is an association class or not
 * @return	true, if the class is an association class, otherwise false
 */
boolean isAssociationClass(MClass this) : ownedAssociation != null;

/**
 * check if a classifier is an association class or not
 * @see		isAssociationClass(MClass)
 * @return	false
 */
boolean isAssociationClass(MClassifier this) : false;

/**
 * checks if an association role belongs to an association class or not
 * @param	aend	an association role
 * @return	true, if it's a plain association role and doesn't belongs to an association class and 
 * 			false, if the association role belongs to an association class
 * @deprecated, use {@link hasAssociationClass(MAssociationRole)}
 */
boolean isPlainAssociation(MAssociationRole aend) :
	aend.association.associationClass == null;

/**
 * getter for the association class of an association role
 * @param	aend	an association role
 * @return	the association class of an association role (or null)
 * @see		isPlainAssociation
 */
MClass assocClass(MAssociationRole aend) :
	aend.association.associationClass;


/**
 * Getter for a list of all association roles including inherited.
 * Inherited association roles first.
 *
 * @return 	a list of association roles or an empty list
 */
List[MAssociationRole] allAssociationRoles(MClassifier this):
	{}.addAll(
		generalization.isEmpty
			? {}
			: generalization.allAssociationRoles()
	).addAll(
		realization.isEmpty
			? {}
			: realization.allAssociationRoles()
	).addAll( property.typeSelect(MAssociationRole) );


/**
 * Just there for error free templates.
 *
 * @see		allAssociationRoles(MClassifier)
 * @return	an empty list
 */
List[MAssociationRole] allAssociationRoles(MType this) : {};


/**
 * Checks if a classifier has initializable association roles or not.
 *
 * @return	true, if a classifier has initializable association roles, otherwise false
 */
boolean hasInitializableAssociationRoles(MClassifier this) : 
	!allInitializableAssociationRoles().isEmpty;


/**
 * Getter for a list of all owning initializable association roles.
 * Excluding derived.
 * 
 * @return	a list of initializable association roles or an empty list
 */
List[MAssociationRole] owningInitializableAssociationRoles(MClassifier this) :
	property.typeSelect(MAssociationRole).select( e | 
		!e.derived
	);


/**
 * Getter for a list of all initializable association roles.
 * Excluding derived.
 * Inherited initializable association roles first.
 *
 * @return 	a list of initializable association roles or an empty list
 */
List[MAssociationRole] allInitializableAssociationRoles(MClassifier this):
	{}.addAll(
		realization.isEmpty
			? {}
			: realization.allInitializableAssociationRoles()
	).addAll( owningInitializableAssociationRoles() );


/**
 * just there for error free templates
 * @see		allInitializableAssociationRoles(MClassifier)
 * @return	an empty list
 */
List[MAssociationRole] allInitializableAssociationRoles(MType this) : {};


/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	operations
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

/**
 * checks if a classifier has operations
 * @return	true if the classifier has operations, otherwise false
 */
boolean hasOperations(MClassifier this) : operation.size > 0;

/**
 * checks if a classifier has operation declarations, that is, if it has abstract operations
 * @return	true if the classifier has abstract operations, otherwise false
 */
boolean hasOperationDeclarations(MClassifier this) : 
	operation.reject( o|o.isConstructor() || o.isDestructor() || !o.abstract ).size > 0;

/**
 * checks if a classifier has one or more constructors
 * @return	true if the classifier has constructors, otherwise false
 * @see		isConstructor(MOperation)
 */
boolean hasConstructors(MClassifier this) : operation.exists( o|o.isConstructor() );

/**
 * checks if an operation is a constructor of a classifier
 * @return	true if the operation is a constructor, otherwise false
 */
boolean isConstructor(MOperation this) :
	hasStereotype("Create") || hasStereotype("create") || classifier.name == name;

/**
 * checks if a classifier has one or more destructors
 * @return	true if the classifier has destructors, otherwise false
 * @see		isDestructor(MOperation)
 */
boolean hasDestructors(MClassifier this) : operation.exists( o|o.isDestructor() );

/**
 * checks if an operation is a destructor of a classifier
 * @return	true if the operation is a destructor, otherwise false
 */
boolean isDestructor(MOperation this) :
	hasStereotype("Destroy") || hasStereotype("destroy") || name.startsWith("~");

/**
 * checks if an operation has a return type
 * @return	true if the operation has a return type, otherwise false
 */
boolean hasReturn(MOperation this) :
	return != null && return.type.name().toLowerCase() != "void";

/**
 * checks if a parameter has a default value
 * @return	true if the parameter has a default value, otherwise false
 */
boolean hasDefaultValue(MParameter this) :
	defaultvalue.length > 0;

/**
 * checks if an operation can throw exceptions
 * @return	true if the operation can throw exceptions, otherwise false
 */
boolean hasExceptions(MOperation this) : !raisedException.isEmpty;

/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	comments
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

/**
 * checks if an element has one or more comments
 * @return	true if the element has at least one comment, otherwise false
 */
boolean hasComment(MElement this) :
	ownedComment.size > 0;

/**
 * getter for the comment text of a list of comments
 * @param	l	list of comments of an element
 * @return	the comment text as a string or an empty string
 * @todo	revise, see file comment for further details
 * @deprecated	use 'comment' functions in 'Conversion'-script instead
 */
String getCommentText(List[MComment] this) :
	size > 0
		? getComment( first() ).replaceAll("\n", "; ")
		: "";

/**
 * getter for the owned comments of a type
 * @return	the list of owned comments
 * @deprecated	use 'comment' functions in 'Conversion'-script instead
 */
List[MComment] ownedComment(MType this) :
	switch (metaType) {
		case MGeneric : {}
		case MExternal : {}
		default : ((MClassifier)this).ownedComment
	};
	

/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	generics
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

/**
 * checks if a classifier has one or more generic parameters
 * @return	true if the classifier has at least one generic parameter, otherwise false
 */
boolean hasGenericParameter(MClassifier this) :
	genericParameter.size > 0;
	
/**
 * checks if an external type has one or more generic parameters
 * @return	true if the external type has at least one generic parameter, otherwise false
 */
boolean hasGenericParameter(MExternal this) :
	genericParameter.size > 0;

/**
 * checks if an operation has one or more generic parameter
 * @return	true if the operation has at least one generic parameter, otherwise false
 */
boolean hasGenericParameter(MOperation this) :
	genericParameter.size > 0;

/**
 * checks if a property has one or more generic realizations
 * @return	true if the property has at least one generic realization, otherwise false
 */
boolean hasGenericRealization(MProperty this) :
	genericRealization.size > 0;

/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	stereotypes + tagged values
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

/**
 * checks if an element is annotated with a stereotype
 * @param	stereotype	the name of a stereotype
 * @return	true if the element has the stereotype, otherwise false
 */
boolean hasStereotype(MElement this, String stereotype) :
	this.stereotype.name.contains(stereotype);

/**
 * return a stereotype with the given name
 * @param	this	the instance of MElement
 * @param	name	the name of a stereotype
 * @return	the stereotype
 */
MStereotype getStereotype(MElement this, String name) :
	this.stereotype.selectFirst(e|e.name == name);

/**
 * checks if an element has a tagged value by ignoring the stereotype
 * @param	tag		the name of a tagged value
 * @param	value	the value of a tagged value
 * @return	true if the element has a tag with the given value, otherwise false
 */
boolean hasTaggedValue(MElement this, String tag, String value) :
	taggedValue.exists( e| e.tag.name == tag && e.value == value );
	
/**
 * checks if an element has a tagged value by ignoring the stereotype
 * @param	tag				the name of a tagged value
 * @param	valueReference	the value reference of a tagged value
 * @return	true if the element has a tag with the given value reference, otherwise false
 */
boolean hasTaggedValue(MElement this, String tag, MElement valueReference) :
	taggedValue.exists( e| e.tag.name == tag && e.valueReference == valueReference );

/**
 * checks if an element has a tagged value of a specific stereotype
 * @param	sterotype	the name of a stereotype
 * @param	tag			the name of a tagged value
 * @param	value		the value of a tagged value
 * @return	true if the element has a tag with the given value, otherwise false
 */
boolean hasTaggedValue(MElement this, String stereotype, String tag, String value) :
	!taggedValue.typeSelect(MTaggedValue)
		.select( e| e.value == value && e.tag.name == tag && e.tag.stereotype.name == stereotype)
		.isEmpty;
		
/**
 * checks if an element has a tagged value of a specific stereotype
 * @param	sterotype		the name of a stereotype
 * @param	tag				the name of a tagged value
 * @param	valueReference	the value reference of a tagged value
 * @return	true if the element has a tag with the given value reference, otherwise false
 */
boolean hasTaggedValue(MElement this, String stereotype, String tag, MElement valueReference) :
	!taggedValue.typeSelect(MTaggedValue)
		.select( e| e.valueReference == valueReference && e.tag.name == tag && e.tag.stereotype.name == stereotype)
		.isEmpty;

/**
 * 	returns a tagged value of a stereotype if exists
 *
 * 	@param	stereotype	the name of a stereotype
 *	@param	tag			the name of a tagged value
 *	
 * 	@return		value of the tagged value
 */
String getTaggedValue(MElement this, String stereotype, String tag) :
	this.taggedValue.exists(e|e.tag.name == tag && e.tag.stereotype.name == stereotype)
		? this.taggedValue.selectFirst(e|e.tag.name == tag && e.tag.stereotype.name == stereotype).value
		: "";
		
/**
 * 	returns a tagged value reference of a stereotype if exists
 *
 * 	@param	stereotype	the name of a stereotype
 *	@param	tag			the name of a tagged value
 *	
 * 	@return		value reference of the tagged value
 */
MElement getTaggedValueReference(MElement this, String stereotype, String tag) :
	this.taggedValue.exists(e|e.tag.name == tag && e.tag.stereotype.name == stereotype)
		? this.taggedValue.selectFirst(e|e.tag.name == tag && e.tag.stereotype.name == stereotype).valueReference
		: "";

/**
 * returns the boolean value of a tagged value of a stereotype
 * 
 * @param	stereotype	the name of a stereotype
 * @param	tag			the name of a tagged value
 * 
 * @return	true, if the tagged value is true, otherwise false
 */
boolean getTaggedBooleanValue(MElement this, String stereotype, String tag) :
	hasTaggedValue( stereotype, tag, "true")
		? true
		: false;

/**
 * Returns a list of tagged values of a stereotype.
 * 
 * @param	stereotype	the name of a stereotype
 * @param	tag			the name of the tagged value
 * 
 * @return	the list of tagged values
 */
List[MTaggedValue] owningTaggedValues(MElement this, String stereotype, String tag) :
	this.taggedValue.exists(e|e.tag.name == tag && e.tag.stereotype.name == stereotype)
		? this.taggedValue.select(e|e.tag.name == tag && e.tag.stereotype.name == stereotype)
		: {};

/**
 * Returns a list of values of a tagged value of a stereotype.
 * 
 * @param	stereotype	the name of a stereotype
 * @param	tag			the name of the tagged value
 * 
 * @return	the list of values
 */
List[String] getTaggedValueList(MElement this, String stereotype, String tag) :
	let taggedValues = {} :
		taggedValues.addAll( owningTaggedValues(stereotype, tag).value ) ->
		taggedValues;
		
/**
 * Returns a list of value references of a tagged value of a stereotype.
 * 
 * @param	stereotype	the name of a stereotype
 * @param	tag			the name of the tagged value
 * 
 * @return	the list of value references
 */
List[MElement] getTaggedValueReferenceList(MElement this, String stereotype, String tag) :
	let taggedValueReferences = {} :
		taggedValueReferences.addAll( owningTaggedValues(stereotype, tag).valueReference ) ->
		taggedValueReferences;

/**
 *	function to set any existing tagged value
 *
 *	@param		this	MProperty
 *	@param		tag		name of the tagged value
 *	@param		value	the new value of the tagged value
 *
 */
Void setTaggedValue(MElement this, String tag, String value) :
	this.taggedValue.selectFirst(e|e.tag.name == tag).setValue(value);
	
/**
 *	function to set any existing tagged value reference
 *
 *	@param		this			MProperty
 *	@param		tag				name of the tagged value
 *	@param		valueReference	the new value reference of the tagged value
 *
 */
Void setTaggedValue(MElement this, String tag, MElement valueReference) :
	this.taggedValue.selectFirst(e|e.tag.name == tag).setValueReference(valueReference);
	
/**
 *	function to set a tagged value of a specific stereotype
 *	note: if a MTagggedValue already exists, it is used and it's value is changed
 *
 *	@param		this		MPropertye
 *	@param		stereotype	name of the stereotype
 *	@param		tag			name of the tagged value
 *	@param		value		the new value of the tagged value
 *
 */
Void setTaggedValue(MElement this, String stereotype, String tag, String value) :
	this.taggedValue.exists(e|e.tag.name == tag && e.tag.stereotype.name == stereotype)
		? this.taggedValue.selectFirst(e|e.tag.name == tag && e.tag.stereotype.name == stereotype).setValue(value)
		: createTaggedValue(
			this.stereotype.selectFirst(e|e.name == stereotype).property.selectFirst(e|e.name == tag),
			value
		);
	
/**
 *	function to set a tagged value reference of a specific stereotype
 *	note: if a MTagggedValue already exists, it is used and it's value is changed
 *
 *	@param		this			MPropertye
 *	@param		stereotype		name of the stereotype
 *	@param		tag				name of the tagged value
 *	@param		valueReference	new value reference of the tagged value
 *
 */
Void setTaggedValue(MElement this, String stereotype, String tag, MElement valueReference) :
	this.taggedValue.exists(e|e.tag.name == tag && e.tag.stereotype.name == stereotype)
		? this.taggedValue.selectFirst(e|e.tag.name == tag && e.tag.stereotype.name == stereotype).setValueReference(valueReference)
		: createTaggedValue(
			this.stereotype.selectFirst(e|e.name == stereotype).property.selectFirst(e|e.name == taggedValue),
			valueReference
		);
	
/**
 * 	checks if a tagged value of a stereotype exists and has a utilizable value (not empty or null)
 *
 * 	@param	sterotype		the name of a stereotype
 * 	@param	tag				the name of a tagged value
 * 	
 *	@return		true if the value exists and is utilizable
 */
boolean hasUtilizableValue(MElement this, String stereotype, String tag) :
	this.taggedValue.exists(e|e.tag.name == tag && e.tag.stereotype.name == stereotype) &&
	this.taggedValue.selectFirst(e|e.tag.name == tag && e.tag.stereotype.name == stereotype).value != "" &&
	this.taggedValue.selectFirst(e|e.tag.name == tag && e.tag.stereotype.name == stereotype).value != "null" &&
	// (nihe) I think this check is not needed anymore, because multi valued tagged values are splited into separate tagged values 
	this.taggedValue.selectFirst(e|e.tag.name == tag && e.tag.stereotype.name == stereotype).value != "[]"
		? true
		: false;
		
/**
 * 	checks if a tagged value of a stereotype exists and has a utilizable value reference (not null)
 *
 * 	@param	sterotype		the name of a stereotype
 * 	@param	tag				the name of a tagged value
 * 	
 *	@return		true if the value reference exists and is utilizable
 */
boolean hasUtilizableValueReference(MElement this, String stereotype, String tag) :
	this.taggedValue.exists(e|e.tag.name == tag && e.tag.stereotype.name == stereotype) &&
	this.taggedValue.selectFirst(e|e.tag.name == tag && e.tag.stereotype.name == stereotype).valueReference != null
		? true
		: false;

/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	aspects
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

/**
 * checks if an element has an aspect with the specified name and domain name
 * @param	domain	the name of a domain
 * @param	name	the name of an aspect
 * @return	true if an element has an aspect with a specified name and domain name, otherwise false
 */
boolean hasAspect(MElement this, String domain, String name) :
	!aspect.select( a| a.domain == domain && a.name == name ).isEmpty;

/**
 * checks if an element has an aspect with a specified domain name or not
 * @param	domain	the name of a domain
 * @return	true if an element has an aspect with a specified domain name, otherwise false
 */
boolean hasAspect(MElement this, String domain) :
	!aspect.select( a| a.domain == domain ).isEmpty;

/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	type helpers
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

/**
 * checks if the type is a generic
 * @return	true if the type is a generic, otherwise false
 */
boolean isGenericType(MType this) : metaType == MGeneric;

/**
 * checks if the type is an external type
 * @return	true if the type is an external type, otherwise false
 */
boolean isExternalType(MType this) : metaType == MExternal;

/**
 * checks if the type is a data type
 * @return	true if the type is a data type, otherwise false
 */
boolean isDataType(MType this) : metaType == MDataType;

/**
 * checks if the type is an enumeration
 * @return	true if the type is an enumeration, otherwise false
 */
boolean isEnumeration(MType this) : metaType == MEnumeration;

/**
 * checks if the type is a classifier
 * @return	true if the type is a classifier, otherwise false
 */
boolean isClassifier(MType this) : MClassifier.isInstance(this);

/**
 * checks if the type is a class
 * @return	true if the type is a class, otherwise false
 */
boolean isClass(MType this) : MClass.isInstance(this);

/**
 * getter for the name of a type or the specification of a generic
 * @return	the name (or specification) of the type
 */
String name(MType this) :
	switch (metaType) {
		case MGeneric : ((MGeneric)this).specification
		case MExternal : ((MExternal)this).name
		default : ((MClassifier)this).name
	};

/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	package accessors
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

/**
 * getter for the package element by using a property
 * @return	the package element
 */
MPackage package(MProperty this) : classifier.package();

/**
 * getter for the package element by using an operation
 * @return	the package element
 */
MPackage package(MOperation this) : classifier.package();

/**
 * getter for the package element by using a classifier
 * @return	the package element
 */
MPackage package(MClassifier this) :
	switch (owningContext.metaType) {
		case MModel : ((MPackage)owningContext)
		case MPackage : ((MPackage)owningContext)
		default : (logFatal("MDefinitionContext is neither MPackage nor MModel. This should never happen.") -> Void)
	};
	
/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	model accessors
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

/**
 * getter for the model element by using a property
 * @return	the model element
 */
MModel model(MProperty this) : classifier.model();

/**
 * getter for the model element by using an operation
 * @return	the model element
 */
MModel model(MOperation this) :	classifier.model();

/**
 * getter for the model element by using a classifier
 * @return	the model element
 */
MModel model(MClassifier this) :
	switch {
		case MModel.isInstance(this) : ((MModel)owningContext)
		case MPackage.isInstance(this) : ((MPackage)owningContext).model()
		case MClassifier.isInstance(this) : ((MClassifier)owningContext).model()
		default : (logFatal("MDefinitionContext is neither MPackage nor MModel nor MClassifier. This should never happen.") -> Void)
	};

MModel model(MElement this) :
	switch (this.metaType) {
		case MClassifier : ((MClassifier) this).model()
		case MOperation :  ((MOperation) this).model()
		case MParameter :  ((MParameter) this).operation.model()
		case MProperty :  ((MProperty) this).model()
		case MStereotype : ((MStereotype) this).model
		default : (logFatal("unable to determine MModel from MElement. Please add your case to this function!") -> Void)
	};

/**
 * getter for the model element by using a package
 * @return	the model element
 */
MModel model(MPackage this) :
	metaType == MModel
		? this
		: nestingPackage.getModel();

/**
 * getter for the model element by using a classifier
 * @return	the model element
 * @deprecated	replaced by {@link model(MClassifier)}
 */
MModel getModel(MClassifier this) :
	this.model();

/**
 * getter for the model element by using a package
 * @return	the model element
 * @deprecated	replaced by {@link model(MClassifier)}
 */
MModel getModel(MPackage this) :
	this.model();

/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	classifiers
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

/**
 * getter for a class by it's full qualified name which is separed by dot's
 * @param	fullQualifiedName	full qualified name of the class
 * @return	the class found or Void
 */
MClass getClass(MModel this, String fullQualifiedName) :
	let c = getClassifier(fullQualifiedName) :
		c.metaType == MClass
			? c
			: Void;

/**
 * getter for a classifier by it's full qualified name which is separed by dot's
 * @param	fullQualifiedName	full qualified name of the classifier
 * @return	the classifier found or null
 */
MClassifier getClassifier(MModel this, String fullQualifiedName) :
	getClassifier(nestedPackage, fullQualifiedName);

/**
 * getter for a package by it's full qualified name, which is separated by dot's
 * @param	fullQualifiedPackageName	full qualified name of a package
 * @return	the package found or null
 */
MPackage getPackage(MModel this, String fullQualifiedPackageName) :
	getPackage(nestedPackage, fullQualifiedPackageName);

List[MClassifier] allClassifiers(MPackage this) :
	addAllClassifier({});

List[MClassifier] addAllClassifier(MPackage this, List[MClassifier] classifiers) :
	classifiers.addAll(classifier) ->
	nestedPackage.addAllClassifier(classifiers) ->
	classifiers;
	
	
/**
 * Getter for a list of all generalized types.
 * Indirect generalized types first.
 *
 * @return 	a list of generalized types or an empty list
 */
List[MType] allGeneralizations(MClassifier this) :
	let generalizations = {} :
		!generalization.isEmpty
			? (	generalizations.addAll( generalization.allGeneralizations() ) ->	
				generalizations.addAll( generalization )
			) : Void ->
		generalizations;


/**
 * just there for error free templates
 *
 * @see		allGeneralizations(MClassifier)
 * @return	an empty list
 */
List[MType] allGeneralizations(MType this) :
	{};


/**
 * Getter for a list of all owning specialized types
 *
 * @return	a list of specialized types or an empty list
 */
List[MClassifier] owningSpecializations(MClassifier this) :
	model().allClassifiers().select( e | e.generalization.contains(this) );


/**
 * Getter for a list of all owning specialized types
 *
 * @see		owningSpecializations(MClassifier)
 * @return	a list of specialized types or an empty list
 */
List[MClassifier] owningSpecializations(MExternal this) :
	model.allClassifiers().select( e | e.generalization.contains(this) );


/**
 * just there for error free templates
 *
 * @see		owningSpecializations(MClassifier)
 * @return	an empty list
 */
List[MClassifier] owningSpecializations(MType this) :
	{};


/**
 * Getter for a list of all specialized types.
 * Direct specialized types first.
 *
 * @return 	a list of specialized types or an empty list
 */
List[MClassifier] allSpecializations(MType this):
	let specializations = {} :
		!owningSpecializations().isEmpty
			? (	specializations.addAll( owningSpecializations() ) ->
				specializations.addAll( owningSpecializations().allSpecializations() )
			) : Void ->
		specializations;

/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	packages
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/
	
List[MPackage] allPackages(MPackage this) :
	addAllPackages({});

List[MPackage] addAllPackages(MPackage this, List[MPackage] packages) :
	packages.addAll(nestedPackage) ->
	nestedPackage.addAllPackages(packages) ->
	packages;

/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	elements
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

MClassifier getClassifier(MElement this) :
	switch (metaType) {
		case MOperation : ((MOperation) this).classifier
		case MAttribute : ((MAttribute) this).classifier
		case MAssociationRole : ((MAssociationRole) this).classifier
		default : null
	};

/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	activities
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

MNode getInitialNode(MActivity this) :
	node.reject(e|e.metaType == MAction)
		.select(e|e.from.isEmpty)
		.first();












/**
 * getter for the type of a parameter
 * @return	the type of the parameter
 */
//MType type(MParameter this) : type;

/**
 * getter for the type of a property
 * @return	the type of the property
 */
//MType type(MProperty this) : type;

/**
 * just there for error free templates
 * should NOT be called!
 */
/*
MType type(MElement this) : 
	logFatal("somethings goes totally wrong within your templates... " +
	"   you cannot determine the type of an 'MElement': " + this) ->
	Void;
*/








/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	private functions
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

/**
 * getter for a string representation of a comment
 * @return	the string representation of a comment
 */
private String getComment(MComment this) :
	annotation != "null"
		? annotation
		: "";

/**
 * getter for a class by it's full qualified name from a list of classes
 * note: should actually only work, if the list contains the package, which is the first in the full qualified name
 * @param	packages			a list of packages
 * @param	fullQualifiedName	the full qualified name of a class
 * @return	the class found or null
 */
private MClassifier getClassifier(List[MClass] packages, String fullQualifiedName) :
	JAVA org.genesez.metamodel.core.util.AccessHelper.getClassifier(java.util.List, java.lang.String);

/**
 * getter for a package by it's full qualified name from a list of packages
 * note: should actually only work, if the list contains the package, which is the first in the full qualified name
 * @param	packages					a list of packages
 * @param	fullQualifiedPackageName	full qualifed name of a package
 * @return	the package found or null
 */
private MPackage getPackage(List[MPackage] packages, String fullQualifiedPackageName) :
	JAVA org.genesez.metamodel.core.util.AccessHelper.getPackage(java.util.List, java.lang.String);
