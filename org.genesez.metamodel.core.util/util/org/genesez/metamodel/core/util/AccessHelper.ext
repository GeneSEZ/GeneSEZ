/*
 * (c) GeneSEZ Research Group
 * All rights reserved.
 *
 * Licensed according to GeneSEZ License Terms <http://www.genesez.org/en/license>
 */

import gcore;


/**
 * Helper scripts to simplifies access to GeneSEZ Core meta model elements and
 * makes working with them more easier.
 * 
 * @author	Tobias Haubold <tobias.haubold@fh-zwickau.de> (maintainer)
 * @author	Nico Herbig <nico.herbig@fh-zwickau.de> (maintainer)
 * @author	Andre Pfl√ºger <andre.pflueger@fh-zwickau.de>
 */

extension org::genesez::metamodel::core::util::ExtensionMechanism;
extension org::genesez::util::logging::Logging;



// -- Multiplicity Elements (Properties, Parameters, Operations) --------------------------------------------


// -- Property --


/**
 * Checks if a property is single-valued.
 * 
 * @return	True if the property is single-valued, otherwise false.
 * @api
 */
boolean isSingleValued(MProperty this) :
	multiplicity.upperBound == 0 || multiplicity.upperBound == 1;


/**
 * Checks if a property is multi-valued.
 * 
 * @return	True if the property is multi-valued, otherwise false.
 * @api
 */
boolean isMultiValued(MProperty this) :
	multiplicity.upperBound == -1 || multiplicity.upperBound > 1;


/**
 * Checks if a property has a fixed lower count of values.
 * 
 * @return	True if the property has a fixed lower count of values, otherwise false.
 * @api
 */
boolean hasFixedLowerBoundMultiplicity(MProperty this) : 
	multiplicity.lowerBound > -1;


/**
 * Checks if a property has a fixed upper count of values.
 * @return	True if the property has a fixed upper count of values, otherwise false.
 * @api
 */
boolean hasFixedUpperBoundMultiplicity(MProperty this) : 
	multiplicity.upperBound > -1;


// -- Association Role --


/**
 * Checks if the opposite of an association role is single-valued.
 * 
 * @return	True if the opposite of the association role is single-valued, otherwise false.
 * @api
 */
boolean isOppositeSingleValued(MAssociationRole this) :
	oppositeMultiplicity.upperBound == 0 || oppositeMultiplicity.upperBound == 1;


/**
 * Checks if the opposite of an association role is multi-valued.
 * 
 * @return	True if the opposite of the association role is multi-valued, otherwise false.
 * @api
 */
boolean isOppositeMultiValued(MAssociationRole this) :
	oppositeMultiplicity.upperBound == -1 || oppositeMultiplicity.upperBound > 1;


/**
 * Checks if the opposite of an association role has a fixed lower count of values.
 * 
 * @return	True if the opposite of the association role has a fixed lower count of values, otherwise false.
 * @api
 */
boolean hasOppositeFixedLowerBoundMultiplicity(MAssociationRole this) : 
	oppositeMultiplicity.lowerBound > -1;


/**
 * Checks if the opposite of an association role has a fixed upper count of values.
 * 
 * @return	True if the opposite of the association role has a fixed upper count of values, otherwise false.
 * @api
 */
boolean hasOppositeFixedUpperBoundMultiplicity(MAssociationRole this) : 
	oppositeMultiplicity.upperBound > -1;


/**
 * Checks if the qualifier of an qualified association role is single-valued.
 * 
 * @return	True if the qualifier of the the qualified association role is single-valued, otherwise false.
 * @api
 */
boolean isQualifierSingleValued(MAssociationRole this) :
	qualifierMultiplicity.upperBound == 0 || qualifierMultiplicity.upperBound == 1;


/**
 * Checks if the qualifier of an qualified association role is multi-valued.
 * 
 * @return	True if the qualifier of the the qualified association role is multi-valued, otherwise false.
 * @api
 */
boolean isQualifierMultiValued(MAssociationRole this) :
	qualifierMultiplicity.upperBound == -1 || qualifierMultiplicity.upperBound > 1;


/**
 * Checks if the qualifier of an qualified association role has a fixed lower count of values.
 * 
 * @return	True if the qualifier of the qualified association role has a fixed lower count of values, otherwise false.
 * @api
 */
boolean hasQualifierFixedLowerBoundMultiplicity(MAssociationRole this) : 
	qualifierMultiplicity.lowerBound > -1;
	

/**
 * Checks if the qualifier of an qualified association role has a fixed upper count of values.
 * 
 * @return	True if the qualifier of the qualified association role has a fixed upper count of values, otherwise false.
 * @api
 */
boolean hasQualifierFixedUpperBoundMultiplicity(MAssociationRole this) : 
	qualifierMultiplicity.upperBound > -1;


// -- Parameter --


/**
 * Checks if the parameter is single-valued.
 * 
 * @return	True if the parameter is single-valued, otherwise false.
 * @api
 */
boolean isSingleValued(MParameter this) :
	multiplicity.upperBound == 0 || multiplicity.upperBound == 1;


/**
 * Checks if the parameter is multi-valued.
 * 
 * @return	True if the parameter is multi-valued, otherwise false.
 * @api
 */
boolean isMultiValued(MParameter this) :
	multiplicity.upperBound == -1 || multiplicity.upperBound > 1;


/**
 * Checks if a parameter has a fixed lower count of values.
 * 
 * @return	True if the parameter has a fixed lower count of values, otherwise false.
 * @api
 */
boolean hasFixedLowerBoundMultiplicity(MParameter this) : 
	multiplicity.lowerBound > -1;


/**
 * Checks if a parameter has a fixed upper count of values.
 * 
 * @return	True if the parameter has a fixed upper count of values, otherwise false.
 * @api
 */
boolean hasFixedUpperBoundMultiplicity(MParameter this) : 
	multiplicity.upperBound > -1;


// -- Operation --


/**
 * Checks if the return parameter of an operation is single-valued.
 * 
 * @return	True if the return parameter of the operation is single-valued, otherwise false.
 * @api
 * @todo: use Xtend script hasReturnParameter
 * @deprecated
 */
boolean isReturnSingleValued(MOperation this) :
	return != null
		? return.isSingleValued()
		: false;


/**
 * Checks if the return parameter of an operation is multi-valued.
 * 
 * @return	True if the return parameter of the operation is multi-valued, otherwise false.
 * @api
 * @todo: use Xtend script hasReturnParameter
 * @deprecated
 */
boolean isReturnMultiValued(MOperation this) :
	return != null
		? !return.isSingleValued()
		: false;


/**
 * Checks if the return parameter of an operation has a fixed lower count of values.
 * 
 * @return	True if the return parameter of the operation has a fixed lower count of values, otherwise false.
 * @api
 * @todo: use Xtend script hasReturnParameter
 * @deprecated
 */
boolean hasReturnFixedLowerBoundMultiplicity(MOperation this) : 
	return != null
		? !return.hasFixedLowerBoundMultiplicity()
		: false;


/**
 * Checks if the return parameter of an operation has a fixed upper count of values.
 * 
 * @return	True if the return parameter of the operation has a fixed upper count of values, otherwise false.
 * @api
 * @todo: use Xtend script hasReturnParameter
 * @deprecated
 */
boolean hasReturnFixedUpperBoundMultiplicity(MOperation this) : 
	return != null
		? !return.hasFixedUpperBoundMultiplicity()
		: false;


// -- Properties --------------------------------------------------------------------------------------------


// -- Getter for a Classifier --


/**
 * Returns the list of properties of an classifier including inherited,
 * whereas all attributes are added first to the list.
 *
 * @return 	The list of properties of the classifier, otherwise an empty list.
 * @see allAttributes(MClassifier)
 * @see allAssociationRoles(MClassifier)
 * @api
 */
List[MAttribute] allProperties(MClassifier this) :
	{ allAttributes() }.addAll(
		allAssociationRoles()
	);


/**
 * Returns the list of initializable properties of an classifier including inherited,
 * whereas all initializable attributes are added first to the list.
 * 
 * @return	The list of initializable properties of the classifier, otherwise an empty list.
 * @see allInitializableAttributes(MClassifier)
 * @see allInitializableAssociationRoles(MClassifier)
 */
List[MProperty] allInitializableProperties(MClassifier this) :
	{ allInitializableAttributes() }.addAll(
		allInitializableAssociationRoles()
	);


/**
 * Returns the list of owning initializable properties of an classifier including inherited,
 * whereas all owning initializable attributes are added first to the list.
 * 
 * @return	The list of initializable properties of the classifier, otherwise an empty list.
 * @see owningInitializableAttributes(MClassifier)
 * @see owningInitializableAssociationRoles(MClassifier)
 * @api
 */
List[MProperty] owningInitializableProperties(MClassifier this) :
	{ owningInitializableAttributes() }.addAll(
		owningInitializableAssociationRoles() 
	);


// -- Attributes --------------------------------------------------------------------------------------------


// -- Checks for a Classifier --

/**
 * Checks if a classifier has owning attributes.
 * 
 * @return	True if the classifier has owning attributes, otherwise false.
 * @api
 */
boolean hasAttributes(MClassifier this) : 
	property.exists( a | a.metaType == MAttribute );


/**
 * Checks if a classifier has owning initializable attributes.
 *
 * @return	True if the classifier has owning initializable attributes, otherwise false.
 */
boolean hasInitializableAttributes(MClassifier this) : 
	property.typeSelect( MAttribute ).exists( a | !a.static && !a.derived && !( a.final && a.hasDefaultValue() ) );


/**
 * Checks if a classifier has owning derived attributes.
 * 
 * @return	True if the classifier has derived attributes, otherwise false.
 * @api
 */
boolean hasDerivedAttributes(MClassifier this) : 
	property.typeSelect( MAttribute ).exists( a | a.derived );


// -- Getter for a Classifier --


/**
 * Returns the list of attributes of an classifier including inherited,
 * whereas inherited attributes are added first to the list.
 *
 * @return 	The list of attributes of the classifier, otherwise an empty list.
 * @api
 */
List[MAttribute] allAttributes(MClassifier this) :
	{}.addAll(
		generalization.allAttributes()
	).addAll(
		realization.allAttributes()
	).addAll( property.typeSelect( MAttribute) );


/**
 * Just there for error free templates.
 * Just called if a generalization or realization of a classifier is no classifier.
 * 
 * @return	An empty list.
 * @see		allAttributes(MClassifier)
 */
private List[MAttribute] allAttributes(MType this) : 
	{};


/**
 * Returns the list of initializable attributes of an classifier including inherited which 
 * are neither final nor derived, whereas inherited initializable attributes are added first to the list.
 *
 * @return	The list of initializable attributes of the classifier, otherwise an empty list.
 * @api
 */
List[MAttribute] allInitializableAttributes(MClassifier this) :
	{}.addAll(
		generalization.allInitializableAttributes()
	).addAll( owningInitializableAttributes() );


/**
 * Just there for error free templates.
 * Just called if a generalization of a classifier is no classifier.
 * 
 * @return	An empty list.
 * @see		allInitializableAttributes(MClassifier)
 */
private List[MAttribute] allInitializableAttributes(MType this) : 
	{};


/**
 * Returns the list of owning initializable attributes of an classifier which
 * are neither final nor derived.
 * 
 * @return	The list of initializable attributes of the classifier, otherwise an empty list.
 * @api
 */
List[MAttribute] owningInitializableAttributes(MClassifier this) :
	property.typeSelect(MAttribute).select( a | 
		!a.static && !a.derived && !( a.final && a.hasDefaultValue() )
	);


// -- Checks for an Attribute --


/**
 * Checks if an attribute has a default value
 * 
 * @return	True if the attribute has a default value, otherwise false.
 * @api
 */
boolean hasDefaultValue(MAttribute this) :
	defaultvalue.length > 0;


// -- Association Roles -------------------------------------------------------------------------------------


// -- Checks for a Classifier --


/**
 * Checks if a classifier has owning association roles.
 * 
 * @return	True if the classifier has owning association roles, otherwise false.
 * @api
 */
boolean hasAssociationRoles(MClassifier this) : 
	property.exists( ar | ar.metaType == MAssociationRole );


/**
 * Checks if a classifier has owning initializable association roles.
 *
 * @return	True if the classifier has owning initializable association roles, otherwise false.
 * @api
 */
boolean hasInitializableAssociationRoles(MClassifier this) : 
	property.typeSelect( MAssociationRole ).exists( ar | !ar.derived );


// -- Getter for a Classifier --


/**
 * Returns the list of association roles of an classifier including inherited,
 * whereas inherited association roles are added first to the list.
 *
 * @return 	The list of association roles of the classifier, otherwise an empty list.
 * @api
 */
List[MAssociationRole] allAssociationRoles(MClassifier this) :
	{}.addAll(
		generalization.allAssociationRoles()
	).addAll(
		realization.allAssociationRoles()
	).addAll( property.typeSelect(MAssociationRole) );


/**
 * Just there for error free templates.
 * Just called if a generalization or realization of a classifier is no classifier.
 * 
 * @return	An empty list.
 * @see		allAssociationRoles(MClassifier)
 */
private List[MAssociationRole] allAssociationRoles(MType this) : 
	{};


/**
 * Returns the list of initializable association roles of an classifier including inherited which 
 * are not derived, whereas inherited initializable association roles are added first to the list.
 *
 * @return	The list of initializable association roles of the classifier, otherwise an empty list.
 * @api
 */
List[MAssociationRole] allInitializableAssociationRoles(MClassifier this) :
	{}.addAll(
		realization.allInitializableAssociationRoles()
	).addAll( owningInitializableAssociationRoles() );


/**
 * Just there for error free templates.
 * Just called if a generalization of a classifier is no classifier.
 * 
 * @return	An empty list.
 * @see		allInitializableAssociationRoles(MClassifier)
 */
private List[MAssociationRole] allInitializableAssociationRoles(MType this) : 
	{};


/**
 * Returns the list of owning initializable association roles of an classifier which
 * are not derived.
 * 
 * @return	The list of initializable association roles of the classifier, otherwise an empty list.
 * @api
 */
List[MAssociationRole] owningInitializableAssociationRoles(MClassifier this) :
	property.typeSelect(MAssociationRole).select( ar | 
		!ar.derived
	);


// -- Checks for an Association Role --


/**
 * Checks if an association role has an opposite.
 * 
 * @return	True if the association role has an opposite, otherwise false.
 * @api
 */
boolean hasOpposite(MAssociationRole this) : 
	opposite != null;


/**
 * Checks if an association role has a qualifier.
 * 
 * @return	True if the association role has a qualifier, otherwise false.
 * @api
 */
boolean hasQualifier(MAssociationRole this) : 
	qualifier != null;


/**
 * Checks if the opposite of an association role has a qualifier.
 * 
 * @return	True if the opposite of the association role has a qualifier, otherwise false.
 * @api
 */
boolean hasOppositeQualifier(MAssociationRole this) :
	hasOpposite() && opposite.hasQualifier();


/**
 * Checks if an association role belongs to an association class.
 * It returns true, if the association role belongs to and acco
 * 
 * @return	True if the association role belongs to an association class, otherwise 
 * 			false if it is a plain association role and does not belongs to an association class.
 * @api
 */
boolean hasAssociationClass(MAssociationRole this) :
	association.associationClass != null;


/**
 * Returns the association class of an association role.
 * 
 * @return	The association class of the association role or 
 * 			null if the association role is a plain association and does not belongs to an association class.
 * @todo do we really need this?
 */
MClass getAssociationClass(MAssociationRole this) :
	association.associationClass;


/**
 * Check if a class is an association class.
 * 
 * @return	True if the class is an association class, otherwise false.
 * @api
 */
boolean isAssociationClass(MClass this) : 
	ownedAssociation != null;


/**
 * Check if a classifier is an association class.
 * 
 * @return	False.
 * @see		isAssociationClass(MClass)
 */
boolean isAssociationClass(MClassifier this) : 
	false;


// -- Operation ---------------------------------------------------------------------------------------------


// -- Checks for a Classifier --


/**
 * Checks if a classifier has owning operations including constructors and destructors.
 * 
 * @return	True if the classifier has owning operations, otherwise false.
 * @api
 */
boolean hasOperations(MClassifier this) : 
	!operation.isEmpty;


/**
 * Checks if a classifier has owning declared operations excluding constructors and destructors.
 * 
 * @return	True if the classifier has declared operations, otherwise false
 * @api
 */
boolean hasDeclaredOperations(MClassifier this) :
	operation.exists( o | !o.isConstructor() && !o.isDestructor() && o.abstract );


/**
 * Checks if a classifier has one or more constructors.
 * 
 * @return	True if the classifier has at least one constructors, otherwise false.
 * @see		isConstructor(MOperation)
 * @api
 */
boolean hasConstructors(MClassifier this) : 
	operation.exists( o | o.isConstructor() );


/**
 * Checks if a classifier has one or more destructors.
 * 
 * @return	True if the classifier has at least one destructors, otherwise false.
 * @see		isDestructor(MOperation)
 * @api
 */
boolean hasDestructors(MClassifier this) : 
	operation.exists( o | o.isDestructor() );


// -- Checks for an Operation --


/**
 * Checks if an operation is a constructor of a classifier, whereas the following properties are checked:
 *   - is the stereotype "Create" starting with a capital letter assigned to the specified operation or
 *   - is the stereotype "create" starting with a small letter assigned to the specified operation or
 *   - is the name of the classifier equals to the name of the specified operation
 * 
 * @return	True if the operation is a constructor of a classifier, otherwise false.
 * @api
 */
boolean isConstructor(MOperation this) :
	emHasStereotype("Create") || emHasStereotype("create") || classifier.name == name;


/**
 * Checks if an operation is a destructor of a classifier, whereas the following properties are checked:
 *   - is the stereotype "Destroy" starting with a capital letter assigned to the specified operation or
 *   - is the stereotype "destroy" starting with a small letter assigned to the specified operation or
 *   - does the name of the specified operation starting with the "~" character
 * 
 * @return	True if the operation is a destructor of a classifier, otherwise false.
 * @api
 */
boolean isDestructor(MOperation this) :
	emHasStereotype("Destroy") || emHasStereotype("destroy") || name.startsWith("~");


/**
 * Checks if an operation has a return parameter which is likewise not "void".
 * 
 * @return	True if the operation has a return parameter, otherwise false.
 * @api
 */
boolean hasReturn(MOperation this) :
	return != null && return.type.name().toLowerCase() != "void";


/**
 * Checks if an operation has exceptions that can be thrown.
 * 
 * @return	True if the operation has exceptions, otherwise false.
 * @api
 */
boolean hasExceptions(MOperation this) : 
	!raisedException.isEmpty;


// -- Checks for a Parameter --


/**
 * Checks if a parameter has a default value.
 * 
 * @return	True if the parameter has a default value, otherwise false.
 * @api
 */
boolean hasDefaultValue(MParameter this) :
	defaultvalue.length > 0;


// -- Comments ----------------------------------------------------------------------------------------------


// -- Checks for a Element --


/**
 * Checks if an element has one or more comments.
 * 
 * @return	True if the element has at least one comment, otherwise false.
 * @api
 */
boolean hasComment(MElement this) :
	!ownedComment.isEmpty;
	

// -- Generics ----------------------------------------------------------------------------------------------


/**
 * Checks if a classifier has one or more generic parameters.
 * 
 * @return	True if the classifier has at least one generic parameter, otherwise false.
 * @api
 */
boolean hasGenericParameter(MClassifier this) :
	genericParameter.size > 0;


/**
 * Checks if an external type has one or more generic parameters.
 * 
 * @return	True if the external type has at least one generic parameter, otherwise false.
 * @api
 */
boolean hasGenericParameter(MExternal this) :
	genericParameter.size > 0;


/**
 * Checks if an operation has one or more generic parameter.
 * 
 * @return	True if the operation has at least one generic parameter, otherwise false.
 * @api
 */
boolean hasGenericParameter(MOperation this) :
	genericParameter.size > 0;


/**
 * Checks if a property has one or more generic realizations.
 * 
 * @return	True if the property has at least one generic realization, otherwise false.
 * @api
 */
boolean hasGenericRealization(MProperty this) :
	genericRealization.size > 0;
	

/**
 * Checks if a parameter has one or more generic realizations.
 * @return	True if the parameter has at least one generic realizations, otherwise false.
 * @api
 */
boolean hasGenericRealization(MParameter this) :
	genericRealization.size > 0;


// -- Type Information --------------------------------------------------------------------------------------


/**
 * Checks if a type is a generic.
 *
 * @return	True if the type is a generic, otherwise false.
 */
boolean isGenericType(MType this) : 
	metaType == MGeneric;


/**
 * Checks if a type is an external type.
 * 
 * @return	True if the type is an external type, otherwise false.
 */
boolean isExternalType(MType this) : 
	metaType == MExternal;


/**
 * Checks if a type is a data type.
 * 
 * @return	True if the type is a data type, otherwise false.
 */
boolean isDataType(MType this) : 
	metaType == MDataType;


/**
 * Checks if a type is an enumeration.
 * 
 * @return	True if the type is an enumeration, otherwise false.
 */
boolean isEnumeration(MType this) : 
	metaType == MEnumeration;


/**
 * Checks if a type is a classifier.
 * 
 * @return	True if the type is a classifier, otherwise false.
 */
boolean isClassifier(MType this) : 
	MClassifier.isInstance(this);


/**
 * Checks if a type is a class
 * @return	true if the type is a class, otherwise false
 */
boolean isClass(MType this) : 
	MClass.isInstance(this);


/**
 * getter for the name of a type or the specification of a generic
 * @return	the name (or specification) of the type
 */
String name(MType this) :
	switch (metaType) {
		case MGeneric : ((MGeneric)this).specification
		case MExternal : ((MExternal)this).name
		default : ((MClassifier)this).name
	};

/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	package accessors
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

/**
 * getter for the package element by using a property
 * @return	the package element
 */
MPackage package(MProperty this) : classifier.package();

/**
 * getter for the package element by using an operation
 * @return	the package element
 */
MPackage package(MOperation this) : classifier.package();

/**
 * getter for the package element by using a classifier
 * @return	the package element
 */
MPackage package(MClassifier this) :
	switch (owningContext.metaType) {
		case MModel : ((MPackage)owningContext)
		case MPackage : ((MPackage)owningContext)
		default : (logFatal("MDefinitionContext is neither MPackage nor MModel. This should never happen.") -> Void)
	};
	
/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	model accessors
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

/**
 * getter for the model element by using a property
 * @return	the model element
 */
MModel model(MProperty this) : classifier.model();

/**
 * getter for the model element by using an operation
 * @return	the model element
 */
MModel model(MOperation this) :	classifier.model();

/**
 * getter for the model element by using a classifier
 * @return	the model element
 */
MModel model(MClassifier this) :
	switch {
		case MModel.isInstance(this) : ((MModel)owningContext)
		case MPackage.isInstance(this) : ((MPackage)owningContext).model()
		case MClassifier.isInstance(this) : ((MClassifier)owningContext).model()
		default : (logFatal("MDefinitionContext is neither MPackage nor MModel nor MClassifier. This should never happen.") -> Void)
	};

MModel model(MElement this) :
	switch (this.metaType) {
		case MClassifier : ((MClassifier) this).model()
		case MOperation :  ((MOperation) this).model()
		case MParameter :  ((MParameter) this).operation.model()
		case MProperty :  ((MProperty) this).model()
		case MStereotype : ((MStereotype) this).model
		default : (logFatal("unable to determine MModel from MElement. Please add your case to this function!") -> Void)
	};

/**
 * getter for the model element by using a package
 * @return	the model element
 */
MModel model(MPackage this) :
	metaType == MModel
		? this
		: nestingPackage.model();



/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	classifiers
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

/**
 * getter for a class by it's full qualified name which is separed by dot's
 * @param	fullQualifiedName	full qualified name of the class
 * @return	the class found or Void
 */
MClass getClass(MModel this, String fullQualifiedName) :
	let c = getClassifier(fullQualifiedName) :
		c.metaType == MClass
			? c
			: Void;

/**
 * getter for a classifier by it's full qualified name which is separed by dot's
 * @param	fullQualifiedName	full qualified name of the classifier
 * @return	the classifier found or null
 */
MClassifier getClassifier(MModel this, String fullQualifiedName) :
	getClassifier(nestedPackage, fullQualifiedName);

/**
 * getter for a package by it's full qualified name, which is separated by dot's
 * @param	fullQualifiedPackageName	full qualified name of a package
 * @return	the package found or null
 */
MPackage getPackage(MModel this, String fullQualifiedPackageName) :
	getPackage(nestedPackage, fullQualifiedPackageName);

List[MClassifier] allClassifiers(MPackage this) :
	addAllClassifier({});

List[MClassifier] addAllClassifier(MPackage this, List[MClassifier] classifiers) :
	classifiers.addAll(classifier) ->
	nestedPackage.addAllClassifier(classifiers) ->
	classifiers;
	
	
/**
 * Getter for a list of all generalized types.
 * Indirect generalized types first.
 *
 * @return 	a list of generalized types or an empty list
 */
List[MType] allGeneralizations(MClassifier this) :
	let generalizations = {} :
		!generalization.isEmpty
			? (	generalizations.addAll( generalization.allGeneralizations() ) ->	
				generalizations.addAll( generalization )
			) : Void ->
		generalizations;


/**
 * just there for error free templates
 *
 * @see		allGeneralizations(MClassifier)
 * @return	an empty list
 */
List[MType] allGeneralizations(MType this) :
	{};


/**
 * Getter for a list of all owning specialized types
 *
 * @return	a list of specialized types or an empty list
 */
List[MClassifier] owningSpecializations(MClassifier this) :
	model().allClassifiers().select( e | e.generalization.contains(this) );


/**
 * Getter for a list of all owning specialized types
 *
 * @see		owningSpecializations(MClassifier)
 * @return	a list of specialized types or an empty list
 */
List[MClassifier] owningSpecializations(MExternal this) :
	model.allClassifiers().select( e | e.generalization.contains(this) );


/**
 * just there for error free templates
 *
 * @see		owningSpecializations(MClassifier)
 * @return	an empty list
 */
List[MClassifier] owningSpecializations(MType this) :
	{};


/**
 * Getter for a list of all specialized types.
 * Direct specialized types first.
 *
 * @return 	a list of specialized types or an empty list
 */
List[MClassifier] allSpecializations(MType this):
	let specializations = {} :
		!owningSpecializations().isEmpty
			? (	specializations.addAll( owningSpecializations() ) ->
				specializations.addAll( owningSpecializations().allSpecializations() )
			) : Void ->
		specializations;

/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	packages
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/
	
List[MPackage] allPackages(MPackage this) :
	addAllPackages({});

List[MPackage] addAllPackages(MPackage this, List[MPackage] packages) :
	packages.addAll(nestedPackage) ->
	nestedPackage.addAllPackages(packages) ->
	packages;

/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	elements
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

MClassifier getClassifier(MElement this) :
	switch (metaType) {
		case MOperation : ((MOperation) this).classifier
		case MAttribute : ((MAttribute) this).classifier
		case MAssociationRole : ((MAssociationRole) this).classifier
		default : null
	};










/**
 * getter for the type of a parameter
 * @return	the type of the parameter
 */
//MType type(MParameter this) : type;

/**
 * getter for the type of a property
 * @return	the type of the property
 */
//MType type(MProperty this) : type;

/**
 * just there for error free templates
 * should NOT be called!
 */
/*
MType type(MElement this) : 
	logFatal("somethings goes totally wrong within your templates... " +
	"   you cannot determine the type of an 'MElement': " + this) ->
	Void;
*/








/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	private functions
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

/**
 * getter for a string representation of a comment
 * @return	the string representation of a comment
 */
private String getComment(MComment this) :
	annotation != "null"
		? annotation
		: "";

/**
 * getter for a class by it's full qualified name from a list of classes
 * note: should actually only work, if the list contains the package, which is the first in the full qualified name
 * @param	packages			a list of packages
 * @param	fullQualifiedName	the full qualified name of a class
 * @return	the class found or null
 */
private MClassifier getClassifier(List[MClass] packages, String fullQualifiedName) :
	JAVA org.genesez.metamodel.core.util.AccessHelper.getClassifier(java.util.List, java.lang.String);

/**
 * getter for a package by it's full qualified name from a list of packages
 * note: should actually only work, if the list contains the package, which is the first in the full qualified name
 * @param	packages					a list of packages
 * @param	fullQualifiedPackageName	full qualifed name of a package
 * @return	the package found or null
 */
private MPackage getPackage(List[MPackage] packages, String fullQualifiedPackageName) :
	JAVA org.genesez.metamodel.core.util.AccessHelper.getPackage(java.util.List, java.lang.String);
