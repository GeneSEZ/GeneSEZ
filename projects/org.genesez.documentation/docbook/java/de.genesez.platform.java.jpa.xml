<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE section PUBLIC "-//OASIS//DTD Simplified DocBook XML V1.0//EN" "http://www.oasis-open.org/docbook/xml/simple/1.0/sdocbook.dtd">
<section id="de.genesez.platforms.java.jpa">
	
	<title>JPA (Java Persistence API)</title>
	
	<para>Die Java Plattform Erweiterung JPA erm&ouml;glicht dem Modellierer 
	das Modell mit persistenzspezifische Informationen auf Basis der 
	Java Persistence API (JPA) in der 
	<ulink url="http://java.sun.com/javaee/technologies/persistence.jsp">
	Version 1.0</ulink> zu versehen. GeneSEZ erzeugt aus diesen Informationen 
	die entsprechenden Annotationen und f&uuml;gt sie dem Quellcode hinzu. Die 
	Generierung von XML-Konfigurationsdateien wird nicht unterst&uuml;tzt. 
	Es wird ein grundlegendes Verst&auml;ndnis der JPA-Technologie 
	vorausgesetzt.</para>
	
	<para>Im n&auml;chsten Abschnitt wird das UML-Profil f&uuml;r die Java 
	Plattform-Erweiterung JPA vorgestellt. Danach wird am Beispiel 
	einer Persistent Entity gezeigt was ausgew&auml;hlte Stereotypen bewirken und 
	wie die automatische Quellcode-Erg&auml;nzung den Modellierer unterst&uuml;tzt. 
	Die nachfolgenden Abschnitte beschreiben das Verhalten von Stereotypen, 
	welche die automatische Quellcode-Erg&auml;nzung verwenden. Sie k&ouml;nnen 
	unabh&auml;ngig voneinander gelesen werden. Als Beispiel dient durchg&auml;ngig 
	das Bank-Projekt.</para>
	
	<section>
		<title>Das UML-Profil "jpa"</title>
		
		<figure id="fig:de.genesez.platforms.java.jpa.profile">
			<title>UML-Profil der Java Plattform-Erweiterung JPA</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata align="center"
   					fileref="de.genesez.uml.profile.jpa.png"/>
   				</imageobject>
				<imageobject role="fo">
					<imagedata align="center" 
					fileref="profiles/de.genesez.uml.profile.jpa.svg" 
					scalefit="1" width="100%"/>
				</imageobject>
			</mediaobject>
		</figure>
		
		<para><xref linkend="fig:de.genesez.platforms.java.jpa.profile"/> zeigt das 
		UML-Profil f&uuml;r die Java Plattform-Erweiterung JPA. In dem Profil sind die 
		verschiedenen Stereotypen mit ihren TaggedValues und den dazugeh&ouml;rigen 
		Enumerations enthalten. Die Enumerations werden als Datentypen einiger 
		TaggedValues verwendet, falls diesen fest definierte Werte zugewiesen werden 
		m&uuml;ssen. Dadurch werden dem Modellierer direkt die m&ouml;glichen Werte 
		(am besten durch das Modellierungstool) vorgegeben und Tippfehler vermieden.
		</para>
	</section>
	
	<section>
		<title>Eine Einf&uuml;hrung - Die (Persistent) Entity</title>
		
		<para>Eine normale UML-Klasse wird zu einer (Persistent) Entity, indem 
		der Modellierer diese mit Hilfe des Stereotyps "jpaPersistentEntity" als 
		solche charakterisiert. Jede Persistent Entity ben&ouml;tigt einen 
		Prim&auml;rschl&uuml;ssel, der durch das Anh&auml;ngen des Stereotyps 
		<emphasis>jpaPrimaryKey</emphasis> an ein Attribut oder eine Methode 
		(field oder property access, siehe auch Kapitel &uuml;ber field/property 
		access-Umschaltung) festgelegt wird (siehe 
		<xref linkend="fig:de.genesez.platforms.java.jpa.simplePersistentEntity"/>).
		</para>
		
		<figure id="fig:de.genesez.platforms.java.jpa.simplePersistentEntity">
			<title>Persistent Entity mit den Stereotypen "jpaPersistentEntity" und "jpaPrimaryKey"</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata align="center"
   					fileref="de.genesez.platforms.java.jpa.simplePersistentEntity.png"/>
   				</imageobject>
				<imageobject role="fo">
					<imagedata align="center" 
					fileref="java/de.genesez.platforms.java.jpa.simplePersistentEntity.svg" 
					scalefit="1" width="100%"/>
				</imageobject>
			</mediaobject>
		</figure>
		
		<para>GeneSEZ erzeugt aus dieser Klasse folgenden Quellcode (ohne die automatisch 
		erzeugten getter und setter-Methoden):</para>
		
		<programlisting id="listing:de.genesez.platforms.java.jpa.simplePersistentEntity">
			@Entity
			@Table(name = "tbl_Bank")
			public class Bank implements Serializable {
			
				@Id
				@GeneratedValue(strategy = GenerationType.AUTO)
				private int sortCode;
				
				private String name;
				
				@Version
				private int version;
				
				public Bank {
				}
				
				[...]		
						
			}	
		</programlisting>
		
		<para>Die Generierung der Annotationen <emphasis>@Entity</emphasis> 
		sowie <emphasis>@Id</emphasis> lassen sich durch die beiden 
		verwendeten Stereotypen erkl&auml;ren. Woher kommen aber die anderen Stereotypen, 
		das Attribut <emphasis>version</emphasis>, der Standardkonstruktor und das 
		Interface <emphasis>Serializable</emphasis>?</para>
		
		<para>Die Antwort lautet <emphasis>automatische Quellcode-Erg&auml;nzung</emphasis>. 
		Gehen wir die verschiedenen Punkte der Reihe nach durch:</para>
		
		<itemizedlist>
		
			<listitem>
		
				<para><emphasis>@Table(name = "tbl_bank")</emphasis>: 
				Diese Annotation entsteht durch die Verwendung des Stereotyps 
				<emphasis>jpaPersistentEntity</emphasis>. Dies ist auch der Grund 
				warum <emphasis>jpaPersistentEntity</emphasis> kein 1:1 Mapping der Annotation 
				<emphasis>@Entity</emphasis> ist und auch nicht genauso benannt wurde. Er 
				enth&auml;lt zus&auml;tzlich die TaggedValues der Annotation <emphasis>@Table</emphasis>. 
				F&uuml;r die Zusammenfassung der beiden Annotationen zu einem Stereotyp 
				spricht vor allem, dass diese nicht getrennt verwendet werden. 
				Aufgrund der "convention over configuration" ist die Angabe von 
				<emphasis>@Table</emphasis> zwar optional, es k&ouml;nnen aber bei 
				bestimmten Klassennamen, welche Schl&uuml;sselworte in Datenbanken sind, Probleme 
				entstehen. Aus diesem Grund wird automatisch ein Prefix (Standard "tbl_") vor den 
				Klassennamen gesetzt und somit ein Tabellenname erzeugt, welcher Probleme 
				mit reservierten Schl&uuml;sselworten in Datenbanken verhindert.</para>
			
			</listitem>
			
			<listitem>
		
				<para><emphasis>Serializable</emphasis>: 
				Die Implementierung dieses Interfaces erm&ouml;glicht die Serialisierung der Klasse, 
				was beispielsweise bei der &Uuml;bertragung &uuml;ber ein Netzwerk ben&ouml;tigt wird. Der 
				Programmierer hat durch die Implementierung dieses Interfaces keinerlei 
				Mehraufwand. Durch die automatische Quellcode-Erg&auml;nzung muss die Implementierung 
				dieses Interfaces nicht modelliert werden. Das Modell wird frei von 
				technologiespezifischen Elementen gehalten.</para>
			
			</listitem>
			
			<listitem>
		
				<para><emphasis>@GeneratedValue(strategy = GenerationType.AUTO)</emphasis>: 
				Wie im Klassendiagramm zu sehen ist dem TaggedValue <emphasis>generatedValue</emphasis> 
				des Stereotyps <emphasis>jpaPrimaryKey</emphasis> der Wert <emphasis>true</emphasis> 
				zugewiesen worden (Default-Wert: false). Wie bei <emphasis>jpaPersistentEntity</emphasis> 
				verbergen sich auch hinter <emphasis>jpaPrimaryKey</emphasis> mehrere Annotationen, 
				weshalb der Stereotyp auch nicht <emphasis>jpaId</emphasis> genannt wurde. 
				Die Begr&uuml;ndung ist analog zu <emphasis>jpaPersistentEntity</emphasis>. Die Annotation 
				<emphasis>@GeneratedValue</emphasis> wird nur in Verbindung mit <emphasis>@Id</emphasis> 
				verwendet. Durch die <emphasis>convention over configuration</emphasis> wird die 
				Standard-Generierungsstrategie der Datenbank &uuml;berlassen. Dies spiegelt sich im 
				TaggedValue <emphasis>strategy</emphasis> wieder, der als Datentyp die Enumeration 
				<emphasis>jpaGenerationType</emphasis> mit dem Standardwert <emphasis>AUTO</emphasis> 
				besitzt.</para>
				
				<para>Bei diesem Beispiel wurden GeneSEZ die notwendigen Informationen zur Generierung 
				manuell vom Modellierer vorgegeben. Es wurden keine Werte logisch hergeleitet oder 
				automatisch erg&auml;nzt. Die Vorgabe der Standardstrategie basiert auf der JPA-Spezifikation.</para>
			
			</listitem>
			
			<listitem>
		
				<para><emphasis>@Version und das Attribut "version"</emphasis>: 
				Die automatische Quellcode-Erg&auml;nzung erzeugt f&uuml;r jede Persistent Entity, die &uuml;ber 
				kein Attribut mit <emphasis>@Version</emphasis> verf&uuml;gt, dieses Attribut und die 
				dazugeh&ouml;rige Annotation f&uuml;r das optimistische Locking. Es handelt sich wiederum um 
				ein technologiespezifisches Element, welches nicht modelliert werden muss.</para>
			
			</listitem>
			
			<listitem>
		
				<para><emphasis>Standardkonstruktor</emphasis>: 
				Zur Erzeugung von JavaBeans durch den Container ist ein parameterloser 
				Standardkonstruktor notwendig. Dieser muss bei einer JavaBean (also auch 
				SessionBeans, MessageDrivenBeans oder Seam-Komponenten) explizit 
				vorhanden sein. Auch um diese technologiespezifische Eigenheit k&uuml;mmert 
				sich die automatische Quellcode-Erg&auml;nzung.</para>
			
			</listitem>
		</itemizedlist>
		
		<para>Bei dieser Klasse gibt es bez&uuml;glich des Prim&auml;rschl&uuml;ssels zwei 
		notwendige Anmerkungen. Da mit der Bankleitzahl (sortCode) nicht gerechnet werden 
		soll, ist die Wahl des Datentyps <emphasis>String</emphasis> hier dem 
		<emphasis>int</emphasis> vorzuziehen. Aus Performanzgr&uuml;nden empfiehlt die 
		JPA-Spezifikation aber auf Prim&auml;rschl&uuml;ssel mit dem Datentyp String zu 
		verzichten. Hinzu kommt noch, dass die Vermischung von fachlichen und technischen 
		Merkmalen nicht besonders guter Programmierstil ist. Aus diesem Grund wird dem 
		Attribut <emphasis>sortCode</emphasis> mit Hilfe des Stereotyps 
		<emphasis>jpaColumn</emphasis> eine Unique-Beschr&auml;nkung verpasst 
		(fachlicher Prim&auml;rschl&uuml;ssel) und als technischer Prim&auml;rschl&uuml;ssel wird das Attribut 
		<emphasis>id</emphasis> mit dem Datentyp <emphasis>int</emphasis> hinzugef&uuml;gt. 
		F&uuml;r das n&auml;chste Beispiel (siehe 
		<xref linkend="fig:de.genesez.platforms.java.jpa.simplePersistentEntity2"/> und 
		<xref linkend="listing:de.genesez.platforms.java.jpa.simplePersistentEntity2" />) 
		wird noch ein Attribut mit dem Namen <emphasis>index</emphasis> hinzugef&uuml;gt, 
		welches den Platz der Bank in einem fiktiven Bewertungsindex repr&auml;sentiert.</para>
		
		<figure id="fig:de.genesez.platforms.java.jpa.simplePersistentEntity2">
			<title>Persistent Entity mit unique-Attribut und ohne jpaPrimaryKey</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata align="center"
   					fileref="de.genesez.platforms.java.jpa.simplePersistentEntity2.png"/>
   				</imageobject>
				<imageobject role="fo">
					<imagedata align="center" 
					fileref="java/de.genesez.platforms.java.jpa.simplePersistentEntity2.svg" 
					scalefit="1" width="100%"/>
				</imageobject>
			</mediaobject>
		</figure>
		
		<para>GeneSEZ erzeugt aus dieser Klasse folgenden Quellcode (ohne die automatisch 
		erzeugten getter und setter-Methoden):</para>
		
		<programlisting id="listing:de.genesez.platforms.java.jpa.simplePersistentEntity2">
			@Entity
			@Table(name = "tbl_Bank")
			public class Bank implements Serializable {
			
				@Id
				@GeneratedValue(strategy = GenerationType.AUTO)
				private int id;
				
				@Column(name = "sortCode", unique=true, nullable=false)
				private String sortCode;
				
				private String name;
				
				@Column(name = "bank_index")
				private String index;
				
				@Version
				private int version;
				
				public Bank {
				}
				
				[...]
								
			}	
		</programlisting>
		
		<para>Auch in diesem Beispiel war die automatische Quellcode-Erg&auml;nzung wieder 
		am Werke. Wir schauen uns die Punkte genauer an:</para>
		
		<itemizedlist>
			<listitem>
				<para><emphasis>@Id und @GeneratedValue(strategy = GenerationType.AUTO)</emphasis>: 
				GeneSEZ hat diese Annotationen automatisch an das Attribut <emphasis>id</emphasis> generiert, 
				weil ein Attribut mit diesem Namen in der Java Plattform-Erweiterung JPA f&uuml;r einen 
				Prim&auml;rschl&uuml;ssel reserviert ist, sofern kein anderes Attribut den Stereotyp 
				<emphasis>jpaPrimaryKey</emphasis> besitzt. Nur unter bestimmten Umst&auml;nde wird diese 
				automatische Quellcode-Erg&auml;nzung unterlassen (siehe <emphasis>jpaInheritance</emphasis>).
				</para>
				
				<para>Bei diesem Beispiel hat GeneSEZ alle notwendigen Informationen durch 
				das Modell erhalten (ein Attribut mit dem Namen <emphasis>id</emphasis> und dem Datentyp
				<emphasis>int</emphasis> existiert und gleichzeitig besitzt kein anderes Attribut dieser 
				PersistentEntity den Stereotyp <emphasis>jpaPrimaryKey</emphasis>). Es hat eine 
				vollautomatische Erg&auml;nzung stattgefunden.</para>
			
			</listitem>
			
			<listitem>
				<para><emphasis>@Column(name = "sortCode", unique=true, nullable=false)</emphasis>: 
				Die Beschr&auml;nkung <emphasis>unique</emphasis> verlangt, dass der Wert des entsprechende 
				Attributs ungleich <emphasis>null</emphasis> ist. Leider reicht das Setzen des 
				Annotation-Attributs <emphasis>unique</emphasis> auf den Wert <emphasis>true</emphasis> 
				nicht aus, um diese Folgebedingung zu erf&uuml;llen. GeneSEZ sorgt in diesem Fall 
				vollautomatisch f&uuml;r das Setzen des Annotation-Attributs <emphasis>nullable</emphasis> 
				auf den Wert <emphasis>false</emphasis> und l&auml;sst eine Kombination 
				<emphasis>unique=true, nullable=false</emphasis> bei der Generierung auch nicht zu.</para>			
			</listitem>
			
			<listitem>
				<para><emphasis>@Column(name = "bank_index")</emphasis>: 
				Der Name dieses Attributs ist ein reserviertes Schl&uuml;sselwort in der Datenbank 
				MySQL. Damit es nicht zu Problemen kommt, sorgt GeneSEZ daf&uuml;r, dass ein 
				anderer Spaltenname verwendet wird (Klassenname + "_" + Attribut-Name). Eine Festlegung 
				des Spaltennamens durch den Modellierer hat nat&uuml;rlich eine h&ouml;here Priorit&auml;t. 
				Es wird dabei von einem m&uuml;ndigen Modellierer ausgegangen, der &uuml;ber die 
				Problematik von Schl&uuml;sselwortkonflikten Bescheid wei&szlig;. Schlie&szlig;lich 
				treten die Konflikte nicht mit jeder verwendeten Datenbank auf.</para>
			
			</listitem>
		</itemizedlist>
		
		<figure id="fig:de.genesez.platforms.java.jpa.simplePersistentEntity3">
			<title>Persistent Entity ohne technischen Prim&auml;rschl&uuml;ssel</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata align="center"
   					fileref="de.genesez.platforms.java.jpa.simplePersistentEntity3.png"/>
   				</imageobject>
				<imageobject role="fo">
					<imagedata align="center" 
					fileref="java/de.genesez.platforms.java.jpa.simplePersistentEntity3.svg" 
					scalefit="1" width="100%"/>
				</imageobject>
			</mediaobject>
		</figure>
		
		<para>Ein Ziel der Java Plattform-Erweiterung JPA ist das Modell m&ouml;glichst frei von 
		technologiespezifischen Elementen zu halten. Dies wird nicht immer gelingen, aber 
		bei der Persistent Entity l&auml;sst sich noch etwas verbessern. Der technische 
		Prim&auml;rschl&uuml;ssel ist ein technologiespezifisches Element und h&auml;lt man sich an die 
		Trennung von fachlichen und technischen Merkmalen, dann l&auml;uft es in den meisten 
		Klassen auf ein zus&auml;tzliches Attribut hinaus. Um das Modell von 
		technologiespezifischen Elementen freizuhalten und den Arbeitsaufwand des Modellierers 
		zu verringern, sorgt die automatische Quellcode-Erg&auml;nzung daf&uuml;r, dass 
		jede Persistent Entity einen technischer Prim&auml;rschl&uuml;ssel bekommt (Name: id, 
		Datentyp: int), sofern der Modellierer kein anderes Attribut als Prim&auml;rschl&uuml;ssel 
		definiert hat. <xref linkend="fig:de.genesez.platforms.java.jpa.simplePersistentEntity3"/> 
		zeigt die Klasse Bank ohne technischen Prim&auml;rschl&uuml;ssel. Am generierten Quellcode &auml;ndert sich 
		gegen&uuml;ber dem letzten Beispiel nichts.</para>
		
	</section>
</section>