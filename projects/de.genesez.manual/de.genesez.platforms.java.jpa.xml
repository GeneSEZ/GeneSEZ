<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE section PUBLIC "-//OASIS//DTD Simplified DocBook XML V1.0//EN" "http://www.oasis-open.org/docbook/xml/simple/1.0/sdocbook.dtd">
<section id="de.genesez.platforms.java.jpa">
	
	<title>JPA (Java Persistence API)</title>
	
	<para>Die Java Plattform Erweiterung JPA erm&ouml;glicht dem Modellierer 
	das Modell mit persistenzspezifische Informationen auf Basis der 
	Java Persistence API (JPA) in der 
	<ulink url="http://java.sun.com/javaee/technologies/persistence.jsp">
	Version 1.0</ulink> zu versehen. GeneSEZ erzeugt aus diesen Informationen 
	die entsprechenden Annotationen und f&uuml;gt sie dem Quellcode hinzu. Die 
	Generierung von XML-Konfigurationsdateien wird nicht unterst&uuml;tzt. 
	F&uuml;r die nachfolgende Beschreibung wird ein grundlegendes Verst&auml;ndnis 
	der JPA-Technologie vorausgesetzt.</para>
	
	<section>
		<title>Das UML-Profil "jpa"</title>
		
		<figure id="fig:de.genesez.platforms.java.jpa.profile">
			<title>UML-Profil der Java Plattform-Erweiterung JPA</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata align="center"
   					fileref="images/de.genesez.platforms.java.jpa.profile.png"/>
   				</imageobject>
				<imageobject role="fo">
					<imagedata align="center" 
					fileref="images/de.genesez.platforms.java.jpa.profile.svg" 
					scalefit="1" width="100%"/>
				</imageobject>
			</mediaobject>
		</figure>
		
		<para><xref linkend="fig:de.genesez.platforms.java.jpa.profile"/> zeigt das 
		UML-Profil f&uuml;r die Java Plattform-Erweiterung JPA. In dem Profil sind die 
		verschiedenen Stereotypen mit ihren TaggedValues und den dazugeh&ouml;rigen 
		Enumerations enthalten. Die Enumerations werden als Datentypen einiger 
		TaggedValues verwendet, falls diesen fest definierte Werte zugewiesen werden 
		m&uuml;ssen. Dadurch werden dem Modellierer direkt die m&ouml;glichen Werte 
		(am besten durch das Modellierungstool) vorgegeben und Tippfehler vermieden.
		</para>
	</section>
	
	<section>
		<title>Eine Einf&uuml;hrung - Die (Persistent) Entity</title>
		
		<para>Eine normale UML-Klasse wird zu einer (Persistent) Entity, indem 
		der Modellierer diese mit Hilfe des Stereotyps "jpaPersistentEntity" als 
		solche charakterisiert. Jede Persistent Entity ben&ouml;tigt einen 
		Prim&auml;rschl&uuml;ssel, der durch das Anh&auml;ngen des Stereotyps 
		<emphasis>jpaPrimaryKey</emphasis> an ein Attribut oder eine Methode 
		(field oder property access, siehe auch Kapitel &uuml;ber field/property 
		access-Umschaltung) festgelegt wird (siehe 
		<xref linkend="fig:de.genesez.platforms.java.jpa.simplePersistentEntity"/>).
		</para>
		
		<figure id="fig:de.genesez.platforms.java.jpa.simplePersistentEntity">
			<title>Persistent Entity mit den Stereotypen "jpaPersistentEntity" und "jpaPrimaryKey"</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata align="center"
   					fileref="images/de.genesez.platforms.java.jpa.simplePersistentEntity.png"/>
   				</imageobject>
				<imageobject role="fo">
					<imagedata align="center" 
					fileref="images/de.genesez.platforms.java.jpa.simplePersistentEntity.svg" 
					scalefit="1" width="100%"/>
				</imageobject>
			</mediaobject>
		</figure>
		
		<para>GeneSEZ erzeugt aus dieser Klasse folgenden Quellcode (ohne die automatisch 
		erzeugten getter und setter-Methoden):</para>
		
		<programlisting id="listing:de.genesez.platforms.java.jpa.simplePersistentEntity">
			@Entity
			@Table(name = "tbl_Bank")
			public class Bank implements Serializable {
			
				@Id
				@GeneratedValue(strategy = GenerationType.AUTO)
				private int sortCode;
				
				private String name;
				
				@Version
				private int version;
				
				public Bank {
				}
				
				[...]		
						
			}	
		</programlisting>
		
		<para>Die Generierung der Annotationen <emphasis>@Entity</emphasis> 
		sowie <emphasis>@Id</emphasis> lassen sich durch die beiden 
		verwendeten Stereotypen erkl&auml;ren. Woher kommen aber die anderen Stereotypen, 
		das Attribut <emphasis>version</emphasis>, der Standardkonstruktor und das 
		Interface <emphasis>Serializable</emphasis>?</para>
		
		<para>Die Antwort lautet <emphasis>automatische Quellcode-Erg&auml;nzung</emphasis>. 
		Gehen wir die verschiedenen Punkte der Reihe nach durch:</para>
		
		<itemizedlist>
		
			<listitem>
		
				<para><emphasis>@Table(name = "tbl_bank")</emphasis>: 
				Diese Annotation entsteht durch die Verwendung des Stereotyps 
				<emphasis>jpaPersistentEntity</emphasis>. Dies ist auch der Grund 
				warum <emphasis>jpaPersistentEntity</emphasis> kein 1:1 Mapping der Annotation 
				<emphasis>@Entity</emphasis> ist und auch nicht genauso benannt wurde. Er 
				enth&auml;lt zus&auml;tzlich die TaggedValues der Annotation <emphasis>@Table</emphasis>. 
				F&uuml;r die Zusammenfassung der beiden Annotationen zu einem Stereotyp 
				spricht vor allem, dass diese nicht getrennt verwendet werden. 
				Aufgrund der "convention over configuration" ist die Angabe von 
				<emphasis>@Table</emphasis> zwar optional, es k&ouml;nnen aber bei 
				bestimmten Klassennamen, welche Schl&uuml;sselworte in Datenbanken sind, Probleme 
				entstehen. Aus diesem Grund wird automatisch ein Prefix (Standard "tbl_") vor den 
				Klassennamen gesetzt und somit ein Tabellenname erzeugt, welcher Probleme 
				mit reservierten Schl&uuml;sselworten in Datenbanken verhindert.</para>
			
			</listitem>
			
			<listitem>
		
				<para><emphasis>Serializable</emphasis>: 
				Die Implementierung dieses Interfaces erm&ouml;glicht die Serialisierung der Klasse, 
				was beispielsweise bei der &Uuml;bertragung &uuml;ber ein Netzwerk ben&ouml;tigt wird. Der 
				Programmierer hat durch die Implementierung dieses Interfaces keinerlei 
				Mehraufwand. Durch die automatische Quellcode-Erg&auml;nzung muss die Implementierung 
				dieses Interfaces nicht modelliert werden. Das Modell wird frei von 
				technologiespezifischen Elementen gehalten.</para>
			
			</listitem>
			
			<listitem>
		
				<para><emphasis>@GeneratedValue(strategy = GenerationType.AUTO)</emphasis>: 
				Wie im Klassendiagramm zu sehen ist dem TaggedValue <emphasis>generatedValue</emphasis> 
				des Stereotyps <emphasis>jpaPrimaryKey</emphasis> der Wert <emphasis>true</emphasis> 
				zugewiesen worden (Default-Wert: false). Wie bei <emphasis>jpaPersistentEntity</emphasis> 
				verbergen sich auch hinter <emphasis>jpaPrimaryKey</emphasis> mehrere Annotationen, 
				weshalb der Stereotyp auch nicht <emphasis>jpaId</emphasis> genannt wurde. 
				Die Begr&uuml;ndung ist analog zu <emphasis>jpaPersistentEntity</emphasis>. Die Annotation 
				<emphasis>@GeneratedValue</emphasis> wird nur in Verbindung mit <emphasis>@Id</emphasis> 
				verwendet. Durch die <emphasis>convention over configuration</emphasis> wird die 
				Standard-Generierungsstrategie der Datenbank &uuml;berlassen. Dies spiegelt sich im 
				TaggedValue <emphasis>strategy</emphasis> wieder, der als Datentyp die Enumeration 
				<emphasis>jpaGenerationType</emphasis> mit dem Standardwert <emphasis>AUTO</emphasis> 
				besitzt.</para>
				
				<para>Bei diesem Beispiel wurden GeneSEZ die notwendigen Informationen zur Generierung 
				manuell vom Modellierer vorgegeben. Es wurden keine Werte logisch hergeleitet oder 
				automatisch erg&auml;nzt. Die Vorgabe der Standardstrategie basiert auf der JPA-Spezifikation.</para>
			
			</listitem>
			
			<listitem>
		
				<para><emphasis>@Version und das Attribut "version"</emphasis>: 
				Die automatische Quellcode-Erg&auml;nzung erzeugt f&uuml;r jede Persistent Entity, die &uuml;ber 
				kein Attribut mit <emphasis>@Version</emphasis> verf&uuml;gt, dieses Attribut und die 
				dazugeh&ouml;rige Annotation f&uuml;r das optimistische Locking. Es handelt sich wiederum um 
				ein technologiespezifisches Element, welches nicht modelliert werden muss.</para>
			
			</listitem>
			
			<listitem>
		
				<para><emphasis>Standardkonstruktor</emphasis>: 
				Zur Erzeugung von JavaBeans durch den Container ist ein parameterloser 
				Standardkonstruktor notwendig. Dieser muss bei einer JavaBean (also auch 
				SessionBeans, MessageDrivenBeans oder Seam-Komponenten) explizit 
				vorhanden sein. Auch um diese technologiespezifische Eigenheit k&uuml;mmert 
				sich die automatische Quellcode-Erg&auml;nzung.</para>
			
			</listitem>
		</itemizedlist>
		
		<para>Bei dieser Klasse gibt es bez&uuml;glich des Prim&auml;rschl&uuml;ssels zwei notwendige Anmerkungen.
		Da mit der Bankleitzahl (sortCode) nicht gerechnet werden soll, ist die Wahl des Datentyps 
		<emphasis>String</emphasis> hier dem <emphasis>int</emphasis> vorzuziehen. Aus Performanzgr&uuml;nden 
		empfiehlt die JPA-Spezifikation aber auf Prim&auml;rschl&uuml;ssel mit dem Datentyp String zu verzichten.  
		Hinzu kommt auch noch, dass die Vermischung von fachlichen und technischen Merkmalen nicht 
		besonders sch&ouml;n ist. Aus diesem Grund wird das Attribut <emphasis>sortCode</emphasis> mit Hilfe des 
		Stereotyps <emphasis>jpaColumn</emphasis> eine Unique-Beschr&auml;nkung verpasst und f&uuml;r den 
		Prim&auml;rschl&uuml;ssel wird das Attribut <emphasis>id</emphasis> mit dem Datentyp <emphasis>int</emphasis> 
		hinzugef&uuml;gt. F&uuml;r das n&auml;chste Beispiel (siehe <xref linkend="fig:de.genesez.platforms.java.jpa.simplePersistentEntity2"/> 
		und <xref linkend="listing:de.genesez.platforms.java.jpa.simplePersistentEntity2" />) wird noch 
		ein Attribut mit dem Namen <emphasis>index</emphasis> hinzugef&uuml;gt, welches den Platz der Bank 
		in einem fiktiven Bewertungsindex repr&auml;sentiert.</para>
		
		<figure id="fig:de.genesez.platforms.java.jpa.simplePersistentEntity2">
			<title>Persistent Entity mit den Stereotypen "jpaPersistentEntity" und "jpaPrimaryKey"</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata align="center"
   					fileref="images/de.genesez.platforms.java.jpa.simplePersistentEntity2.png"/>
   				</imageobject>
				<imageobject role="fo">
					<imagedata align="center" 
					fileref="images/de.genesez.platforms.java.jpa.simplePersistentEntity2.svg" 
					scalefit="1" width="100%"/>
				</imageobject>
			</mediaobject>
		</figure>
		
		<para>GeneSEZ erzeugt aus dieser Klasse folgenden Quellcode (ohne die automatisch 
		erzeugten getter und setter-Methoden):</para>
		
		<programlisting id="listing:de.genesez.platforms.java.jpa.simplePersistentEntity2">
			@Entity
			@Table(name = "tbl_Bank")
			public class Bank implements Serializable {
			
				@Id
				@GeneratedValue(strategy = GenerationType.AUTO)
				private int id;
				
				@Column(name = "sortCode", unique=true, nullable=false)
				private String sortCode;
				
				private String name;
				
				@Column(name = "bank_index")
				private String index;
				
				@Version
				private int version;
				
				public Bank {
				}
				
				[...]
								
			}	
		</programlisting>
		
		<para>Auch in diesem Beispiel war die automatische Quellcode-Erg&auml;nzung wieder 
		am Werke. Wir schauen uns die Punkte genauer an:</para>
		
		<itemizedlist>
			<listitem>
				<para><emphasis>@Id und @GeneratedValue(strategy = GenerationType.AUTO)</emphasis>: 
				GeneSEZ hat diese Annotationen automatisch an das Attribut <emphasis>id</emphasis> generiert, 
				weil ein Attribut mit diesem Namen in der Java Plattform-Erweiterung JPA f&uuml;r einen 
				Prim&auml;rschl&uuml;ssel reserviert ist, sofern kein anderes Attribut den Stereotyp 
				<emphasis>jpaPrimaryKey</emphasis> besitzt. Nur unter bestimmten Umst&auml;nde wird diese 
				automatische Quellcode-Erg&auml;nzung unterlassen (siehe <emphasis>jpaInheritance</emphasis>).
				</para>
				
				<para>Bei diesem Beispiel hat GeneSEZ alle notwendigen Informationen durch 
				das Modell erhalten (ein Attribut mit dem Namen <emphasis>id</emphasis> und dem Datentyp
				<emphasis>int</emphasis> existiert und gleichzeitig besitzt kein anderes Attribut dieser 
				PersistentEntity den Stereotyp <emphasis>jpaPrimaryKey</emphasis>). Es hat eine 
				vollautomatische Erg&auml;nzung stattgefunden.</para>
			
			</listitem>
			
			<listitem>
				<para><emphasis>@Column(name = "sortCode", unique=true, nullable=false)</emphasis>: 
				Die Beschr&auml;nkung <emphasis>unique</emphasis> verlangt, dass der Wert des entsprechende 
				Attributs ungleich <emphasis>null</emphasis> ist. Leider reicht das Setzen des 
				Annotation-Attributs <emphasis>unique</emphasis> auf den Wert <emphasis>true</emphasis> 
				nicht aus, um diese Folgebedingung zu erf&uuml;llen. GeneSEZ sorgt in diesem Fall 
				vollautomatisch f&uuml;r das Setzen des Annotation-Attributs <emphasis>nullable</emphasis> 
				auf den Wert <emphasis>false</emphasis> und l&auml;sst eine Kombination 
				<emphasis>unique=true, nullable=false</emphasis> bei der Generierung auch nicht zu.</para>			
			</listitem>
			
			<listitem>
				<para><emphasis>@Column(name = "bank_index")</emphasis>: 
				Der Name dieses Attributs ist ein reserviertes Schl&uuml;sselwort in der Datenbank MySQL. Damit 
				es nicht zu Problemen kommt, sorgt GeneSEZ daf&uuml;r, dass ein anderer Spaltenname verwendet wird 
				(Klassenname + "_" + Attribut-Name). Eine Festlegung des Spaltennamens durch den Modellierer 
				hat nat&uuml;rlich eine h&ouml;here Priorit&auml;t. Es wird dabei von einem m&uuml;ndigen Modellierer ausgegangen, 
				der &uuml;ber die Problematik von Schl&uuml;sselwortkonflikten Bescheid wei&szlig;. Schlie&szlig;lich treten die 
				Konflikte nicht mit jeder verwendeten Datenbank auf.</para>
			
			</listitem>
		</itemizedlist>
		
	</section>
</section>