/**
 * 	modificates the metamodel before generation of the source code  
 *  
 * @author	andre pflueger
 * @date	2009-03-17
 */

// based on genesez meta model
import gcore;

extension de::genesez::platforms::java::ejb3::scripts::Attribute;
extension de::genesez::platforms::java::ejb3::scripts::Interface;
extension de::genesez::platforms::java::ejb3::scripts::Class;
extension de::genesez::platforms::java::scripts::Naming;

Void modifications(MModel this) :
	this.nestedPackage.modifications() ->
	this.classifier.typeSelect(MClass).modifications();
	
Void modifications(MPackage this) :
	this.nestedPackage.modifications() ->
	this.classifier.typeSelect(MClass).modifications();
	
Void modifications(MClass this) :
	addStandardConstructor() ->
	addMessageListener() ->
	addSessionBeanInterfaces() ->
	//checkInterceptorClass() ->
	this.property.typeSelect(MAttribute).modifications() ->
	this.operation.typeSelect(MOperation).modifications();
	
Void modifications(MOperation this) :
	checkTimerStereotype();
	
Void modifications(MAttribute this) :
	checkEJBStereotype() ->
	checkTimerServiceStereotype();

Void modifications(MInterface this) :
	Void;

/**
	Hier werden Methoden für die Verarbeitung der Interceptorklassen auf Xtend-Ebene definiert.
	Diese Funktionalität bleibt zunächst auf XPand-Ebene.
	Grund: Zu viel Aufwand bei zu wenig Ergebnis...bisher auf XPand-Ebene schöner zu lösen,
	da dort direkt Code in die Methodenrümpfe geschrieben werden kann.
*/
/**
Void checkInterceptorClass(MClass this) :
	hasStereotype("ejb3ClassInterceptor") 
		? ( hasUtilizableValue("ejb3ClassInterceptor", "interceptors")
			? ( hasTaggedValue("ejb3ClassInterceptor", "generateDefault", "true") &&
				( this.operation.exists(e|e.hasTaggedValue("ejb3Callback", "external", "true")) ||
				hasUtilizableValue("ejb3ClassInterceptor", "methods") ) 
				? addInterceptorClass()
				: ""
			)				
			: ""
		)
		: "";
*/

		
