// import gcore metamodel
import gcore;

extension org::genesez::platform::common::AccessHelper;
extension org::genesez::platform::common::GlobalStore;

/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	public extend functions
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 */

/**
 * 	process all packages
 */
MModel makeAspects(MModel m): 
	saveModel(m)->
	m.nestedPackage.processPackage()
	;

/**
 * 	process all packages recursively, only consider taged values belonging to <<mdsd>>
 */
private MPackage processPackage(MPackage p) :
	p.classifier.select(sc|sc.stereotype.name.contains("mdsd")).processClassifier()->
	p.nestedPackage.processPackage()->
	p.classifier.aspect._mapClassAspect();
	
/**
 * 	transform tagged values of stereotype <<mdsd>> to aspects
 */
private MClassifier processClassifier(MClassifier c) :
	c.setAspect(
		c.taggedValue.reject(
			tv|(tv.value.toLowerCase() == "false") || (tv.tag.type.toLowerCase() != "boolean")
		).makeAspect()
	)->
	c.property.typeSelect(MAttribute).select(attr|attr.hasStereotype("key")).makeAspect("generate", "key")->
	c.property.typeSelect(MAttribute).select(attr|attr.hasStereotype("key")).makeAspect("generate", "immutable")
	;
	
private create MAspect makeAspect(MTaggedValue tv) :
	tv.owningElement.setAspect({this}) ->
	setDomain(tv._getDomain())->
	setName(tv._getName());
	
private create MAspect makeAspect(MElement e, String domain, String name) :
	e.setAspect({this})->
	setDomain(domain)->
	setName(name);

/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	helper functions
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 */

/**
 * 	helper for tagged value processing
 */	
private _getDomain(MTaggedValue tv) :
	tv.tag.name.split("\\.").first();
	
/**
 * 	helper for tagged value processing
 */	
private _getName(MTaggedValue tv) :
	let l = tv.tag.name.split("\\.") :
	 l.size > 1 ? l.get(1) : tv.tag.name;
	
/**
 * 	this is THE START of interesting functions because aspects define
 *	pim to psm mapping in our concept
 */
private _mapClassAspect(MAspect aspect) :
	aspect.domain == "persistent" ?
		aspect._mapPersistence() :
	(aspect.domain == "ui" ?
		aspect._mapUi() :
		aspect);
		
private _mapPersistence(MAspect aspect) :
	let c = (MClass) aspect.element :
	c._hasNoPersistentSupertype() ?
		(
			c.property.add(
				makeAttribute(c, "PersistId_", "persistId", "Hibernate Object Identifier")
			)->
			c.property.add(
				makeAttribute(c, "PersistVersion_", "persistVersion", "Hibernate Object Version")
			)->
			makeAttribute(c, "PersistId_", "persistId", "Hibernate Object Identifier").makeAspect("persistent", "id")->
			makeAttribute(c, "PersistVersion_", "persistVersion", "Hibernate Object Version").makeAspect("persistent", "version")
		) : null
		;

private _hasNoPersistentSupertype(MClass c) :
	false;//(c.supertype.size == 0) || (c.supertype.select(s|s.hasAspect("persistent")).isEmpty);


private _mapUi(MAspect aspect) :
	aspect.element;

create MOperation makeOperation() :
	this;
	
create MAttribute makeAttribute(MClassifier c, String xid, String name, String comment) :
	setXmiGuid(xid + c.xmiGuid)->
	setName(name)->
	c.property.add(this) -> /*setClassifier(c)->*/
	setMultiplicity(1)->
	setType(retrieveModel().primitiveTypes.selectFirst(ty|ty.name.startsWith("Integer")))->
	setVisibility("private")->
	setFinal(false)->
	setOwnedComment(
			{/*makeComment("c_" + xid + c.xmiGuid).setAnnotation(comment).setOwningElement(this)*/}
		)->
	setAspect({makeAspect(this, "generate", "immutable")})->
//	info(this.name + ": " + this.aspect)->
	this;

create MComment makeComment(String xid) :
	setXmiGuid(xid)->
	this;
		