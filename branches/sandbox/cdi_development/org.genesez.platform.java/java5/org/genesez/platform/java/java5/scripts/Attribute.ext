/**
 * 	functions for changing or adding properties
 *  
 * @author	andre pflueger
 * @date	2010-01-13
 */

// based on genesez meta model
import gcore;

extension org::genesez::platform::java::scripts::Naming;
extension org::genesez::platform::common::m2t::Helper;
extension org::genesez::platform::common::log::Log;
extension org::genesez::platform::common::m2m::CreateTemplate;
extension org::genesez::platform::common::m2m::CreateBasics;
extension org::genesez::platform::common::m2m::MakeElement;
extension org::genesez::platform::common::AccessHelper;
extension org::genesez::platform::java::java5::scripts::Operation;
extension org::genesez::platform::java::java5::scripts::Stereotypes;

/**
 *	this method assignes true to the atribute property static if it is
 *	final, single value typed and has a default value
 *	this is a kind of memory optimization
 
 *	@param	this		instance of MAttribute
 */
Void optimizeFinalAttributesWithDefaultValue(MAttribute this) :
	this.isSingleValuedType() && this.final && this.hasDefaultValue() 
		? this.setStatic(true)
		: "";	

/**
 *	this method adds an accessor stereotype for static final attributes
 *	with setter=false
 *	if there is a accessor available for the getter value, it will be adopted
 *	if there is a accessor available with setter=true, a warning is created
 *
 *	optimizeFinalAttributesWithDefaultValue should be called prior to this method
 *
 *	@param	this		instance of MAttribute
 */
Void addAccessorForStaticFinalAccessor(MAttribute this) :
	this.final && this.static
		? (
			this.hasStereotype("accessor")
				? (
					this.hasTaggedValue("accessor", "setter", "true")
						? logWarn("generation of a setter for the static final attribute '" + this.name + "' in class '" + this.classifier.name + "' makes no sense!")
						: ""
				)
				: createAccessor(this.generateGetter().toString(), "false")
		)
		: "";	

/**
 *	this method creates a getter operation with an internal stereotype 
 *	for the generation of getter operations according to the stereotype
 *	"accessor" of the genesez profile
 *
 *	this operation will be generated by the normal operation template but there
 *	will be implemented code instead of protected regions (template identifies these
 *	operations by the internal stereotype)
 *
 *	using of generateGetter methods secures generateGetterSetter logic
 *	this method must be executed before createGetterSetterOperations for MClass (not yet
 *	implemented; accessor sereotypes on MClass instances will be considered but not removed)
 *
 *	@param	this		instance of MProperty
 *	@param	container	container for the getter operation
 */	
Void createGetterOperation(MProperty this, MClassifier container) :
	this.generateGetter()
		? (
			let o = container.makeOperation(this.asGetter(), "public", this.unique, this.ordered) :
				o.addInternalStereotype("http://www.genesez.de/GetterOperation") //->
			//this.setTaggedValue("accessor", "getter", "false")
		)
		: "";

/**
 *	this method creates a setter operation with an internal stereotype 
 *	for the generation of setter operations according to the stereotype
 *	"accessor" of the genesez profile
 *
 *	this operation will be generated by the normal operation template but there
 *	will be implemented code instead of protected regions (template identifies these
 *	operations by the internal stereotype)
 *
 *	using of generateSetter methods secures generateGetterSetter logic
 *	this method must be executed before createGetterSetterOperations for MClass (not yet
 *	implemented; accessor sereotypes on MClass instances will be considered but not removed)
 *
 *	@param	this		instance of MAttribute
 *	@param	container	container for the setter operation
 */	
Void createSetterOperation(MAttribute this, MClassifier container) :
	this.generateSetter()
		? (
			let o = container.makeOperation(this.asSetter(), "public", this.unique, this.ordered) :
				(let p = o.createParameter(o.xmiGuid+"_parameter_"+this.name.asTypeName(), this.name.asTypeName()) :
					p.setType(this.cloneType()) ->
					p.setMultiplicity(this.multiplicity) ->
					p.setOrdered(this.ordered) ->
					p.setUnique(this.unique)
				) ->
				o.addInternalStereotype("http://www.genesez.de/SetterOperation") //->
			//this.setTaggedValue("accessor", "setter", "false")
			/*this.hasTaggedValue("accessor", "getter", "false") && this.hasTaggedValue("accessor", "setter", "false")
				? this.removeAccessorStereotype()
				: "" */
		)
		: "";

/**
  *	
  */
Void checkFieldAccess(MProperty this) :
	fieldAccess()
		? (
			// field access -> all annotations are located at the attribute declaration
			getGetter().copyStereotypesToProperty(this) ->
			getSetter().copyStereotypesToProperty(this)
		)
		: (
			/** property access -> all annotations are located at the automatic generated getter/automatic 
			  * setter/existing getter/existing setter method of the attribute
			  *
			  *	if there is no automatic generated getter/setter or existing getter/setter the automatic 
			  *	generation of the getter method will be activated
			  *
			  *	if automatic generated getter/automatic generated setter method is available, the stereotypes/
			  *	taggedValues are saved at the attribute (code generation reacts on fieldAccess variable)
			  *	if existing getter/existing setter method are available, the stereotypes/taggedValues are
			  *	saved at the operation
			  */
			!this.generateGetter() && !this.generateSetter() && getGetter() == null && getSetter() == null
				? (
					this.taggedValue.selectFirst(e|e.tag.stereotype.name == "accessor" && e.tag.name == "getter").setValue("true") ->
					info("property access type is selected but attribute "+this.name+" in class "+this.classifier.name+" has no getter/setter method. A getter method will be generated automatically.")
				)
				: "" ->
			this.generateGetter() || this.generateSetter()
				? (
					getGetter().copyStereotypesToProperty(this) ->
					getSetter().copyStereotypesToProperty(this)
				)
				: (
					let o = getGetter() :
						o != null
							? (
								copyStereotypesToOperation(this, o) ->
								(
								let q = getSetter() :
									q != null
										? copyStereotypesToOperation(q, o)
										: ""
								)
							)
							: (
								let p = getSetter() :
									p != null
										? (
											copyStereotypesToOperation(this, p)
										)
										: error("no method for attribute +"+this.name+" in class "+this.classifier.name+" for annotation with property access found")
							)
				)
			
		);

/**
 *	clones the stereotypes of the property and adds them to the operation
 *	
 *	@param	this	instance of MProperty
 *	@param	o		target operation for the stereotypes
 */
Void copyStereotypesToOperation(MProperty this, MOperation o) :
	o != null && this != null
		? (
			/** copy the stereotypes and taggedValues from the attribute
			  * to the operation and remove them at the attribute
			  *
			  *	perhabs it makes sense to copy only the stereotypes really
			  *	evaluated by the cartridge in attribute template
			  *	Are there any stereotypes which can be seriously annotated to the getter
			  *	method but not to the existing attribute?
			  */
			o.stereotype.addAll(this.stereotype) ->
			o.taggedValue.addAll(this.taggedValue) ->
			this.stereotype.removeAll(this.stereotype) ->
			this.taggedValue.removeAll(this.taggedValue) 
		)
		: "";

/**
 *	returns the getter operation
 */
MOperation getGetter(MProperty this) :
	this.classifier.operation.selectFirst(e|e.isGetter() && e.parameter.isEmpty);

/**
 *	returns the setter operation
 */
MOperation getSetter(MProperty this) :
	this.classifier.operation.selectFirst(e|e.isSetter() && e.parameter.size == 1);

/**
 *	clones the data type of the MProperty
 *
 *	@param	this	instance of MProperty
 *	@return			cloned MType instance of the MProperty
 */
MType cloneType(MProperty this) :
	this.type.isPrimitiveType()
		? createPrimitiveType(this.model(), this.type.asTypeName())
		: (
			this.type.isExternalType() 
				? createExternal(this.model(), this.type.asTypeName())
				: (
					this.type.isClassifier() || this.type.isEnumeration()
						? allClassifiers(this.model()).selectFirst(e|e.name == this.type.asTypeName()) 
						: error("clone of return type has reached a not implemented MType: "+this.type)
				)
		);