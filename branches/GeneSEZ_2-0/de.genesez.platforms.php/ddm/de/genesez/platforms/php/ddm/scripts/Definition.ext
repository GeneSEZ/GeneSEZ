/**
 * Helper file for ddm (dynamic data model) definitions covering:
 * - model access
 * - data conversions
 * - naming conventions
 * 
 * @todo	ensure that generated order of ddm class definition is according the inheritance hierarchy
 * @author	tobias haubold
 * @date	2009-06-09
 */
import gcore;

extension de::genesez::platforms::common::AccessHelper;

/**
 * @return	the file name of the php file with the ddm definitions
 */
String filename(MModel this) : "ddm.definitions.php";

/**
 * @return	a collection with all data types to be generated as ddm types
 */
List[MDataType] types(MPackage this) :
	{}.addAll( nestedPackage.types() ).flatten().addAll( classifier.typeSelect(MDataType) );

/**
 * @return	a collection with all classes to be generated as ddm classes
 */
List[MClass] classes(MPackage this) :
	{}.addAll( nestedPackage.classes() ).flatten().addAll( classifier.typeSelect(MClass) );

/**
 * @return	a collection with all attributes to be generated as ddm attributes
 */
List[MAttribute] attributes(MPackage this) : 
	{}.addAll( nestedPackage.classes().property.typeSelect(MAttribute) )
		.addAll( classifier.typeSelect(MClass).property.typeSelect(MAttribute) ).flatten();

/**
 * @return	a collection with all associations to be generated as ddm associations
 */
List[MAssociation] associations(MPackage this) : 
	let assocs = {} :
		classes().property.typeSelect(MAssociationRole).association.forAll(
			e|assocs.contains(e) ? false : ( assocs.add(e) -> true) ) ->
	assocs;

/**
 * @return	the separator for the generated qualified names of ddm types and ddm classes
 */
String qualifiedNameSeparator() : "_";

/**
 * @return	the qualified name of a package
 */
String name(MPackage this) : 
	nestingPackage != null
		? nestingPackage.name + qualifiedNameSeparator() + name
		: name;

/**
 * @return	the qualified name of a classifier
 */
String name(MClassifier this) : package().name() + qualifiedNameSeparator() + name;

/**
 * @return	the qualified name of an attribute
 */
String name(MAttribute this) : classifier.name() + qualifiedNameSeparator() + name;

/**
 * @return	a human readable representation of an association
 */
String name(MAssociation this) :
	end.first().classifier.name() + " [ " + end.first().oppositeMultiplicity + " ] " + " - "
	 + " [ " + end.first().multiplicity + " ] " + ((MClassifier)end.first().type).name();

/**
 * @return	the basetype of a data type to be generated as ddm type
 */
String basetype(MDataType this) : 
	stereotype.select( e| {"boolean", "integer", "string"}.contains(e.name.toLowerCase()) ).first().name;

/**
 * - if the stereotype 'type' is not applied, an empty constraint is generated
 * - if the stereotype 'type' is applied, but the tag 'constraint' has no value, the name of the 
 *   data type is used
 * - else the tagged value 'constraint' is used
 * @return	the constraint of a data type to be generated as ddm type
 */
String constraint(MDataType this) : 
	stereotype.exists( e|e.name.toLowerCase() == "type" )
	? ( taggedValue.select( e|e.tag.name.toLowerCase() == "constraint" ).first().value == Void
		? name
		: taggedValue.select( e|e.tag.name.toLowerCase() == "constraint" ).first().value
	) : "";

/**
 * - if the stereotype 'class' is not applied, the class name is used
 * - if the stereotype 'class' is applied but the tag 'view' has no value, the class name is used
 * - else the tagged value 'view' is used
 * @return	the name of the view for a class to be generated as ddm class
 */
String view(MClass this) :
	stereotype.exists( e|e.name.toLowerCase() == "class" )
	&& taggedValue.select( e|e.tag.name.toLowerCase() == "view" ).first().value != Void
	? taggedValue.select( e|e.tag.name.toLowerCase() == "view" ).first().value
	: name;

/**
 * @return	the cardinality of the given gcore multiplicity value
 */
String cardinality(Integer this) :
	this == 1 ? "0..1" : "N";


// - - naming conventions - - - - - - - - - - - - - - - - - - - - - - - - - - -

/**
 * @return	the formatted name of a base type
 */
String asBaseType(String this) : toUpperCase();

/**
 * @return	the formatted name of a view
 */
String asViewName(String this) : toFirstUpper();

/**
 * @return	the formatted name of a column name
 */
String asColumnName(String this) : toFirstUpper();

/**
 * @return	the formatted name of a data type
 */
String asName(MDataType this) : name.toFirstUpper();

/**
 * @return	the formatted name of a class
 */
String asName(MClass this) : name.toFirstUpper();

/**
 * @return	the formatted name of an attribute
 */
String asName(MAttribute this) : name.toFirstUpper();

/**
 * @return	the formatted name of an association
 */
String asName(MAssociation this) : name.toFirstUpper();
