/**
 * UML 2 GeneSEZ transformation script.
 * Transforms UML State Models models into GeneSEZ models.
 * 
 * @author	georg beier
 */

// uses ecore metamodel
import ecore;
// uses uml metamodel - the source metamodel
import uml;
// uses GeneSEZ metamodel - the target metamodel
import gcore;

// use logging
extension de::genesez::platforms::common::log::Log;

// access helper functions
extension de::genesez::adapter::uml2::uml2genesez;

/**
 * create a GeneSEZ StateMachine from UML Behavior
 * @param sm UML Behavior subclass StateMachine
 * @context the Classifier that owns the behavior
 * @return newly generated MStateMachine
 */
MStateMachine transformBehavior(StateMachine sm, MClassifier this):
//	trace("transforming UML StateMachine for class " + name + " in package " + owningContext) ->
	let msm = makeStateMachine(sm, this) :
		ownedBehavior.add(msm) ->
		msm.atomize() ->
		msm.display()
		;

/**
 * create a GeneSEZ Activity from UML Behavior
 * @param a UML Behavior subclass Activity
 * @context the Classifier that owns the behavior
 * @return newly generated MActivity
 */
MActivity transformBehavior(Activity a, MClassifier this):
	info("transforming UML Activity for class " + name);

/**
 * create a GeneSEZ Activity from UML Behavior
 * @param a UML Behavior subclass Activity
 * @context the Package that owns the behavior
 * @return newly generated MActivity
 */
MActivity transformBehavior(Activity a, MPackage this):
	info("transforming UML unbound Activity");
	
/**
 * create nothing, just catch unimplemented behavior
 * @param a any UML Behavior subclass 
 * @context any Context that owns the behavior
 * @return null
 */
MActivity transformBehavior(Behavior a, MDefinitionContext this):
	error("found unknown behaviour") ->
	null;

/**
 * create StateMachine
 * @param sm uml::StateMachine
 * @context none
 * @return new MStateMachine
 */
private create MStateMachine makeStateMachine(StateMachine sm, MDefinitionContext ctx) :
	transformBasics(sm)->
	ctx.ownedBehavior.add(this) ->
	sm.region.transition.makeTransition(this) ->
	this;

 
/**
 * create the right kind of State
 * @param  uml::State
 * @context none
 * @return right kind of new MState 
 */
private MState makeState(State s, MStateMachine sm) :
	switch {
		case s.isComposite:
			makeCompositeState(s, sm)
		case s.isSimple:
			makeLeafState(s, sm)
		default:
			error("unsupported State " + s)
	};

/**
 * create the right kind of Pseudostate
 * @param  uml::Pseudostate
 * @context none
 * @return right kind of new MState 
 */
private MState makeState(Pseudostate ps, MStateMachine sm) :
	switch {
		case ps.kind.toString() == "initial":
			makeInitialState(ps, sm)
		case ps.kind.toString().endsWith("History"):
			makeHistoryState(ps, sm)
		default:
			error("unsupported Pseudostate " + ps)
	};
	
/**
 * propagate to the referenced state
 * @param  uml::ConnectionPointReference
 * @context none
 * @return right kind of new MState 
 */
private MState makeState(Vertex v, MStateMachine sm) :
	error("should never be called: " + v);

/**
 * propagate to the referenced state
 * @param  uml::ConnectionPointReference
 * @context none
 * @return right kind of new MState 
 */
private MState makeState(ConnectionPointReference ref, MStateMachine sm) :
	ref.state.makeState(sm);

/**
 * create Final State
 * @param  uml::FinalState
 * @context none
 * @return new MLeafState 
 */
private create MFinalState makeState(FinalState s, MStateMachine sm) :
 	transformBasics(s) ->
 	sm.smstate.add(this) ->
 	setName(stateName(s, "_f")) ->
 	this;
 

/**
 * create Composite State 
 * @param  uml::State
 * @context none
 * @return new MCompositeState
 */
private create MCompositeState makeCompositeState(State s, MStateMachine sm) :
 	transformBasics(s) ->
 	sm.smstate.add(this) ->
 	s.region.transition.makeTransition(sm) ->
	linkActions(s, sm) ->
	(s.container.state != null ?
		setSuperstate((MCompositeState) makeState(s.container.state, sm)) :
		null) ->
 	this;

/**
 * create Leaf State
 * @param s uml::State
 * @context none
 * @return new MLeafState 
 */
private create MLeafState makeLeafState(State s, MStateMachine sm) :
// 	debug("\t\t Leaf State " + s.name) ->
 	transformBasics(s) ->
 	sm.smstate.add(this) ->
	linkActions(s, sm) ->
	(s.container.state != null ?
		setSuperstate((MCompositeState) makeState(s.container.state, sm)) :
		null) ->
 	this;

/**
 * create Initial State 
 * @param  uml::Pseudostate
 * @context none
 * @return new Metaobject
 */
 private create MInitialState makeInitialState(Pseudostate ps, MStateMachine sm) :
// 	debug("\t\t Initial state " + ps.name) ->
 	transformBasics(ps) ->
 	sm.smstate.add(this) ->
	setName(psName(ps, "_i")) ->
	(ps.container.state != null ?
		setSuperstate((MCompositeState) makeState(ps.container.state, sm)) :
		null) ->
 	this;

/**
 * create History State 
 * @param  uml::Pseudostate
 * @context none
 * @return new Metaobject 
 */
 private create MHistoryState makeHistoryState(Pseudostate ps, MStateMachine sm) :
 	transformBasics(ps) ->
 	sm.smstate.add(this) ->
 	setDeep(ps.kind.toString() == "deepHistory") ->
	setName(psName(ps, "_h")) ->
	(ps.container.state != null ?
		setSuperstate((MCompositeState) makeState(ps.container.state, sm)) :
		null) ->
 	this;
 
/**
 * link actions into MState, creating them if not present 
 * @param  gcore::MState
 * @param  uml::State
 * @param  gcore::MStateMachine	the owning state machine
 * @context none
 * @return new Metaobject
 */
private linkActions(MState ms, State s, MStateMachine sm) :
 	s.entry != null ? ms.setEntry(s.entry.makeActivity(sm)) : null ->
 	s.exit != null ? ms.setExit(s.exit.makeActivity(sm)) : null ->
 	s.doActivity != null ? ms.setDo(s.doActivity.makeActivity(sm)) : null ;

/**
 * build a meaningful default name for an unnamed Pseudostate 
 * @param  uml::Pseudostate
 * @context none
 * @return name
 */
private String psName(Pseudostate ps, String prefix) :
 	ps.name == "" ?
 		prefix + 
 			(switch {
 				case ps.container.stateMachine != null:
 					ps.container.stateMachine.name
 				case ps.container.state != null:
 					ps.container.state.name
 				default:
 					error("free floating state " + ps)
 			}).toFirstUpper()
 		: ps.name; 

/**
 * build a meaningful default name for an unnamed Pseudostate 
 * @param  uml::Pseudostate
 * @context none
 * @return name
 */
private String stateName(State s, String prefix) :
 	s.name == "" ?
 		prefix + 
 			(switch {
 				case s.container.stateMachine != null:
 					s.container.stateMachine.name
 				case s.container.state != null:
 					s.container.state.name
 				default:
 					error("free floating state " + s)
 			}).toFirstUpper()
 		: s.name; 
 
/**
 * create transition
 * @param t uml::transition
 * @param  gcore::MStateMachine	the owning state machine
 * @context
 * @return new Metaobject
 */
 private create MTransition makeTransition(Transition t, MStateMachine sm) :
 	transformBasics(t) ->
 	setKind(t.kind.toString().subString(0,3)) ->
	setSource(makeState(t.source, sm)) ->
	setTarget(makeState(t.target, sm)) ->
	setName(kind + ": " + source.name + " -> " + target.name) ->
	sm.smtransition.add(this) ->
 	t.effect != null ? setAction(t.effect.makeActivity(sm)): null ->
 	t.guard != null ? setGuard(t.guard.makeGuard(sm)) : null ->
	t.trigger.event.isEmpty ? 
		null : trigger.addAll(t.trigger.event.makeEvent(sm)) ->
 	this;
 
/**
 * create a new MActivity  
 * @param b uml::Behavior, usually the Activity or Action linked to this transition
 * @param sm gcore::MStateMachine	the owning state machine
 * @context
 * @return new Metaobject
 */
private create MActivity makeActivity(Behavior bh, MStateMachine sm) :
	transformBasics(bh) ->
//	debug("		activity: " + name) ->
	sm.ownedBehavior.add(this) ->
	this; 
 
/**
 * create a new MGuard  
 * @param g uml::Constraint guard attached to transition
 * @param sm gcore::MStateMachine	the owning state machine
 * @context
 * @return new Metaobject
 */
private create MGuard makeGuard(Constraint guard, MStateMachine sm) :
	transformBasics(guard) ->
	sm.guard.add(this) ->
	setName(xtractValue(guard.specification)) ->
	this; 
	
/**
 * extract some meaningful specification string from a uml guard.specification
 * @param ox uml::OpaqueExpression (a ValueSpecification subtype)
 * @return specification string
 */
 private String xtractValue(OpaqueExpression ox) :
 	ox.body.toString()
 	;

/**
 * extract some meaningful specification string from a uml guard.specification
 * @param vs uml::ValueSpecification subtype
 * @return specification string
 */
 private String xtractValue(ValueSpecification vs) :
 	"cannot process ValueSpec of type " + vs.metaType.toString()
 	;

/**
 * create event
 * @param s a uml::SignalEvent
 * @param sm gcore::MStateMachine	the owning state machine
 * @context the owning state machine
 * @return new MEvent
 */
private create MEvent makeEvent(SignalEvent s, MStateMachine sm) :
	transformBasics(s.signal) ->
	sm.event.add(this) ->
	setIsCall(false) ->
	setIsChange(false) ->
	parameter.addAll(s.signal.ownedAttribute.makeEventParameter()) ->
	this;
	
/**
 * create event
 * @param s a uml::CallEvent
 * @param sm gcore::MStateMachine	the owning state machine
 * @context the owning state machine
 * @return new MEvent
 */
private create MEvent makeEvent(CallEvent s, MStateMachine sm) :
	transformBasics(s) ->
	sm.event.add(this) ->
	setIsCall(true) ->
	setIsChange(false) ->
	parameter.addAll(s.operation.ownedParameter.makeEventParameter()) ->
	this;
	
/**
 * create event
 * @param s a uml::TimeEvent
 * @param sm gcore::MStateMachine	the owning state machine
 * @context the owning state machine
 * @return new MEvent
 */
private create MTimeEvent makeEvent(TimeEvent s, MStateMachine sm) :
	transformBasics(s) ->
	sm.event.add(this) ->
	setIsCall(false) ->
	setIsChange(false) ->
	setIsRelative(s.isRelative) ->
	setWhen(s.when.stringValue()) ->
	this;
	
/**
 * create event
 * @param s a uml::ChangeEvent
 * @param sm gcore::MStateMachine	the owning state machine
 * @context the owning state machine
 * @return new MEvent
 */
private create MEvent makeEvent(ChangeEvent s, MStateMachine sm) :
	transformBasics(s) ->
	sm.event.add(this) ->
	setIsCall(false) ->
	setIsChange(true) ->
	setName(s.changeExpression.stringValue()) ->
	this;
	
/**
 * create event
 * @param s a uml::SignalEvent
 * @param sm gcore::MStateMachine	the owning state machine
 * @context the owning state machine
 * @return new MEvent
 */
private create MEvent makeEvent(Event s, MStateMachine sm) :
	error("not supported kind of event: " + s.metaType + " for event " + s.name) ->
	this;

/**
 * create Event Parameter
 * @param p uml::Parameter
 * @context nne
 * @return new MEventParameter
 */
private create MEventParameter makeEventParameter(Parameter p) :
	transformBasics(p) ->
	setType(p.type.makeType()) ->
	this;

/**
 * create Event Parameter
 * @param p uml::Property
 * @context nne
 * @return new MEventParameter
 */
private create MEventParameter makeEventParameter(Property p) :
	transformBasics(p) ->
	setType(p.type.makeType()) ->
	this;

/*
 ********** Transition atomisation section **********
 */
 
/**
 * decompose  a (top level) state machine into atomic transitions by
 * decomposing all of its transitions
 * @param msm top level state machine
 */
private atomize(MStateMachine this) :
	atomicTransition.addAll(smtransition.decompose()) ->
	this;
	
/**
 * decompose a transition into atomic transitions by processing all of its leaf 
 * source and target states
 */
private decompose(MTransition this) :
//	trace("	decomposing >" + name + "<") ->
//	trace("		sources: " + source.name + " -> " + (source.sourceStates()).name) ->
//	trace("		target: " + target.name + " -> " + target.targetState().name) ->
	switch {
		case kind == "int" :
			source.sourceStates().makeInternalAtomicTransition(this)
		default:
			source.sourceStates().makeAtomicTransition(target.targetState(), this)
	};

/**
 * create an internal atomic transition in a MLeafState instance
 */
private create MAtomicTransition makeInternalAtomicTransition(MLeafState src, MTransition def) :
	setXmiGuid("ATI"+src.xmiGuid+def.xmiGuid) ->
	setName("ATI_" + src.name) ->
	setDefiningTransition(def) ->
	setSource(src) ->
	setTarget(src)
	;

/**
 * create an atomic transition between two MLeafState instances
 */
private create MAtomicTransition makeAtomicTransition(MLeafState src, MLeafState trg, MTransition def) :
	setXmiGuid("AT"+src.xmiGuid+def.xmiGuid+trg.xmiGuid) ->
	setName("AT_" + src.name + "_" + trg.name) ->
	setDefiningTransition(def) ->
	switch {
		case def.kind == "int" : error("only external transitions should be processed here")
		case src == trg :
		(
			(src.exit != null ? exit.add(src.exit) : null) ->
			(src.do != null ? endDo.add(src.do) : null) ->
			(trg.entry != null ? entry.add(trg.entry) : null) ->
			(trg.do != null ? startDo.add(trg.do) : null) ->
			setSource(src) ->
			setTarget(trg)
		)
		default:	
		(let from = src.outlist(trg) :
			(let to = src.intolist(trg) :
				setSource((MFinalState)from.first()) ->
				setTarget((MFinalState)to.last()) ->
				from.collect(state|(state.exit != null ? exit.add(state.exit) : null) -> 
								   (state.do != null ? endDo.add(state.do) : null)) ->
				to.collect(state|(state.entry != null ? entry.add(state.entry) : null) -> 
										   (state.do != null ? startDo.add(state.do) : null))
			)
		)
	} ->
	this;

private List[MState] outlist(MLeafState fstate, MLeafState tstate) :
	let from = fstate.hierarchylist() :
	tstate.hierarchylist().collect(st|from.remove(st)) ->
	from
	;

private List[MState] intolist(MLeafState fstate, MLeafState tstate) :
	let into = tstate.hierarchylist() :
	fstate.hierarchylist().collect(st|into.remove(st)) ->
	into.reverse()
	;

/**
 * recursively build a list of all leaf substates of a state
 */
private cached List[MLeafState] sourceStates(MCompositeState this) :
//	trace("	superstate: " + (superstate != null ? superstate.name : "TOP")) ->
//	trace("	substates: " + substate.name) ->
	substate.sourceStates()
		.reject(state|state.metaType == MInitialState || 
		              state.metaType == MHistoryState || 
		              state.metaType == MFinalState)
		.flatten()
	;

/**
 * list of all leaf substates of a state is itself
 */
private cached List[MLeafState] sourceStates(MLeafState this) :
//	trace("	superstate: " + (superstate != null ? superstate.name : "TOP")) ->
	{this};

/**
 * should never been called
 */
private cached List[MLeafState] sourceStates(MState this) :
	error("sourceStates should never been called on abstract class MState") ->
	{};

/**
 * recursively build a list of all superstates of a state
 */
private List[MState] hierarchylist(MState state) :
	state.superstate == null ? {state} : {state}.addAll(state.superstate.hierarchylist())
	;

/**
 * recursively find target substate of a state
 */
private cached MLeafState targetState(MCompositeState this) :
	substate.typeSelect(MInitialState).isEmpty ? 
		(substate.typeSelect(MHistoryState).isEmpty ?
			error("Transition to Compound state without Initial or History State") :
			substate.typeSelect(MHistoryState).targetState().first()
		) :
		substate.typeSelect(MInitialState).targetState().first()
	;

/**
 * target state of an Initial State is found on its outgoing transition
 */
private cached MLeafState targetState(MInitialState this) :
	outgoing.isEmpty ? (error("Initial State has no outgoing transition: " + name) -> null) :
	outgoing.first().target.targetState()
	;

/**
 * target state of a History State is found on its outgoing default transition<br>
 * but has to be evaluated by generated code
 */
private cached MLeafState targetState(MHistoryState this) :
	outgoing.isEmpty ? error("Initializing History State has no outgoing transition: " + name) : null ->
	this
	;

/**
 * target state of a LeafState is itself
 */
private MLeafState targetState(MLeafState this) :
	this;

/**
 * should never been called
 */
private cached MLeafState targetState(MState this) :
	error("targetlist should never been called on abstract class MState") ->
	{};

/*
 ********** Tracing section **********
 */
 
/**
 * for debugging: trace this state machine element
 */
private display(MStateMachine msm) :
	trace("StateMachine of " + msm.owningContext.name + " (" + msm.owningContext.metaType.toString() + ")") ->
//	msm.smstate.sortBy(e|e.name).displayState() ->
//	msm.smtransition.select(tr|tr.kind == 'ext').displayTransition("	") ->
	trace("	Atomic Transitions") ->
	msm.atomicTransition.
	sortBy(t|t.source.name).
	sortBy(t|t.definingTransition.kind).
	display("		")
	;

/**
 * for debugging: trace this state machine element
 */
private displayState(MState mst) :
	trace("	" + mst.name + " [" + 
		(switch (mst.metaType) {
			case gcore::MLeafState: 'L'
			case MCompositeState: 'C'
			case MInitialState: 'I'
			case MFinalState: 'F'
			case MHistoryState: 'H' + (((MHistoryState) mst).deep ? '*':'')
			default: mst.metaType.toString()
		}) + "]"
	) ->
	mst.entry != null ? trace("		entry/" + mst.entry.name) : null -> 
	mst.exit != null ? trace("		exit/" + mst.exit.name) : null -> 
	mst.do != null ? trace("		do/" + mst.do.name) : null -> 
	mst.outgoing.select(tr|tr.kind != 'ext').displayTransition("		")
	;

/**
 * for debugging: trace this state machine element
 */
private displayTransition(MTransition mtr, String ind) :
	trace(ind + "[" + mtr.source.name + "]-- " +
		(mtr.trigger.first() != null ? mtr.trigger.first().displayEvent() : '***') +
		(mtr.guard != null ? mtr.guard.name : '') + (mtr.action != null ? "/" + mtr.action.name : '') +
		" -->[" + mtr.target.name + "]")
	;	

/**
 * for debugging: trace this state machine element
 */
private displayEvent(MEvent mev) :
	mev.name + "(" + 
	(mev.parameter.size > 0 ? mev.parameter.collect(e|' ' + e.name + ":" + e.type.name()) + ' ' : '')
		.toString().replaceAll('[\\[\\]]', '') + ")";
 
/**
 * for debugging: trace this state machine element
 */
private displayEvent(MTimeEvent mev) :
	(mev.isRelative? "after" : "at") + "(" + mev.when + "): " + mev.name;

/**
 * for debugging: trace this state machine element
 */
private display(MAtomicTransition mtr, String ind) :
	trace(ind + (mtr.definingTransition.kind == "int" ? "I " : "E ") + "(" + mtr.source.name + ")--- " +
		(mtr.definingTransition.trigger.first() != null ? mtr.definingTransition.trigger.first().displayEvent() : '_anonymous_') +
		(mtr.definingTransition.guard != null ? mtr.definingTransition.guard.name : '') +
		" exit: " + mtr.exit.name + " endDo: " + mtr.endDo.name + " " +
		(mtr.definingTransition.action != null ? "/" + mtr.definingTransition.action.name : '') +
		" entry: " + mtr.entry.name + " startDo: " + mtr.startDo.name + " " +
		" -->(" + mtr.target.name + ")")
	;	

/**
 * create 
 * @param  
 * @param  gcore::MStateMachine	the owning state machine
 * @context
 * @return 
 */
	/**
 * create 
 * @param  
 * @param  gcore::MStateMachine	the owning state machine
 * @context
 * @return 
 */
	