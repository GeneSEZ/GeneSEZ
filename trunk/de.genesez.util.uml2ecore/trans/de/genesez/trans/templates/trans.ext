// this is the transformation that transforms UML2 
// class models into eCore models. Not very long, but
// you need to be somewhat familiar with the UML2 
// metamodel to understand this code. You should also
// read the reference docs for the Xtend language first.
// You should also take a look at the xTend sample first,
// since it explains how xTend can be used.

// this imports the ecore metamodel; since we want to 
// transform into an instance of ecore, we need to load 
// this metamodel
import ecore;
// import the UML2 metamodel - this is what we transform from
import uml;

import codegenMm;
    
// and we also load the io extensions, for the purpose of
// debugging, in case we need it   
extension org::openarchitectureware::uml2ecore::io;   
    
// on top level, we transform a UML model into an EPackage. A 
// create extension is used for this. Create extensions have
// the sideeffect of creating an instance of the type given
// after the create keyword. Note that the newly created 
// EPackage can be accessed by "this" inside the function
create MModel this transform(Model m): 
	// set the unique xmiId
	setXmiId(getXmiIdAtt(m))->
 	// the name of the new package should be the same as the UML model
	setName(m.name)->info()->
	// setXmiId(xmiId(m))->
	// start descending package tree
	setOwnedPackage(m.ownedElement.typeSelect(Package).reject(e|((Package) e).name == ignoredPackage())
	.processPackage().setModel(this))->this;

private String xmiId (Element obj) : 
	JAVA de.genesez.util.TransUtils.getXmiId(org.eclipse.emf.ecore.EObject);
	
private getXmiIdAtt (Element e) :
	xmiId(e);

// create new MPackage from uml2 package
create MPackage makePackage( Package p) :
	// set the unique xmiId
	setXmiId(getXmiIdAtt(p))->
	setName(p.name)->info();

// only packages are contained in the model element
// they can contain more packages or classes
private MPackage processPackage( Package p) :
	let mp = makePackage(p) :
	// recursively descend package tree
	mp.setNestedPackage(p.ownedElement.typeSelect(Package).processPackage())->
	// add classes in package
	mp.setClass(p.ownedElement.typeSelect(Class).processClass().setOwningPackage(mp)) ->
	// map associations in package to unidirectional or bidirectional references
//	p.ownedMember.typeSelect( Association ).mapAssociation(mp)
	mp;
	
// create new MClass from uml2 class
create MClass makeClass( Class c ) :
	// set the unique xmiId
	setXmiId(getXmiIdAtt(c))->
	setName(c.name)->info();

// classes are contained in packages. 
// they own attributes and Association ends
private MClass processClass( Class c) :
	let mc = makeClass(c) :
	// add attributes
	mc.setAttribute(c.ownedAttribute.reject(p|p.association != null).processAttribute().setClass(mc))->
	mc;

// create new MAttribute from uml2 Property
create MAttribute makeAttribute( Property p ) :
	// set the unique xmiId
	setXmiId(getXmiIdAtt(p))->
	setName(p.name)->
	setVisibility(p.visibility.toString())->info()->
	setType(p.type.toString())->
	this;

// attributes at the moment are leafs in the model tree, so do nearly nothing here.
private MAttribute processAttribute( Property p) :
	let ma = makeAttribute(p) :
	ma;

// associations are contained in packages and contain their ends
create MAssociation mapAssociation(Association a, MPackage owningPackage): 
	// set the unique xmiId
	setXmiId(getXmiIdAtt(a))->
	setName(assocName(a))->info()->
	setOwningPackage(owningPackage)->
	setEnd(a.memberEnd.mapAssociationEnd(this, a))->
	this;
	
private String assocName(Association a):
	(a.name == null || a.name == "") ?
		"" :
		a.name ;

// MAssociationEnd is represented by a property in the uml2 meta model
create MAssociationEnd mapAssociationEnd(Property aend, MAssociation owningAssociation, Association umlassoc):
	// set the unique xmiId
	setXmiId(getXmiIdAtt(aend))->
	setName(aend.assocEndName())->info()->
	// Note: we can call mapClass() as often as we want, since create
	// extensions are cached and, when invoked several times with the 
	// same arguments are executed only upon first invocation. Subsequent
	// invocations return the cached result of the first invocation
	this;
	
private String assocEndName(Property a):
//	"toClass: ".info()->a.class.info()->
//	a.associationEnd.info()->
	(a.name == null || a.name == "") ?
		(a.class == null ? "???" : a.class.name.toFirstLower()) :
		a.name ;
	
// externally configure packages to ignore, e.g. UML standard profile :-)
private String ignoredPackage(): GLOBALVAR excludePackage; 	
		
	
	
  