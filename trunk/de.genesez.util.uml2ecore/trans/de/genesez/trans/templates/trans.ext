// this is the transformation that transforms UML2 
// class models into eCore models. Not very long, but
// you need to be somewhat familiar with the UML2 
// metamodel to understand this code. You should also
// read the reference docs for the Xtend language first.
// You should also take a look at the xTend sample first,
// since it explains how xTend can be used.

// this imports the ecore metamodel; since we want to 
// transform into an instance of ecore, we need to load 
// this metamodel
import ecore;
// import the UML2 metamodel - this is what we transform from
import uml;

import codegenMm;
    
// and we also load the io extensions, for the purpose of
// debugging, in case we need it   
extension org::openarchitectureware::uml2ecore::io;   
    
// on top level, we transform a UML model into an EPackage. A 
// create extension is used for this. Create extensions have
// the sideeffect of creating an instance of the type given
// after the create keyword. Note that the newly created 
// EPackage can be accessed by "this" inside the function
create MModel this transform(Model m): 
 	// the name of the new package should be the same as the UML model
	setName(m.name)->info()->
	// set the unique xmiId
	// setXmiId(xmiId(m))->
	// start descending package tree
	setOwnedPackage(m.ownedElement.typeSelect(Package).reject(e|((Package) e).name == ignoredPackage())
	.mapPackage(this))->this;

private String xmiId (Element obj) : 
	JAVA de.genesez.util.TransUtils.getXmiId(org.eclipse.emf.ecore.EObject);

// only packages are contained in the model element
// they can contain more packages or classes
create MPackage mapPackage( Package p, MModel model ) :
	setName(p.name)->info()->setModel(model)->
	// recursively descend package tree
	setNestedPackage(p.ownedElement.typeSelect(Package).mapPackage(this))->
	// add classes in package
	setClass(p.ownedElement.typeSelect(Class).mapClass(this))->
	// map associations in package to unidirectional or bidirectional references
	p.ownedMember.typeSelect( Association ).mapAssociation(this)->
	this;

// here are packages nested in packages
create MPackage mapPackage( Package p, MPackage nesting ) :
	setName(p.name)->info()->setNestingPackage(nesting)->
	// recursively descend package tree
	setNestedPackage(p.ownedElement.typeSelect(Package).mapPackage(this))->
	// add classes in package
	setClass(p.ownedElement.typeSelect(Class).mapClass(this))->
	// map associations in package to unidirectional or bidirectional references
	p.ownedMember.typeSelect( Association ).mapAssociation(this)->
	this;
	
// classes are contained in packages. 
// they own attributes and Association ends
create MClass mapClass( Class c, MPackage owningPackage) :
	setName(c.name)->
//	c.info()->" is mapped to ".info()->
	info()->
	setOwningPackage(owningPackage)->
	// add attributes
	setAttribute(c.ownedAttribute.reject(p|p.association != null).mapAttribute(this))->
	this;

// attributes at the moment are leafs in the model tree.
create MAttribute mapAttribute( Property p, MClass class) :
	setName(p.name)->
	setVisibility(p.visibility.toString())->info()->
	setType(p.type.toString())->
	setClass(class)->
	this;

// this one returns the value of the global variable nsUriPrefix
// global variables are defined in the workflow file, take a look
// at uml2ecoreWorkflow.oaw	
private String nsUri(): GLOBALVAR nsUriPrefix;	
	
// associations are contained in packages and contain their ends
create MAssociation mapAssociation(Association a, MPackage owningPackage): 
	setName(assocName(a))->info()->
	setOwningPackage(owningPackage)->
	setEnd(a.memberEnd.mapAssociationEnd(this, a))->
	this;
	
private String assocName(Association a):
	(a.name == null || a.name == "") ?
		"" :
		a.name ;

// MAssociationEnd is represented by a property in the uml2 meta model
create MAssociationEnd mapAssociationEnd(Property aend, MAssociation owningAssociation, Association umlassoc):
	setName(aend.assocEndName())->info()->
	// Note: we can call mapClass() as often as we want, since create
	// extensions are cached and, when invoked several times with the 
	// same arguments are executed only upon first invocation. Subsequent
	// invocations return the cached result of the first invocation
	this;
	
private String assocEndName(Property a):
//	"toClass: ".info()->a.class.info()->
//	a.associationEnd.info()->
	(a.name == null || a.name == "") ?
		(a.class == null ? "???" : a.class.name.toFirstLower()) :
		a.name ;
	
	
// for unidirectional associations, we determine which of the two ends is
// navigable (by definition, in a unidir assocation, only one end can be
// navigable!). For tht end, we create an Ecore reference by calling the
// respective helper function createRef().
private mapUniDirAssociation(Association a): 
	a.memberEnd.get(0).isNavigable() ? a.memberEnd.get(0).createRef() : null ->
	a.memberEnd.get(1).isNavigable() ? a.memberEnd.get(1).createRef() : null;

// the mapping of bidirectional associations must be to two EReferences
// that know each other as their opposite. So, we create a reference 
// for each side, and then set one as the opposite of the other. Since
// createRef() returns the created reference, all of this can be written
// very consisely.
// hm. For some very strange reason we now have to set the EOpposite properties
// in both directions... this has worked with setting it in only one way before.
// Strange.
private mapBiDirAssociation(Association a): 
	a.memberEnd.get(0).createRef().setEOpposite( a.memberEnd.get(1).createRef() ) ->
	a.memberEnd.get(1).createRef().setEOpposite( a.memberEnd.get(0).createRef() );

// this helper function creates an EReference for a Property (a Property 
// is basically the "docking point" of an association at the respective
// class
create EReference this createRef( Property a ): 
	// the reference has the same name as the property
	setName( a.name ) -> 
	// the type is the result of mapping the UML class
	// associated with the property to the respective EClass
	setEType( ((Class)a.type).mapClass() ) ->
	// the next couple of lines determine the multiplicity
    a.lowerValue.stringValue() == "1" ? setLowerBound(1) : null -> 
    a.lowerValue.stringValue() == "0" ? setLowerBound(0) : null -> 
    a.upperValue.stringValue() == "1" ? setUpperBound(1) : null -> 
    a.upperValue.stringValue() != "1" ? setUpperBound(-1) : null ->	
	// this one copies the containment
	setContainment( a.isComposite ) ->
	// and finally, we add the refernce to the result of mapping 
	// the UML class associated with the property to the respective EClass
	// Note: we can call mapClass() as often as we want, since create
	// extensions are cached and, when invoked several times with the 
	// same arguments are executed only upon first invocation. Subsequent
	// invocations return the cached result of the first invocation
	a.class.mapClass().eStructuralFeatures.add(this);
	
// that one creates an EClass from an UML Class	
create EClass this mapClass(Class c):
	// copies the name
	setName(c.name) ->
	// copies the isAbstract property 
	setAbstract(c.isAbstract) ->
	// copy the super classes; note how we iterate over all generalization
	// objects of the current class, ask it for it's general end (i.e. the super
	// class) and then map that UML class to an EClass, as usual
	setESuperTypes(c.generalization.general.typeSelect(Class).mapClass()) ->
	// finally, we copy attributes. Attributes are by definition all Properties
	// that have a PrimitiveType as their type. mapAttribute converts a UML 
	// Property into an EAttribute
	setEStructuralFeatures( 
		c.ownedAttribute.select(a|PrimitiveType.isInstance(a.type)).mapAttribute() ) ->
	// add the name attribute, if it needs to be added automatically
	addNameAttr() && this.eSuperTypes.isEmpty && !eAttributes.collect(a|a.name).contains("name") ? 
		eStructuralFeatures.add(createNameAttr()) : null;

// creates the additional name attribute, if necessary	
create EAttribute this createNameAttr(EClass cls):
	setName("name") -> setEType( "String".mapTypeName() );	

// copying attributes is easy, just copy name and type
create EAttribute this mapAttribute( Property a ):
	setName( a.name ) ->
	// note how we call the mapTypeName() operation on the
	// name of the type
	setEType( a.type.name.mapTypeName() );	
	  
// finally, because of a number of EMF intricacies, we delegate the
// actual type mapping to a Java method; take a look at the respective
// method to see how it works	  
ecore::EClassifier mapTypeName(String t):
	JAVA org.openarchitectureware.uml2ecore.TypeMapper.mapType( java.lang.String );
// this one returns the value of the global variable addNameAttribute
// global variables are defined in the workflow file, take a look
// at uml2ecoreWorkflow.oaw	
private boolean addNameAttr(): GLOBALVAR addNameAttribute;
private String ignoredPackage(): GLOBALVAR excludePackage; 	
		
	
	
  