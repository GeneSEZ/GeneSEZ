/**
 * Simplifies access to genesez models + makes working with the genesez metamodel more easier
 * 
 * currently covered:
 * - properties, attributes, association roles
 * - associations
 * - operations
 * - comments
 * - generics
 * - stereotypes + tagged values
 * - aspects
 * - type helpers
 * - classifiers
 * 
 * @author	tobias haubold 
 * @author	andre pflueger
 * @author	Nico Herbig <nico.herbig@fh-zwickau.de> (last)
 * @date	2011-05-17
 */

// based on genesez meta model
import gcore;

extension de::genesez::platforms::common::log::Log;
extension de::genesez::platforms::common::m2m::CreateTemplate;

/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	multiplicity elements (properties, parameters, operations)
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

/**
 * checks if a property has a simple valued type
 * @return	true if the property has a simple valued type, otherwise false
 */
boolean isSingleValuedType(MProperty this) :
	multiplicity == 1;

/**
 * checks if an operation has a simple valued type
 * @return	true if the operation has a simple valued type, otherwise false
 */
boolean isSingleValuedType(MOperation this) :
	multiplicity == 1;

/**
 * checks if a parameter has a simple valued type
 * @return	true if the parameter has a simple valued type, otherwise false
 */
boolean isSingleValuedType(MParameter this) :
	multiplicity == 1;

/**
 * checks if a property is a multi-valued type
 * @return	true if the property has a multi-valued type, otherwise false
 */
boolean isMultiValuedType(MProperty this) :
	multiplicity != 1;

/**
 * checks if an operation is a multi-valued type
 * @return	true if the operation has a multi-valued type, otherwise false
 */
boolean isMultiValuedType(MOperation this) :
	multiplicity != 1;

/**
 * checks if a parameter is a multi-valued type
 * @return	true if the parameter has a multi-valued type, otherwise false
 */
boolean isMultiValuedType(MParameter this) :
	multiplicity != 1;

/**
 * checks if a property has a fixed count of values
 * @return	true if the property has a fixed count of values, otherwise false
 */
boolean hasFixedMultiplicity(MProperty this) : 
	multiplicity > -1;

/**
 * checks if a parameter has a fixed count of values
 * @return	true if the parameter has a fixed count of values, otherwise false
 */
boolean hasFixedMultiplicity(MParameter this) : 
	multiplicity > -1;

/**
 * checks if an operation has a fixed count of values
 * @return	true if the operation has a fixed count of values, otherwise false
 */
boolean hasFixedMultiplicity(MOperation this) : 
	multiplicity > -1;

/**
 * checks if a qualified association role has a single qualifier
 * @return	true, if a qualified association has a single qualifier, otherwise false
 */
boolean isSingleQualified(MAssociationRole this) :
	qualifierMultiplicity == 1;

/**
 * checks if a qualified association role can have more qualifier values
 * @return	true, if a qualified association role can have more qualifier values, otherwise false
 */
boolean isMultiQualified(MAssociationRole this) :
	qualifierMultiplicity != 1;

/**
 * getter for the return type of an operation
 * @return	the return type of the operation
 */
MType type(MOperation this) : returnType;

/**
 * getter for the type of a parameter
 * @return	the type of the parameter
 */
MType type(MParameter this) : type;

/**
 * getter for the type of a property
 * @return	the type of the property
 */
MType type(MProperty this) : type;

/**
 * just there for error free templates
 * should NOT be called!
 */
MType type(MElement this) : 
	fatal("somethings goes totally wrong within your templates... " +
	"   you cannot determine the type of an 'MElement': " + this) ->
	Void;

/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	attributes
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

/**
 * checks if a classifier has attributes
 * @return	true if the classifier has attributes, otherwise false
 */
boolean hasAttributes(MClassifier this) : 
	property.typeSelect(MAttribute).size > 0;

/**
 * checks if a classifier has derived attributes
 * @return	true if the classifier has derived attributes, otherwise false
 */
boolean hasDerivedAttributes(MClassifier this) : 
	property.typeSelect(MAttribute).exists( a|a.derived );

/**
 * checks if an attribute has a default value
 * @return	true if the attribute has a default value, otherwise false
 */
boolean hasDefaultValue(MAttribute this) :
	defaultvalue.length > 0;

/**
 * getter for a list of all attributes including inherited
 * @return	a list with attributes or an empty list
 * @deprecated	replaced by {@link allInitializableAttributes(MClassifier)}
 */
List[MAttribute] getAllAttributes(MClassifier this) :
	{}.add( getOwnAttributes() )
		.add( getParentAttributes() ).flatten();

/**
 * it's just there for error free templates
 * @return	an empty list
 * @see		getParentAttributes(MClassifier)
 * @deprecated	replaced by {@link allInitializableAttributes(MType)}
 */
List[MAttribute] getAllAttributes(MType this) : {};

/**
 * getter for a list with all owned attributes excluding final and derived
 * @return	a list with attributes or an empty list
 * @deprecated	replaced by {@link owningInitializableAttributes(MClassifier)}
 */
List[MAttribute] getOwnAttributes(MClassifier this) :
	property.typeSelect(MAttribute).select( a| !a.final && !a.derived );

/**
 * getter for a list of all inherited attributes of the first supertype
 * @return	a list with attributes or an empty list
 * @deprecated	replaced by {@link allInitializableAttributes(MClassifier)}
 */
List[MAttribute] getParentAttributes(MClassifier this) :
	supertype.isEmpty
		? {}
		: supertype.first().getAllAttributes();

/**
 * checks if a classifier has initializable attributes or not
 * @return	true, if a classifier has initializable attributes, otherwise false
 */
boolean hasInitializableAttributes(MClassifier this) : !allInitializableAttributes().isEmpty;

/**
 * getter for a list of all owning initializable attributes
 * @return	a list of initializable attributes or an empty list
 */
List[MAttribute] owningInitializableAttributes(MClassifier this) :
	property.typeSelect(MAttribute).select( e| 
		!e.static && !e.derived && !( e.final && e.hasDefaultValue() )
	);

/**
 * getter for a list of all initializable attributes
 * @return 	a list of initializable attributes or an empty list
 */
List[MAttribute] allInitializableAttributes(MClassifier this):
	owningInitializableAttributes().addAll(
		generalization.isEmpty
			? {}
			: generalization.allInitializableAttributes()
	);

/**
 * just there for error free templates
 * @see		allInitializableAttributes(MClassifier)
 * @return	an empty list
 */
List[MAttribute] allInitializableAttributes(MType this) : {};


/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	association + association roles
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

/**
 * checks if a classifier has association roles
 * @return	true if the classifier has association roles, otherwise false
 */
boolean hasAssociationRoles(MClassifier this) : 
	property.typeSelect(MAssociationRole).size > 0;

/**
 * checks if an association role has an opposite or not
 * @return	true, if the association role has an opposite
 */
boolean hasOpposite(MAssociationRole this) : opposite != null;

/**
 * checks if an association role has a qualifier
 * @return	true, if the association role has a qualifier
 */
boolean hasQualifier(MAssociationRole this) : qualifier != null;

/**
 * checks if an association role is qualified
 * @return	true, if the association role has a qualifier
 * @see		hasQualifier(MAssociationRole)
 */
boolean isQualified(MAssociationRole this) : hasQualifier();

/**
 * checks if the opposite of an association role is qualified
 * @return	true, if the opposite has a qualifier, otherwise false
 */
boolean hasQualifiedOpposite(MAssociationRole this) :
	hasOpposite() ? opposite.isQualified() : false;

/**
 * checks if the opposite of an association role is qualified
 * @return	true, if the opposite has a qualifier, otherwise false
 */
boolean isOppositeQualified(MAssociationRole this) :
	hasOpposite() && opposite.isQualified();

/**
 * checks if an association role belongs to an association class or not
 * @return	true, if it's a plain association role and doesn't belongs to an association class and 
 * 			false, if the association role belongs to an association class
 */
boolean hasAssociationClass(MAssociationRole this) :
	association.associationClass != null;

/**
 * check if a class is an association class or not
 * @return	true, if the class is an association class, otherwise false
 */
boolean isAssociationClass(MClass this) : ownedAssociation != null;

/**
 * check if a classifier is an association class or not
 * @see		isAssociationClass(MClass)
 * @return	false
 */
boolean isAssociationClass(MClassifier this) : false;

/**
 * checks if an association role belongs to an association class or not
 * @param	aend	an association role
 * @return	true, if it's a plain association role and doesn't belongs to an association class and 
 * 			false, if the association role belongs to an association class
 * @deprecated, use {@link hasAssociationClass(MAssociationRole)}
 */
boolean isPlainAssociation(MAssociationRole aend) :
	aend.association.associationClass == null;

/**
 * getter for the association class of an association role
 * @param	aend	an association role
 * @return	the association class of an association role (or null)
 * @see		isPlainAssociation
 */
MClass assocClass(MAssociationRole aend) :
	aend.association.associationClass;

/**
 * returns all owning association roles
 */
List[MAssociationRole] owningAssociationRoles(MClassifier this) :
	property.typeSelect(MAssociationRole).reject( e|e.derived );

/**
 * returns all initializable association roles
 */
List[MAssociationRole] allInitializableAssociationRoles(MClassifier this) :
	let assocs = {} :
		assocs.addAll( owningAssociationRoles() ) ->
		assocs.addAll( realization.typeSelect(MClassifier).owningAssociationRoles() ) ->
	assocs.flatten();

/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	operations
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

/**
 * checks if a classifier has operations
 * @return	true if the classifier has operations, otherwise false
 */
boolean hasOperations(MClassifier this) : operation.size > 0;

/**
 * checks if a classifier has operation declarations, that is, if it has abstract operations
 * @return	true if the classifier has abstract operations, otherwise false
 */
boolean hasOperationDeclarations(MClassifier this) : 
	operation.reject( o|o.isConstructor() || o.isDestructor() || !o.abstract ).size > 0;

/**
 * checks if a classifier has one or more constructors
 * @return	true if the classifier has constructors, otherwise false
 * @see		isConstructor(MOperation)
 */
boolean hasConstructors(MClassifier this) : operation.exists( o|o.isConstructor() );

/**
 * checks if an operation is a constructor of a classifier
 * @return	true if the operation is a constructor, otherwise false
 */
boolean isConstructor(MOperation this) :
	hasStereotype("Create") || hasStereotype("create") || classifier.name == name;

/**
 * checks if a classifier has one or more destructors
 * @return	true if the classifier has destructors, otherwise false
 * @see		isDestructor(MOperation)
 */
boolean hasDestructors(MClassifier this) : operation.exists( o|o.isDestructor() );

/**
 * checks if an operation is a destructor of a classifier
 * @return	true if the operation is a destructor, otherwise false
 */
boolean isDestructor(MOperation this) :
	hasStereotype("Destroy") || hasStereotype("destroy") || name.startsWith("~");

/**
 * checks if an operation has a return type
 * @return	true if the operation has a return type, otherwise false
 */
boolean hasReturnType(MOperation this) :
	returnType != null && returnType.name().toLowerCase() != "void";

/**
 * checks if a parameter has a default value
 * @return	true if the parameter has a default value, otherwise false
 */
boolean hasDefaultValue(MParameter this) :
	defaultvalue.length > 0;

/**
 * checks if an operation can throw exceptions
 * @return	true if the operation can throw exceptions, otherwise false
 */
boolean hasExceptions(MOperation this) : !raisedException.isEmpty;

/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	comments
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

/**
 * checks if an element has one or more comments
 * @return	true if the element has at least one comment, otherwise false
 */
boolean hasComment(MElement this) :
	ownedComment.size > 0;

/**
 * getter for the comment text of a list of comments
 * @param	l	list of comments of an element
 * @return	the comment text as a string or an empty string
 * @todo	revise, see file comment for further details
 * @deprecated	use 'comment' functions in 'Conversion'-script instead
 */
String getCommentText(List[MComment] this) :
	size > 0
		? getComment( first() ).replaceAll("\n", "; ")
		: "";

/**
 * getter for the owned comments of a type
 * @return	the list of owned comments
 * @deprecated	use 'comment' functions in 'Conversion'-script instead
 */
List[MComment] ownedComment(MType this) :
	switch (metaType) {
		case MGeneric : {}
		case MExternal : {}
		case MPrimitiveType : {}
		default : ((MClassifier)this).ownedComment
	};
	

/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	generics
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

/**
 * checks if a classifier has one or more generic parameters
 * @return	true if the classifier has at least one generic parameter, otherwise false
 */
boolean hasGenericParameter(MClassifier this) :
	genericParameter.size > 0;
	
/**
 * checks if an external type has one or more generic parameters
 * @return	true if the external type has at least one generic parameter, otherwise false
 */
boolean hasGenericParameter(MExternal this) :
	genericParameter.size > 0;

/**
 * checks if an operation has one or more generic parameter
 * @return	true if the operation has at least one generic parameter, otherwise false
 */
boolean hasGenericParameter(MOperation this) :
	genericParameter.size > 0;

/**
 * checks if a property has one or more generic realizations
 * @return	true if the property has at least one generic realization, otherwise false
 */
boolean hasGenericRealization(MProperty this) :
	genericRealization.size > 0;

/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	stereotypes + tagged values
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

/**
 * checks if an element is annotated with a stereotype
 * @param	stereotype	the name of a stereotype
 * @return	true if the element has the stereotype, otherwise false
 */
boolean hasStereotype(MElement this, String stereotype) :
	this.stereotype.name.contains(stereotype);

/**
 * checks if an element has a tagged value by ignoring the stereotype
 * @param	tag		the name of a tagged value
 * @param	value	the value of a tagged value
 * @return	true if the element has a tag with the given value, otherwise false
 */
boolean hasTaggedValue(MElement this, String tag, String value) :
	taggedValue.exists( e| e.tag.name == tag && e.value == value );

/**
 * checks if an element has a tagged value of a specific stereotype
 * @param	sterotype	the name of a stereotype
 * @param	tag			the name of a tagged value
 * @param	value		the value of a tagged value
 * @return	true if the element has a tag with the given value, otherwise false
 */
boolean hasTaggedValue(MElement this, String stereotype, String tag, String value) :
	!taggedValue.typeSelect(MTaggedValue)
		.select( e| e.value == value && e.tag.name == tag && e.tag.stereotype.name == stereotype)
		.isEmpty;

/**
 * 	returns a tagged value of a stereotype if exists
 *
 * 	@param	stereotype	the name of a stereotype
 *	@param	tag			the name of a tagged value
 *	
 * 	@return		value of the tagged value
 */
String getTaggedValue(MElement this, String stereotype, String tag) :
	this.taggedValue.exists(e|e.tag.name == tag && e.tag.stereotype.name == stereotype)
		? this.taggedValue.selectFirst(e|e.tag.name == tag && e.tag.stereotype.name == stereotype).value
		: "";

/**
 * returns the boolean value of a tagged value of a stereotype
 * 
 * @param	stereotype	the name of a stereotype
 * @param	tag			the name of the tag
 * 
 * @return	true, if the tagged value is true, otherwise false
 */
boolean getTaggedBooleanValue(MElement this, String stereotype, String tag) :
	hasTaggedValue( stereotype, tag, "true")
		? true
		: false;

/**
 *	function to set any existing tagged value
 *
 *	@param		this	MProperty
 *	@param		name	name of the tagged value
 *	@param		value	new value
 *
 */
Void setTaggedValue(MElement this, String name, String value) :
	this.taggedValue.selectFirst(e|e.tag.name == name).setValue(value);
	
/**
 *	function to set a tagged value of a specific stereotype
 *	note: if a MTagggedValue already exists, it is used and it's value is changed
 *
 *	@param		this		MPropertye
 *	@param		stereotype	name of the stereotype
 *	@param		taggedValue	name of the tagged value
 *	@param		value		new value
 *
 */
Void setTaggedValue(MElement this, String stereotype, String taggedValue, String value) :
	this.taggedValue.exists(e|e.tag.name == taggedValue && e.tag.stereotype.name == stereotype)
		? this.taggedValue.selectFirst(e|e.tag.name == taggedValue && e.tag.stereotype.name == stereotype).setValue(value)
		: createTaggedValue(
			this.stereotype.selectFirst(e|e.name == stereotype).property.selectFirst(e|e.name == taggedValue),
			value
		);
	
/**
 * 	checks if a tagged value of a stereotype exists and has a utilizable value (not empty or null)
 *
 * 	@param	sterotype		the name of a stereotype
 * 	@param	tagggedValue	the name of a tagged value
 * 	@param	value		the value of a tagged value
 * 	
 *	@return		true if the value exists and is utilizable
 */
boolean hasUtilizableValue(MElement this, String stereotype, String taggedValue) :
	this.taggedValue.exists(e|e.tag.name == taggedValue && e.tag.stereotype.name == stereotype) &&
	this.taggedValue.selectFirst(e|e.tag.name == taggedValue && e.tag.stereotype.name == stereotype).value != "" &&
	this.taggedValue.selectFirst(e|e.tag.name == taggedValue && e.tag.stereotype.name == stereotype).value != "null" &&
	this.taggedValue.selectFirst(e|e.tag.name == taggedValue && e.tag.stereotype.name == stereotype).value != "[]"
		? true
		: false;

/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	aspects
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

/**
 * checks if an element has an aspect with the specified name and domain name
 * @param	domain	the name of a domain
 * @param	name	the name of an aspect
 * @return	true if an element has an aspect with a specified name and domain name, otherwise false
 */
boolean hasAspect(MElement this, String domain, String name) :
	!aspect.select( a| a.domain == domain && a.name == name ).isEmpty;

/**
 * checks if an element has an aspect with a specified domain name or not
 * @param	domain	the name of a domain
 * @return	true if an element has an aspect with a specified domain name, otherwise false
 */
boolean hasAspect(MElement this, String domain) :
	!aspect.select( a| a.domain == domain ).isEmpty;

/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	type helpers
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

/**
 * checks if the type is a primitive type
 * @return	true if the type is a primitive type, otherwise false
 */
boolean isPrimitiveType(MType this) : metaType == MPrimitiveType;

/**
 * checks if the type is a generic
 * @return	true if the type is a generic, otherwise false
 */
boolean isGenericType(MType this) : metaType == MGeneric;

/**
 * checks if the type is an external type
 * @return	true if the type is an external type, otherwise false
 */
boolean isExternalType(MType this) : metaType == MExternal;

/**
 * checks if the type is a data type
 * @return	true if the type is a data type, otherwise false
 */
boolean isDataType(MType this) : metaType == MDataType;

/**
 * checks if the type is an enumeration
 * @return	true if the type is an enumeration, otherwise false
 */
boolean isEnumeration(MType this) : metaType == MEnumeration;

/**
 * checks if the type is a classifier
 * @return	true if the type is a classifier, otherwise false
 */
boolean isClassifier(MType this) : MClassifier.isInstance(this);

/**
 * getter for the name of a type or the specification of a generic
 * @return	the name (or specification) of the type
 */
String name(MType this) :
	switch (metaType) {
		case MGeneric : ((MGeneric)this).specification
		case MExternal : ((MExternal)this).specification
		case MPrimitiveType : ((MPrimitiveType)this).name
		default : ((MClassifier)this).name
	};

/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	package accessors
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

/**
 * getter for the package element by using a property
 * @return	the package element
 */
MPackage package(MProperty this) : classifier.package();

/**
 * getter for the package element by using an operation
 * @return	the package element
 */
MPackage package(MOperation this) : classifier.package();

/**
 * getter for the package element by using a classifier
 * @return	the package element
 */
MPackage package(MClassifier this) :
	switch (owningContext.metaType) {
		case MModel : ((MPackage)owningContext)
		case MPackage : ((MPackage)owningContext)
		default : (fatal("MDefinitionContext is neither MPackage nor MModel. This should never happen.") -> Void)
	};
	
/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	model accessors
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

/**
 * getter for the model element by using a property
 * @return	the model element
 */
MModel model(MProperty this) : classifier.model();

/**
 * getter for the model element by using an operation
 * @return	the model element
 */
MModel model(MOperation this) :	classifier.model();

/**
 * getter for the model element by using a classifier
 * @return	the model element
 */
MModel model(MClassifier this) :
	switch (owningContext.metaType) {
		case MModel : ((MModel)owningContext)
		case MPackage : ((MPackage)owningContext).model()
		default : (fatal("MDefinitionContext is neither MPackage nor MModel. This should never happen.") -> Void)
	};

MModel model(MElement this) :
	switch (this.metaType) {
		case MClassifier : ((MClassifier) this).model()
		case MOperation :  ((MOperation) this).model()
		case MParameter :  ((MParameter) this).operation.model()
		case MProperty :  ((MProperty) this).model()
		case MStereotype : ((MStereotype) this).model
		default : (fatal("unable to determine MModel from MElement. Please add your case to this function!") -> Void)
	};

/**
 * getter for the model element by using a package
 * @return	the model element
 */
MModel model(MPackage this) :
	metaType == MModel
		? this
		: nestingPackage.getModel();

/**
 * getter for the model element by using a classifier
 * @return	the model element
 * @deprecated	replaced by {@link model(MClassifier)}
 */
MModel getModel(MClassifier this) :
	this.model();

/**
 * getter for the model element by using a package
 * @return	the model element
 * @deprecated	replaced by {@link model(MClassifier)}
 */
MModel getModel(MPackage this) :
	this.model();

/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	classifiers
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

/**
 * getter for a class by it's full qualified name which is separed by dot's
 * @param	fullQualifiedName	full qualified name of the class
 * @return	the class found or Void
 */
MClass getClass(MModel this, String fullQualifiedName) :
	let c = getClassifier(fullQualifiedName) :
		c.metaType == MClass
			? c
			: Void;

/**
 * getter for a classifier by it's full qualified name which is separed by dot's
 * @param	fullQualifiedName	full qualified name of the classifier
 * @return	the classifier found or null
 */
MClassifier getClassifier(MModel this, String fullQualifiedName) :
	getClassifier(nestedPackage, fullQualifiedName);

/**
 * getter for a package by it's full qualified name, which is separated by dot's
 * @param	fullQualifiedPackageName	full qualified name of a package
 * @return	the package found or null
 */
MPackage getPackage(MModel this, String fullQualifiedPackageName) :
	getPackage(nestedPackage, fullQualifiedPackageName);
	
cached List[MClassifier] allClassifiers(MPackage this) :
	addAllClassifier({});

cached List[MClassifier] addAllClassifier(MPackage this, List[MClassifier] classifiers) :
	classifiers.addAll(classifier) ->
	nestedPackage.addAllClassifier(classifiers) ->
	classifiers;

/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	packages
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/
	
cached List[MPackage] allPackages(MPackage this) :
	addAllPackages({});

cached List[MPackage] addAllPackages(MPackage this, List[MPackage] packages) :
	packages.addAll(nestedPackage) ->
	nestedPackage.addAllPackages(packages) ->
	packages;

/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	elements
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

MClassifier getClassifier(MElement this) :
	switch (metaType) {
		case MOperation : ((MOperation) this).classifier
		case MAttribute : ((MAttribute) this).classifier
		case MAssociationRole : ((MAssociationRole) this).classifier
		default : null
	};

/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	activities
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

MNode getInitialNode(MActivity this) :
	node.reject(e|e.metaType == MAction)
		.select(e|e.from.isEmpty)
		.first();

/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	private functions
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

/**
 * getter for a string representation of a comment
 * @return	the string representation of a comment
 */
private String getComment(MComment this) :
	annotation != "null"
		? annotation
		: "";

/**
 * getter for a class by it's full qualified name from a list of classes
 * note: should actually only work, if the list contains the package, which is the first in the full qualified name
 * @param	packages			a list of packages
 * @param	fullQualifiedName	the full qualified name of a class
 * @return	the class found or null
 */
private MClassifier getClassifier(List[MClass] packages, String fullQualifiedName) :
	JAVA de.genesez.platforms.common.AccessHelper.getClassifier(java.util.List, java.lang.String);

/**
 * getter for a package by it's full qualified name from a list of packages
 * note: should actually only work, if the list contains the package, which is the first in the full qualified name
 * @param	packages					a list of packages
 * @param	fullQualifiedPackageName	full qualifed name of a package
 * @return	the package found or null
 */
private MPackage getPackage(List[MPackage] packages, String fullQualifiedPackageName) :
	JAVA de.genesez.platforms.common.AccessHelper.getPackage(java.util.List, java.lang.String);
