/*
 * (c) GeneSEZ Research Group
 * All rights reserved.
 *
 * Licensed according to GeneSEZ License Terms <http://www.genesez.org/en/license>
 */

import gcore;


/**
 * Helper scripts for conversions to makes codce generation more easier.
 * 
 * @author	Tobias Haubold <tobias.haubold@fh-zwickau.de> (maintainer)
 * @author	Nico Herbig <nico.herbig@fh-zwickau.de> (maintainer)
 */

extension org::genesez::metamodel::core::util::AccessHelper;


// -- Comments ----------------------------------------------------------------------------------------------


/**
 * Builds the comment text of an element by placing an empty line between the comments and nested comments.
 * 
 * @return	The comment string.
 * @see		comment(String, String)
 * @api
 */
String comment(MElement this) :
	comment("\n\n", "\n\n");


/**
 * Builds the comment text of an element by placing the specified seperators between the comments and nested comments. 
 * 
 * @param	commentSeparator		A separator which is placed between comments.
 * @param	nestedCommentSeparator	A separator which is placed between a comment and its nested comment.
 * @return	The comment string.
 * @api
 */
String comment(MElement this, String commentSeparator, String nestedCommentSeparator) :
	JAVA org.genesez.metamodel.core.util.CommentProcessing.comment(org.genesez.metamodel.gcore.MElement, java.lang.String, java.lang.String);


/**
 * Formats a string by adding the asterix (' * ') as prefix and the newline ('\n') as suffix to each line within the string.
 * Hint: To format the comment text of an element please use the formatComment* scripts instead.  
 * 
 * @return	The formatted string.
 * @api
 */
String format(String this) :
	format(" * ", "\n");


/**
 * Formats a string by adding the specified prefix and suffix to each line within the string.
 * Hint: To format the comment text of an element please use the formatComment* scripts instead.
 * 
 * @param	linePrefix	A prefix which is prepended to each line.
 * @param	lineSuffix	A suffix which is appended to each line.
 * @return	The formatted string.
 * @api
 */
String format(String this, String linePrefix, String lineSuffix) :
	JAVA org.genesez.util.comment.CommentProcessing.format(java.lang.String, java.lang.String, java.lang.String);


/**
 * Formats the comment text of an element by placing an empty line between the comments and nested comments
 * and adding the asterix (' * ') as prefix and the newline ('\n') as suffix to each line within the comment text.
 * 
 * @return	The formatted comment string.
 * @see		formatComment(MElement, String, String)
 */
String formatComment(MElement this) : 
	formatComment(" * ", "\n");


/**
 * Formats the comment text of an element by placing an empty line between the comments and nested comments
 * and adding the asterix (' * ') as prefix and the newline ('\n') as suffix to each line within the comment text.
 * 
 * @return	The formatted comment string.
 * @see		formatComment(MElement, String, String)
 * @api
 */
String formatCommentAsterix(MElement this) : 
	formatComment(" * ", "\n");


/**
 * Formats the comment text of an element by placing an empty line between the comments and nested comments
 * and adding two slashes  ('// ') as prefix and the newline ('\n') as suffix to each line within the comment text.
 * 
 * @return	The formatted comment string.
 * @see		formatComment(MElement, String, String)
 * @api
 */
String formatCommentSlashSlash(MElement this) : 
	formatComment("// ", "\n");


/**
 * Formats the comment text of an element by placing an empty line between the comments and nested comments
 * and adding the specified prefix and suffix to each line within the comment text.
 * 
 * @param	linePrefix	A prefix which is prepended to each line.
 * @param	lineSuffix	A suffix which is appended to each line.
 * @return	The formatted comment string.
 * @see		comment(MElement)
 * @see		format(String, String, String)
 * @api
 */
String formatComment(MElement this, String linePrefix, String lineSuffix) :
	comment().format(linePrefix, lineSuffix);


/**
 * Formats the comment text of an element by placing the specified seperators between the comments and nested comments
 * and adding the specified prefix and suffix to each line within the comment text.
 * 
 * @param	commentSeparator		A separator which is placed between comments.
 * @param	nestedCommentSeparator	A separator which is placed between a comment and its nested comment.
 * @param	linePrefix				A prefix which is prepended to each line.
 * @param	lineSuffix				A suffix which is appended to each line.
 * @return	The formatted comment string.
 * @see		comment(MElement, String, String)
 * @see		format(String, String, String)
 * @api
 */
String formatComment(MElement this, String commentSeparator, String nestedCommentSeparator, String linePrefix, String lineSuffix) :
	comment(commentSeparator, nestedCommentSeparator).format(linePrefix, lineSuffix);


// -- Directory name and path conversions ------------------------------------------------------------------- 


/**
 * Getter for the directory path separator character.
 *
 * @return	The directory path separator character ('/').
 * @api
 */
String dirPathSeparator() : 
	"/";


/**
 * Getter for the directory name of a classifier.
 * For instance if the classifier is located inside the package path '/path/to/classifier'
 * then only the last package name 'classifier' is returned as directory name. 
 *
 * @return	The name of the directory.
 * @api
 */
String dirName(MClassifier this) : 
	package().name;


/**
 * Getter for the directory path of a classifier based on its namespace.
 * For instance if the classifier is located inside the package path '/path/to/classifier'
 * then the full package path '/path/to/classifier' is returned as directory path. 
 * 
 * @return	The path of the directory.
 * @api
 */
String dirPath(MClassifier this) : 
	package().fullQualifiedNameSep( dirPathSeparator() );


/**
 * Getter for the directory path of a classifier based on its namespace and specified base path.
 * For instance if the classifier is located inside the package path '/path/to/classifier' and the specified base path is 'my/base'
 * then the base path including the full package path 'my/base/path/to/classifier' is returned as directory path.
 * 
 * @param	basePath	The base path of a classifier.
 * @return	The path of the directory.
 * @see		dirPath(MClassifier)
 * @api
 */
String dirPath(MClassifier this, String basePath) :
	basePath != ""
		? basePath + dirPathSeparator() + dirPath()
		: dirPath();


// -- File name and path conversions ------------------------------------------------------------------------


/**
 * Getter for the file extension separator character.
 *
 * @return	The file extension separator character ('.').
 * @api
 */
String fileExtensionSeparator() : 
	".";


/**
 * Getter for the file name of a classifier.
 * For instance if the classifier is located inside the package path '/path/to/classifier', the name is 'MyClassifier' and the specified file extension is 'java'
 * then the name of the classifier including the file extension 'MyClassifier.java' is returned as file name.
 *
 * @param	fileExtension	The file extension of a classifier.
 * @return	The name of the file.
 * @api
 */
String fileName(MClassifier this, String fileExtension) : 
	name + fileExtensionSeparator() + fileExtension;


/**
 * Getter for the file path of a classifier based on its namespace.
 * For instance if the classifier is located inside the package path '/path/to/classifier' and the file name is 'MyClassifier.java'
 * then the full package path including the file name '/path/to/classifier/MyClassifier.java' is returned as file path.
 *  
 * @param	filename	The file name of a classifier.
 * @return	The path of the file.
 * @see		dirPath(MClassifier)
 * @api
 */
String filePath(MClassifier this, String filename) :
	dirPath() + dirPathSeparator() + filename;


/**
 * Getter for the file path of a classifier based on its namespace and specified base path.
 * For instance if the classifier is located inside the package path '/path/to/classifier', the file name is 'MyClassifier.java' and the specified base path is 'my/base'
 * then the base path including the full package path and the file name 'my/base/path/to/classifier/MyClassifier.java' is returned as file path.
 *
 * @param	filename	The file name of a classifier.
 * @param	basePath	The base path of a classifier.
 * @return	The path of the file.
 * @see		dirPath(MClassifier, String)
 * @api
 */
String filePath(MClassifier this, String filename, String basePath) :
	dirPath(basePath) + dirPathSeparator() + filename;


/**
 * Getter for the file path of a package based on its namespace.
 * For instance if the package is located inside the package path '/path/to/package' and the package name is 'mypackage'
 * then the full package path including the package name '/path/to/package/mypackage' is returned as file path.
 * 
 * @return	The path of the file.
 * @api 
 */
String filePath(MPackage this) :
	fullQualifiedNameSep( dirPathSeparator() );


/**
 * Getter for the file path of a package based on its namespace and specified base path.
 * For instance if the package is located inside the package path '/path/to/package', the package name is 'mypackage' and the specified base path is 'my/base'
 * then the base path including the full package path and name 'my/base/path/to/package/mypackage' is returned as file path.
 * 
 * @return	The path of the file.
 * @api 
 */
String filePath(MPackage this, String base) :
	base == ""
		? filePath()
		: base + dirPathSeparator() + filePath();
































/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

/**
 * getter for a comma separated string of element names
 * @param	l	list of model elements of type MElement
 * @return	comma blank (', ') separated list of element names or an empty string
 */
String getNameList(List[MElement] l) :
	l.size > 1 
		? ((MElement) l.first()).name + ", " + getNameList(l.withoutFirst())
		: (l.size > 0
			? ((MElement) l.first()).name
			: "");

/**
 * getter for a comma separated string of generic specifications
 * @param	l	list of model elements of type MGeneric
 * @return	comma blank (', ') separated list of generic specifications
 */
String getGenericList(List[MGeneric] l) :
	l.size > 1 
		? ((MGeneric) l.first()).specification + ", " + getGenericList(l.withoutFirst())
		: (l.size > 0
			? ((MGeneric) l.first()).specification
			: "");

/**
 * Splits a comma separated list of values into a list of strings and removs all unnessesary whitespace.
 * If the specified string only contains the separator a list with an empty string is returned.
 * 
 * @param	s	comma separated list of values
 * @return	the list of strings
 */
List[String] toList(String s) :
	s.trim().length == 0
		? {}
		: ( s.trim() == ","
			? {""}
			: s.split(",").trim() );


// -- Full Qualified Names ----------------------------------------------------------------------------------


/**
 * Getter for the qualified name separator character.
 *
 * @return	The qualified extension separator character ('::').
 * @api
 */
String qualifiedNameSeparator() : 
	"::";


/**
 * Getter for a human readable identifier of a model.
 * 
 * @api
 */
String fqn(MModel this) :
	name;


/**
 * Getter for a human readable identifier of a package.
 * 
 * @api
 */
String fqn(MPackage this) : 
	nestingPackage.fqn() + qualifiedNameSeparator() + name;


/**
 * Getter for a human readable identifier of a classifier.
 * 
 * @api
 */
String fqn(MClassifier this) :
	package().fqn() + qualifiedNameSeparator() + name;


/**
 * Getter for a human readable identifier of a property.
 * 
 * @api
 */
String fqn(MProperty this) :
	classifier.fqn() + qualifiedNameSeparator() + name;


/**
 * Getter for a human readable identifier of an operation.
 * 
 * @api
 */
String fqn(MOperation this) :
	classifier.fqn() + qualifiedNameSeparator() + name + "(" + parameter.toString(", ") + ")";


/**
 * Getter for a human readable identifier of an element.
 * 
 * @api
 */
String fqn(MElement this) :
	name;


// -- Qualified Names ---------------------------------------------------------------------------------------


/**
 * Returns the qualified name of the specified root model element, i.e. an empty string.
 */
String qn(MModel this) : 
	"";


/**
 * Returns the qualified name of the specified package.
 */
String qn(MPackage this) :
	nestingPackage == null || nestingPackage.metaType == MModel
		? name
		: nestingPackage.qn() + "::" + name;
		
/**
 * Returns the qualified name of the specified classifier.
 */
String qn(MClassifier this) : package().qn() + "::" + name;



/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

/**
 * getter for the full qualified name of a classifier based on it's namespace
 * @param	spearator	the separator to use between the names
 * @return	string representation of the full qualified name
 */
String fullQualifiedNameSep(MClassifier this, String separator) : 
	let fqn = package().fullQualifiedNameSep(separator) :
		fqn.length == 0
			? name.toFirstUpper()
			: fqn + separator + name.toFirstUpper();

/**
 * getter for the full qualified name of a classifier based on it's namespace
 * @param	typename	the typename of the classifier, usually according naming conventions
 * @param	spearator	the separator to use between the names
 * @return	string representation of the full qualified name
 */
String fullQualifiedNameSep(MClassifier this, String typename, String separator) : 
	let fqn = package().fullQualifiedNameSep(separator) :
		fqn.length == 0
			? typename
			: fqn + separator + typename;

/**
 * getter for the full qualified name of a classifier based on a base package and it's namespace
 * @param	typename	the typename of the classifier, usually according naming conventions
 * @param	base		the base package to prepend
 * @param	spearator	the separator to use between the names
 * @return	string representation of the full qualified name
 */
String fullQualifiedNameSep(MClassifier this, String typename, String base, String separator) : 
	let fqn = package().fullQualifiedNameSep(base, separator) :
		fqn.length == 0
			? name.toFirstUpper()
			: fqn + separator + typename;

/**
 * getter for the full qualified name of a package
 * @param	base		a base package to prepend
 * @param	separator	a separator used to build the package path
 * @return	the full qualified name of the package
 */
String fullQualifiedNameSep(MPackage this, String base, String separator) : 
	base == ""
		? fullQualifiedNameSep( separator )
		: base + separator + fullQualifiedNameSep( separator );



/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/




/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	mapping to java functions
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

/**
 * getter for the package path of a classifier
 * @param	pkg			a package
 * @param	separator	a separator used to build the package path
 * @return	string representation of the package path
 */
private String fullQualifiedNameSep(MPackage this, String separator) : 
	JAVA org.genesez.metamodel.core.util.AccessHelper.getFullQualifiedName(org.genesez.metamodel.gcore.MPackage, java.lang.String);
