
import uml;
import gpresentation;

// use qualifed naming functions
extension org::genesez::adapter::uml2::scripts::Helper;

// use logging
extension org::genesez::platform::common::log::Log;
extension org::genesez::platform::common::GlobalStore;

/**
 * Returns the currently populated presentation model
 */
PPackage model() : get("presentationmodel");

create PPackage transform(Model m) :
	useLogger("org.genesez.adapter.uml2") ->
	save("presentationmodel", this) ->
	logDebug("transform: " + m.name) ->
	setName( m.name ) ->
	// walk containment
	m.nestedPackage.transform( this ) ->
	this;

Void transform(Package this, PPackage model) :
	logDebug("process uml package: " + name) ->
	logDebug( ownedElement.typeSelect( InstanceSpecification ).toString() ) ->
	logDebug( ownedElement.typeSelect( InstanceSpecification ).first().classifier.toString() ) ->
	logDebug( ownedElement.typeSelect( InstanceSpecification ).classifier.name.toString() ) ->
	//logDebug( "" + ownedElement.typeSelect( InstanceSpecification ).first().classifier.first().name.l ) ->
	( let is = ownedElement.typeSelect( InstanceSpecification ) :
		is.select( e|e.isPackage() ).transformPackage() ->
		is.select( e|e.isRoot() ).transformRoot() ->
		is.select( e|e.isCompositeArea() ).transformCompositeArea() ->
		is.select( e|e.isElementArea() ).transformElementArea() ->
		is.select( e|e.isReferenceArea() ).transformReferenceArea() ->
		is.select( e|e.isUserDefinedArea() ).transformUserDefinedArea() ->
		is.select( e|e.isAutomaticallyGeneratedArea() ).transformAutomaticallyGeneratedArea()
	) ->
	null;

/**
 * Transforms the specified instance specification with references to other model elements.
 */
cached Void transformPackage(InstanceSpecification is) :
	logDebug("transform package: " + is.name) -> (
		let this = makePackage(is) :
			// no model references to transform
		this
	);

/**
 * Transforms the specified instance specification with references to other model elements.
 */
cached Void transformRoot(InstanceSpecification is) :
	logDebug("transform root: " + is.name) -> (
		let this = makeRoot( is ) :
			// no model references to transform
		this
	);
	
/**
 * Transforms the specified instance specification with references to other model elements.
 */
cached Void transformCompositeArea(InstanceSpecification is) :
	logDebug("transform composite area: " + is.name) -> (
		let this = makeCompositeArea( is ) :
			// no model references to transform
		this
	);
	
/**
 * Transforms the specified instance specification with references to other model elements.
 */
cached Void transformElementArea(InstanceSpecification is) :
	logDebug("transform element area: " + is.name) -> (
		let this = makeElementArea( is ) :
			// no model references to transform
		this
	);
	
/**
 * Transforms the specified instance specification with references to other model elements.
 */
cached Void transformReferenceArea(InstanceSpecification is) :
	logDebug("transform reference area: " + is.name) -> (
		let this = makeReferenceArea( is ) :
			// model references
			setTarget( is.target().transformRoot() ) ->
		this
	);
	
/**
 * Transforms the specified instance specification with references to other model elements.
 */
cached Void transformUserDefinedArea(InstanceSpecification is) :
	logDebug("transform user defined area: " + is.name) -> (
		let this = makeUserDefinedArea( is ) :
			// no model references to transform
		this
	);
	
/**
 * Transforms the specified instance specification with references to other model elements.
 */
cached Void transformAutomaticallyGeneratedArea(InstanceSpecification is) :
	logDebug("transform automatically generated area: " + is.name) -> (
		let this = makeAutomaticallyGeneratedArea( is ) :
			// no model references to transform
		this
	);
	
/**
 * Transforms the specified instance specification without references to other model elements.
 */
PAbstractArea makeAbstractArea(InstanceSpecification this) :
	switch {
		case isRoot() : makeRoot()
		case isCompositeArea() : makeCompositeArea()
		default : null
	};
	
/**
 * Transforms the specified instance specification without references to other model elements.
 */
PContentArea makeContentArea(InstanceSpecification this) :
	switch {
		case isCompositeArea() : makeCompositeArea()
		case isElementArea() : makeElementArea()
		case isReferenceArea() : makeReferenceArea()
		case isUserDefinedArea() : makeUserDefinedArea()
		case isAutomaticallyGeneratedArea() : makeAutomaticallyGeneratedArea()
		default : null
	};
	
/**
 * Transforms the specified instance specification with properties and containment but without references to other model elements.
 * It ensures the containment:
 * - if the PPackage has a nesting package, it is used as containment
 * - else the root PPackage (top level) will be used
 */
create PPackage makePackage(InstanceSpecification is) :
	logDebug("make package: " + is.name) ->
	// properties
	setName( is.name ) ->
	// containment: either in nesting package or root package
	is.hasNestingPackage()
		? is.nestingPackage().makePackage().nestedPackage.add( this )
		: model().nestedPackage.add( this ) ->
	this;
	
/**
 * Transforms the specified instance specification with properties and containment but without references to other model elements.
 */
create PRoot makeRoot(InstanceSpecification is) :
	logDebug("make root: " + is.name) ->
	// inheritance
	copyAA( is ) ->
	// containment
	is.package().makePackage().root.add( this ) ->
	this;
	
/**
 * Transforms the specified instance specification with properties and containment but without references to other model elements.
 */
create PCompositeArea makeCompositeArea(InstanceSpecification is) :
	logDebug("make composite area: " + is.name) ->
	// inheritance
	copyAA( is ) ->
	// inheritance + containment
	copyCA( is.area().makeAbstractArea(), is ) ->
	this;

/**
 * Transforms the specified instance specification with properties and containment but without references to other model elements.
 */
create PElementArea makeElementArea(InstanceSpecification is) :
	logDebug("make element area: " + is.name) ->
	// properties
	setName( is.name ) ->
	// inheritance + containment
	copyCA( is.area().makeAbstractArea(), is ) ->
	this;

/**
 * Transforms the specified instance specification with properties and containment but without references to other model elements.
 */
create PReferenceArea makeReferenceArea(InstanceSpecification is) :
	logDebug("make reference area: " + is.name) ->
	// inheritance + containment
	copyCA( is.area().makeAbstractArea(), is ) ->
	this;

/**
 * Transforms the specified instance specification with properties and containment but without references to other model elements.
 */
create PUserDefinedArea makeUserDefinedArea(InstanceSpecification is) :
	logDebug("make user defined area: " + is.name) ->
	// inheritance + containment
	copyCA( is.area().makeAbstractArea(), is ) ->
	this;

/**
 * Transforms the specified instance specification with properties and containment but without references to other model elements.
 */
create PAutomaticallyGeneratedArea makeAutomaticallyGeneratedArea(InstanceSpecification is) :
	logDebug("make automatically generated area: " + is.name) ->
	// inheritance + containment
	copyCA( is.area().makeAbstractArea(), is ) ->
	this;

/**
 * Copies properties of abstract area.
 */
PAbstractArea copyAA(PAbstractArea this, InstanceSpecification is) :
	// properties
	setName( is.name ) ->
	this;

/**
 * Copies properties of abstract area.
 */
PAbstractArea copyCA(PContentArea this, PAbstractArea container, InstanceSpecification is) :
	// containment
	container.content.add( this ) ->
	this;


// - - helper functions - - - - - - - - - - - - - - - - - - - - - - - - - - - -

/**
 * Returns the first instance specification value of the specified feature.
 * Note: If there are more features with the same name, the first one is used!
 */
InstanceSpecification one(InstanceSpecification this, String featureName) :
	slot.selectFirst( e|e.definingFeature.name == featureName ).value.typeSelect(InstanceValue).first().instance;
	
/**
 * Returns all instance specification values of the specified feature.
 * Note: If there are more features with the same name, the first one is used!
 */
List[InstanceSpecification] many(InstanceSpecification this, String featureName) :
	slot.exists( e|e.definingFeature.name == featureName )
		? slot.selectFirst( e|e.definingFeature.name == featureName ).value.typeSelect(InstanceValue).instance
		: {};

/**
 * Returns true if it's a PPackage, otherwise else.
 */
boolean isPackage(InstanceSpecification this) : classifier.exists( e|e.name == "PPackage" );
/**
 * Returns true if it's a PRoot, otherwise else.
 */
boolean isRoot(InstanceSpecification this) : classifier.exists( e|e.name == "PRoot" );
/**
 * Returns true if it's a PCompositeArea, otherwise else.
 */
boolean isCompositeArea(InstanceSpecification this) : classifier.exists( e|e.name == "PCompositeArea" );
/**
 * Returns true if it's a PAbstractArea, otherwise else.
 */
boolean isAbstractArea(InstanceSpecification this) : classifier.exists( e|e.name == "PAbstractArea" );
/**
 * Returns true if it's a PContentArea, otherwise else.
 */
boolean isContentArea(InstanceSpecification this) : classifier.exists( e|e.name == "PContentArea" );
/**
 * Returns true if it's a PElementArea, otherwise else.
 */
boolean isElementArea(InstanceSpecification this) : classifier.exists( e|e.name == "PElementArea" );
/**
 * Returns true if it's a PReferenceArea, otherwise else.
 */
boolean isReferenceArea(InstanceSpecification this) : classifier.exists( e|e.name == "PReferenceArea" );
/**
 * Returns true if it's a PUserDefinedArea, otherwise else.
 */
boolean isUserDefinedArea(InstanceSpecification this) : classifier.exists( e|e.name == "PUserDefinedArea" );
/**
 * Returns true if it's a PAutomaticallyGeneratedArea, otherwise else.
 */
boolean isAutomaticallyGeneratedArea(InstanceSpecification this) : classifier.exists( e|e.name == "PAutomaticallyGeneratedArea" );

boolean hasNestingPackage(InstanceSpecification this) : slot.exists( e|e.definingFeature.name == "nestingPackage" );
InstanceSpecification nestingPackage(InstanceSpecification this) : one("nestingPackage");
List[InstanceSpecification] nestedPackage(InstanceSpecification this) : many("nestedPackage");
boolean hasPackage(InstanceSpecification this) : slot.exists( e|e.definingFeature.name == "package" );
InstanceSpecification package(InstanceSpecification this) : one("package");
boolean hasArea(InstanceSpecification this) : slot.exists( e|e.definingFeature.name == "area" );
InstanceSpecification area(InstanceSpecification this) : one("area");
InstanceSpecification content(InstanceSpecification this) : many("content");
boolean hasTarget(InstanceSpecification this) : slot.exists( e|e.definingFeature.name == "target" );
InstanceSpecification target(InstanceSpecification this) : one("target");
