/**
 * Additions of the model before generation of source code.  
 *  
 * @author	Nico Herbig <nico.herbig@fh-zwickau.de>
 * @date	2011-07-14
 */

//	based on genesez meta model
import gcore;

// use common logging scripts
extension de::genesez::platforms::common::log::Log;

// use TYPO3 Extbase profile + access helper scripts
extension de::genesez::platform::typo3::extbase::profile::Profile;
extension de::genesez::platform::typo3::extbase::profile::AccessHelper;

// use TYPO3 Fluid profile + access helper scripts
extension de::genesez::platform::typo3::fluid::profile::Profile;
extension de::genesez::platform::typo3::fluid::profile::AccessHelper;

// use TYPO3 Extbase naming scripts
extension de::genesez::platform::typo3::extbase::convention::Naming;

// use TYPO3 Extbase access helper scripts which overrides
// common access helper scripts if script name is equal 
extension de::genesez::platform::typo3::extbase::scripts::AccessHelper;
extension de::genesez::platforms::common::AccessHelper;

// use common create template scripts
extension de::genesez::platforms::common::m2m::CreateTemplate;


/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	MPackage (MModel)
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

Void modelAdditions(MModel this) :
	packageAdditions();


Void packageAdditions(MPackage this) :
	// perform model additions for all nested packages
	this.nestedPackage.packageAdditions() ->
	
	// perform model additions for all classes
	this.classifier.typeSelect(MClass).classAdditions();


/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	MClass
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

Void classAdditions(MClass this) :
	switch {
		case isController() :
			controllerAdditions()
		case isEntity() :
			entityAdditions()
		case isValueObject() :
			valueObjectAdditions()
		case isRepository() :
			repositoryAdditions()
		case isValidator() :
			validatorAdditions()
		case isViewHelper() :
			viewHelperAdditions()
		default :
			Void
	};	


/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	TYPO3 Extbase Controller additions
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

/**
 * Model additions for an TYPO3 Extbase controller.
 */
Void controllerAdditions(MClass this) :
	// add super controller type 
	addControllerType() ->
	// create 'initalizeAction' if it should
	addControllerInitializeAction() ->
	// create 'errorAction' if it should
	addControllerErrorAction() ->
	// create 'getErrorFlashMessage' if it should
	addControllerGetErrorFlashMessage() ->
	// create 'initalizeAction' for all actions which have the sterotype
	operation.select( o | o.hasT3ExtbaseControllerActionCreateInitializeAction("true") )
		.addControllerActionInitializeAction();
 

Void addControllerType(MClass this) :
	// checks if the class has a stereotype 
	hasT3ExtbaseControllerStereotype()
		// if true, then create the super controller type which is specified
		? (	let controllerType = getT3ExtbaseControllerControllerType() :
				switch {
					case controllerType == prT3ExtbaseControllerTypeExtbaseControllerInterface() :
						realization.add( createExternal( model(), controllerType ) )
					case generalization.isEmpty :
						generalization.add( createExternal( model(), controllerType ) )
					default : Void
				}
		)
		// else create the default one
		: (	generalization.isEmpty 
				? generalization.add( createExternal( model(), prT3ExtbaseControllerTypeExtbaseActionController() ) )
				: Void
		);


/**
 * Add the 'initalizeAction' to the controller class.
 */
Void addControllerInitializeAction(MClass this) :
	// checks if the initalize action should be created and doesn't already exists
	hasT3ExtbaseControllerCreateInitializeAction("true")
	&& operation.select( o | o.name() == "initalizeAction" ).isEmpty
		? (	let o = createOperation(this, this.xmiGuid + ".initalizeAction", "initalizeAction") :
				// (visibility, static, abstract, final, multiplicity, unique, ordered)
				o.processOperation("protected", false, false, false, 1, false, false) ->
				// add comment to discribe the operation
				o.ownedComment.add( 
					createComment(o.xmiGuid + ".comment", "Override initalizeAction to solve tasks which all actions have in common.") 
				)
		) : Void;


Void addControllerErrorAction(MClass this) :
	// checks if the error action should be created and doesn't already exists
	hasT3ExtbaseControllerCreateErrorAction("true")
	&& operation.select( o | o.name() == "errorAction" ).isEmpty
		? (	let o = createOperation(this, this.xmiGuid + ".errorAction", "errorAction") :
				// (visibility, static, abstract, final, multiplicity, unique, ordered)
				o.processOperation("protected", false, false, false, 1, false, false) ->
				// add comment to discribe the operation
				o.ownedComment.add( 
					createComment(o.xmiGuid + ".comment", "Override errorAction to show that errors happend.") 
				)
		) : Void;


Void addControllerGetErrorFlashMessage(MClass this) :
	// checks if the get error flash message method should be created and doesn't already exists
	hasT3ExtbaseControllerCreateGetErrorFlashMessage("true")
	&& operation.select(o| o.name() == "getErrorFlashMessage" ).isEmpty
		? (	let o = createOperation(this, this.xmiGuid + ".getErrorFlashMessage", "getErrorFlashMessage") :
				// (visibility, static, abstract, final, multiplicity, unique, ordered)
				o.processOperation("protected", false, false, false, 1, false, false) ->
				// add comment to discribe the operation
				o.ownedComment.add( 
					createComment(o.xmiGuid + ".comment", "Override getErrorFlashMessage to customize the flash message.") 
				) ->
				o.setReturn(
					let return = createParameter(o, o.xmiGuid + ".return", "") :
						return.processParameter("", "return", 1, true, false) ->
						return.ownedComment.add( 
							createComment(o.xmiGuid + ".return.comment", "The flash message") 
						) ->
						return.setType( 
							createPrimitiveTypeString( model() ) 
						) ->
						return
				) ->
				o.stereotype.add( 
					createStereotype( model(), o.xmiGuid + "." + prT3ExtbaseNoControllerAction(), prT3ExtbaseNoControllerAction() ) 
				)
		) :  Void;


Void addControllerActionInitializeAction(MOperation this) :
	// checks if the initalize action for an action should be created and doesn't already exists
	hasT3ExtbaseControllerActionCreateInitializeAction("true") 
	&& classifier.operation.select( o | o.name() == "initalize" + name.toFirstUpper() ).isEmpty
		? (	let o = createOperation(classifier, this.xmiGuid + ".initalize" + name.toFirstUpper() + "Action", "initalize" + name.toFirstUpper() + "Action") :
				// (visibility, static, abstract, final, multiplicity, unique, ordered)
				o.processOperation("protected", false, false, false, 1, false, false) ->
				// add comment to discribe the operation
				o.ownedComment.add( 
					createComment(o.xmiGuid + ".comment", "Define initialize" + name.toFirstUpper() + "Action" + " to solve tasks before the action is called.") 
				)
		) : Void;


/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	TYPO3 Extbase Model additions
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

/*
- - Entitiy additions - - - - - - - - - - - - - - - - - - - - - - - - -

*/

/**
 * Model additions for an TYPO3 Extbase entity.
 */
Void entityAdditions(MClass this) :
	// add super entity type
	addEntityType() ->
	addClassValidator(); 


Void addEntityType(MClass this) :
	// checks if the class has a stereotype 
	hasT3ExtbaseEntityStereotype()
		// if true, then create the super entity type which is specified
		? (	let entityType = getT3ExtbaseEntityEntityType() :
				switch {
					case generalization.isEmpty :
						generalization.add( createExternal( model(), entityType ) )
					default : Void
				}
		)
		// else create the default one
		: (	generalization.isEmpty 
				? generalization.add( createExternal( model(), prT3ExtbaseEntityTypeExtbaseAbstractEntity() ) )
				: Void
		);

	
/*
- - Value Object additions  - - - - - - - - - - - - - - - - - - - - - -
*/

/**
 * Model additions for an TYPO3 Extbase value object.
 */
Void valueObjectAdditions(MClass this) :
	// add super value object type
	addValueObjectType() ->
	addClassValidator();


Void addValueObjectType(MClass this) :
	// checks if the class has a stereotype 
	hasT3ExtbaseValueObjectStereotype()
		// if true, then create the super value object type which is specified
		? ( let valueObjectType = getT3ExtbaseValueObjectValueObjectType() :
				switch {
					case generalization.isEmpty :
						generalization.add( createExternal( model(), valueObjectType ) )
					default : Void
				}
		) 
		// else create the default one
		: (	generalization.isEmpty 
				? generalization.add( createExternal( model(), prT3ExtbaseValueObjectTypeExtbaseAbstractValueObject() ) )
				: Void 
		);


/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	TYPO3 Extbase Repository additions
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

/**
 * Model additions for an TYPO3 Extbase repository.
 */
Void repositoryAdditions(MClass this) :
	// add super repository type
	addRepositoryType() ->
	additionAddRepositoryInitializeObject();


Void addRepositoryType(MClass this) :
	// checks if the class has a stereotype 
	hasT3ExtbaseRepositoryStereotype()
		// if true, then create the super repository type which is specified
		? ( let repositoryType = getT3ExtbaseRepositoryRepositoryType() :
				switch {
					case generalization.isEmpty :
						generalization.add( createExternal( model(), repositoryType ) )
					default : Void
				} 
		) 
		// else create the default one
		: (	generalization.isEmpty 
				? generalization.add( createExternal( model(), prT3ExtbaseRepositoryTypeExtbaseRepository() ) )
				: Void 
		);


Void additionAddRepositoryInitializeObject(MClass this) :
	// checks if the initalize object operation should be created and doesn't already exists
	hasT3ExtbaseRepositoryCreateInitializeObject("true")
	&& operation.select( o | o.name() == "initalizeObject" ).isEmpty
		? (	let o = createOperation(this, this.xmiGuid + ".initalizeObject", "initalizeObject") :
				o.processOperation( "public", false, false, false, 1, false, false ) ->
				// add comment to discribe the operation
				o.ownedComment.add( 
					createComment(o.xmiGuid + ".comment", "Life cycle method.") 
				)
		) : Void;

/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	TYPO3 Extbase Service additions
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/


/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	TYPO3 Extbase Validator additions
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

/**
 * Model additions for an TYPO3 Extbase repository.
 */
Void validatorAdditions(MClass this) :
	// add super validiator type
	addValidatorType();


Void addValidatorType(MClass this) :
	// checks if the class has a stereotype
	hasT3ExtbaseValidatorStereotype()
		// if true, then create the super validator type which is specified
		? ( let validatorType = getT3ExtbaseValidatorValidatorType() :
				switch {
					case validatorType == prT3ExtbaseValidatorTypeExtbaseValidatorInterface() :
						realization.add( createExternal( model(), validatorType ) )
					case generalization.isEmpty :
						generalization.add( createExternal( model(), validatorType ) )
					default : Void
				}
		)
		// else create the default one
		: ( generalization.isEmpty 
				? generalization.add( createExternal( model(), prT3ExtbaseValidatorTypeExtbaseAbstractValidator() ) )
				: Void 
		);


Void addClassValidator(MClass this) :
	( hasT3ExtbaseEntityCreateClassValidator("true") || hasT3ExtbaseValueObjectCreateClassValidator("true") )
	// maybe better to split at '_' and after that check the name
	&& model().allValidators().select( e | e.name().endsWith( name + "Validator" ) ).isEmpty
		? ( let c = createClass(model(), this.xmiGuid + ".validator", name + "Validator") :
				// (visibility, abstract, final)
				c.processClassifier("public", false, false) ->
				// add comment to discribe the operation
				c.ownedComment.add( 
					createComment(c.xmiGuid + ".comment", "Validator for a domain object.") 
				) ->
				// add super validator type
				c.addValidatorType() ->
				// add 'isValid'
				c.addClassValidatorIsValid(this) ->
				// add stereotype to mark this class as validator
				c.stereotype.add( 
					createStereotype( model(), c.xmiGuid + "." + prT3ExtbaseValidator(), prT3ExtbaseValidator() ) 
				)
		) : Void;


Void addClassValidatorIsValid(MClass this, MType valueToValidate) :
	// checks if the is valid method doesn't already exists
	operation.select(o| o.name() == "isValid" ).isEmpty
		? (	let o = createOperation(this, this.xmiGuid + ".isValid", "isValid" ) :
				// (visibility, static, abstract, final, multiplicity, unique, ordered)
				o.processOperation("public", false, false, false, 1, false, false) ->
				// add comment to discribe the operation
				o.ownedComment.add( 
					createComment(o.xmiGuid + ".comment", "Checks if the given value is valid according to the validator.") 
				) ->
				o.parameter.add(
					let value = createParameter(o, o.xmiGuid + ".value", "value") :
						// (defaultValue, direction, multiplicity, unique, ordered)
						value.processParameter("", "in", 1, true, false) ->
						value.ownedComment.add( 
							createComment(value.xmiGuid + ".comment", "The value that should be validated") 
						) ->
						value.setType( 
							valueToValidate
						) ->
						value
				) ->
				o.setReturn(
					let return = createParameter(o, o.xmiGuid + ".return", "") :
						// (defaultValue, direction, multiplicity, unique, ordered)
						return.processParameter("", "return", 1, true, false) ->
						return.ownedComment.add( 
							createComment(return.xmiGuid + ".comment", "TRUE if the value is valid, FALSE if an error occured") 
						) ->
						return.setType( 
							createPrimitiveTypeBoolean( model() ) 
						) ->
						return
				)
		) :  Void;


/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	TYPO3 Fluid ViewHelper additions
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

/**
 * Model additions for an TYPO3 Fluid view helper.
 */
Void viewHelperAdditions(MClass this) :
	// add super view helper type
	addViewHelperType();


Void addViewHelperType(MClass this) :
	// checks if the class has a stereotype 
	hasT3FluidViewHelperStereotype()
		// if true, then create the super view helper type which is specified
		? ( let viewHelperType = getT3FluidViewHelperViewHelperType() :
				switch {
					case generalization.isEmpty :
						generalization.add( createExternal( model(), viewHelperType ) )
					default : Void
				} 
		) 
		// else create the default one
		: (	generalization.isEmpty 
				? generalization.add( createExternal( model(), prT3FluidViewHelperTypeFluidAbstractViewHelper() ) )
				: Void 
		);

/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	Helper functions
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/