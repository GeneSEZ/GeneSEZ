
«IMPORT gcore»

«REM»
	Performs the generation of operations + constructors.
	- supports the stereotype '<<primitive>>' for multi-valued return types
	
	@author	nico herbig
	@author	tobias haubold
	@author andre pflueger (last)
«ENDREM»

«REM» useful support functions «ENDREM»
«EXTENSION org::genesez::platform::common::AccessHelper»
«EXTENSION org::genesez::platform::common::m2t::Helper»
«EXTENSION org::genesez::platform::common::typemapping::TypeMapping»

«EXTENSION org::genesez::platform::java::scripts::Type»
«EXTENSION org::genesez::platform::java::scripts::Naming»
«EXTENSION org::genesez::platform::java::scripts::Conversion»
«EXTENSION org::genesez::platform::java::scripts::Helper»
«EXTENSION org::genesez::util::logging::Logging»

«REM»
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
«ENDREM»

«REM»
	processes the operations of a classifier
	order: constructor, declarations, implementations
«ENDREM»
«DEFINE All FOR MClassifier -»
	«EXPAND Constructor -»
	«EXPAND Declaration -»
	«EXPAND Implementation -»
«ENDDEFINE»

«REM»
	processes all operations to declare
«ENDREM»
«DEFINE Declaration FOR MInterface -»
	«EXPAND _Declaration FOREACH operation -»
«ENDDEFINE»

«REM»
	processes all operations to declare
«ENDREM»
«DEFINE Declaration FOR MClassifier -»
	«EXPAND _Declaration FOREACH operation.select( e| !e.isConstructor() && e.abstract ) -»
«ENDDEFINE»

«REM»
	processes all constructors
	generates an initializing constructor for association classes + data types
«ENDREM»
«DEFINE Constructor FOR MClassifier -»
	«IF isAssociationClass() || isDataType() -»
	«EXPAND _InitializingConstructor -»
	«ENDIF -»
	«EXPAND _Constructor FOREACH operation.select( e| e.isConstructor() ) -»
«ENDDEFINE»

«REM»
	processes all operations to implement, that means no constructors + no abstract operations
	order: normal method, final methods, static methods
«ENDREM»
«DEFINE Implementation FOR MClassifier -»
	«EXPAND _Implementation FOREACH operation.select( e| !e.isConstructor() && !e.abstract && !e.final && !e.static) -»
	«EXPAND _Implementation FOREACH operation.select( e| !e.isConstructor() && !e.abstract && e.final && !e.static) -»
	«EXPAND _Implementation FOREACH operation.select( e| !e.isConstructor() && !e.abstract && !e.final && e.static) -»
«ENDDEFINE»

«REM»
	generates a getInstance operation for singleton pattern
	if stereotype "singleton" is available and there is no
	such operation
«ENDREM»
«DEFINE Singleton FOR MClass -»
	«IF this.hasStereotype("singleton") &&
	!this.operation.exists(e|e.name.matches("getInstance"))	-»
		public static «this.name.asTypeName() -» getInstance() {
			if (instance == null) {
				synchronized («this.name.asTypeName() -».class) {
					if (instance == null) {
						instance = new «this.name.asTypeName() -»();
					}
				}
			}
			return instance;
		}
	«ENDIF-»
«ENDDEFINE»

«REM»
	generate an equals and hashCode operation
	if stereotype "java5EqualsOperation" is available
	and at least one property has the stereotype "java5EqualsProperty"
«ENDREM»
«DEFINE Equals FOR MClass -»
	«IF hasStereotype("java5EqualsOperation") && 
		this.property.exists(e|e.hasStereotype("java5EqualsProperty")) -»
		/**
		  *	checks if instance and parameter other are equal according to specified properties
		  *
		  *	@param	other	to be compared instance of type Object
		  *
		  *	@return	true, if instances are equal
		  */
		public boolean equals(Object other) {
			if ( this == other ) {
				return true;
			}			
			«IF this.owningSpecializations().size > 0-»
				if ( other == null || this.getClass() != other.getClass() ) {
					return false;
				}
			«ELSE-»
				if (!(other instanceof «this.asTypeName()-»)) {
					return false;
				}
			«ENDIF-»
			«this.asTypeName()-» o = («this.asTypeName()-») other;
			return ( «EXPAND _SuperEquals-» «EXPAND _EqualsProperties-» );
		}
		
		/**
		  *	calculates the hash code using specified properties
		  *
		  *	@return	calculated hash code
		  */
		public int hashCode() {
			int result = 23;
			«EXPAND _SuperHashCode-»
			«FOREACH this.property.select(e|e.hasStereotype("java5EqualsProperty")).sortBy(e|e.name) AS value -»
				«IF !value.isJavaPrimitiveType()-»if (this.«value.asGetter()-»() != null) {
				«ENDIF-»result = 37 * result + this.«value.asGetter()-»()«IF !value.isJavaPrimitiveType()-».hashCode()«ENDIF-»;
				«IF !value.isJavaPrimitiveType()-»}
				«ENDIF-»
			«ENDFOREACH-»
			«IF this.owningSpecializations().size > 0-»result = 37 * result + this.getClass().hashCode();«ENDIF-»
			return result;
		}
	«ENDIF-»
«ENDDEFINE»

«DEFINE _EqualsProperties FOR MClass-»
	«FOREACH this.property.select(e|e.hasStereotype("java5EqualsProperty")).sortBy(e|e.name) AS value SEPARATOR " && "-»
		«IF value.isJavaPrimitiveType()-»
			this.«value.asGetter()-»() == o.«value.asGetter()-»()
		«ELSE-»
			( (this.«value.asGetter()-»() == null && o.«value.asGetter()-»() == null) ||
			( this.«value.asGetter()-»() != null && this.«value.asGetter()-»().equals(o.«value.asGetter()-»()) ) )
		«ENDIF-»
	«ENDFOREACH-»
«ENDDEFINE»

«DEFINE _SuperEquals FOR MClass-»
	«IF this.generalization.typeSelect(MClass).size > 0 && 
		this.generalization.typeSelect(MClass).first().hasStereotype("java5EqualsOperation")
		-»super.equals(o) &&
	«ENDIF-»
«ENDDEFINE»

«DEFINE _SuperHashCode FOR MClass-»
	«IF this.generalization.typeSelect(MClass).size > 0 && 
		this.generalization.typeSelect(MClass).first().hasStereotype("java5EqualsOperation")
		-»result = 37 * result + super.hashCode();
	«ENDIF-»
«ENDDEFINE»

«REM»
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	private functions
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
«ENDREM»

«REM»
	generates an initializing constructor
	all initializable attributes of the type and supertypes are set within the constructor
«ENDREM»
«DEFINE _InitializingConstructor FOR MClassifier-»
	«IF hasInitializableAttributes()-»
		«EXPAND Comment::InitConstructor-»
		public «asTypeName()-»(«EXPAND _Params FOREACH allInitializableAttributes() SEPARATOR ", "-») {
			«EXPAND _SuperInit FOREACH generalization-»
			«FOREACH owningInitializableAttributes() AS attr-»
				this.«attr.asAttribute()-» = «attr.asAttribute()-»;
			«ENDFOREACH-»
		}
	«ENDIF»
«ENDDEFINE»

«REM»
	generates the parameter list for the initializing constructor
«ENDREM»
«DEFINE _Params FOR MAttribute-»
	«EXPAND _Annotation-»
	«IF isSingleValuedType()-»
		«type.mapName().asTypeName()-»«EXPAND Type::GenericUse» «asAttribute()-»
	«ELSE-»
		«EXPAND Type::MultiValuedType-» «asAttribute()-»
	«ENDIF-»
«ENDDEFINE»

«REM»
	generates the super constructor call for initializing constructors
«ENDREM»
«DEFINE _SuperInit FOR MClassifier -»
	super(«FOREACH allInitializableAttributes() AS attr SEPARATOR ", "-» «attr.asAttribute() -»«ENDFOREACH -»);
«ENDDEFINE»

«REM»
	generates the super constructor call for initializing constructors
	if you inherit from external types, this is your define for your 'around' statement
«ENDREM»
«DEFINE _SuperInit FOR MType -»
	super();
«ENDDEFINE»

«REM»
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
«ENDREM»

«REM»
	generates a constructor
	a constructor has no 'modifiers' and no 'return value'
«ENDREM»
«DEFINE _Constructor FOR MOperation-»
	«EXPAND Comment::Constructor-»
	«EXPAND _Annotation-»
	«modifier()-» «classifier.asTypeName()-»(«EXPAND _Params-») «EXPAND _Exception-» {
		«EXPAND _ConstructorBody-»
	}
«ENDDEFINE»

«REM»
	generates an operation declaration
	distincts the multiplicity of the return type
«ENDREM»
«DEFINE _Declaration FOR MOperation-»
	«EXPAND Comment::Operation-»
	«EXPAND _Annotation-»
	«IF isSingleValuedType() && return.type.mapName() != null-»
		«EXPAND _Modifier» «EXPAND _SingleValueReturn-»«EXPAND Type::GenericUse FOR return» «asOperation()»(«EXPAND _Params») «EXPAND _Exception -»;
	«ELSEIF isMultiValuedType()-»
		«EXPAND _Modifier-» «EXPAND Type::MultiValuedType FOR return-» «asOperation()-»(«EXPAND _Params-») «EXPAND _Exception-»;
	«ELSE -»
		«EXPAND _Modifier-» void «asOperation()-»(«EXPAND _Params-») «EXPAND _Exception-»;
	«ENDIF-»
«ENDDEFINE»

«REM»
	generates an operation implementation
	distincts the multiplicity of the return type
«ENDREM»
«DEFINE _Implementation FOR MOperation-»
	«EXPAND Comment::Operation-»
	«EXPAND _Annotation-»
	«IF isSingleValuedType() && return.type.mapName() != null-»
		«EXPAND _Modifier-» «EXPAND _SingleValueReturn-»«EXPAND Type::GenericUse FOR return» «asOperation()-»(«EXPAND _Params-») «EXPAND _Exception-» {
	«ELSEIF isMultiValuedType()-»
		«EXPAND _Modifier-» «EXPAND Type::MultiValuedType FOR return-» «asOperation()-»(«EXPAND _Params-») «EXPAND _Exception-» {
	«ELSE -»
		«EXPAND _Modifier-» void «asOperation()-»(«EXPAND _Params-») «EXPAND _Exception-» {
	«ENDIF-»
	«EXPAND _ImplementationBody-»
	}
«ENDDEFINE»

«REM»
	generates the visibility and the modifiers static, final + abstract for an operation
	interfaces methods are always 'public' and 'abstract'
«ENDREM»
«DEFINE _Modifier FOR MOperation -»
	«IF classifier.metaType == MInterface -»
	public
	«ELSE -»
	«modifier()» «IF static»static«ENDIF» «IF final»final«ENDIF» «IF abstract»abstract«ENDIF» «EXPAND _Concurrent-» 
	«ENDIF -»
«ENDDEFINE»

«REM»
	generates the return type of the operation
«ENDREM»
«DEFINE _SingleValueReturn FOR MOperation -»
	«return.type.mapName().asTypeName()»
«ENDDEFINE»

«REM»
	generates the parameters of an operation
«ENDREM»
«DEFINE _Params FOR MOperation -»
	«FOREACH parameter AS p SEPARATOR ", "-»
		«EXPAND _Annotation FOR p-» «IF p.isSingleValuedType()-»
			«p.type.mapName().asTypeName() -» «p.asParameter()» «IF p.hasDefaultValue()-» = «p.defaultvalue-»«ENDIF-»
		«ELSE-»
			«EXPAND Type::MultiValuedType FOR p-» «p.asParameter()-» «IF p.hasDefaultValue()-» = «p.defaultvalue-»«ENDIF-»
		«ENDIF-»
	«ENDFOREACH-»
«ENDDEFINE»

«REM»
	generates the exceptions an operation can throw
«ENDREM»
«DEFINE _Exception FOR MOperation -»
«IF hasExceptions() -»
	throws «FOREACH raisedException AS e SEPARATOR ", " -» «e.mapName().asTypeName()» «ENDFOREACH -»
«ENDIF-»
«ENDDEFINE»


«REM»
	generates the constructor body with a protected region, an eclipse task and
	an implementation which throws an exception that this method is not yet supported
«ENDREM»
«DEFINE _ConstructorBody FOR MOperation -»
	«IF !hasStereotype("http://www.genesez.org/StandardConstructor")-»
		«PROTECT CSTART '/* ' CEND ' */' ID ("java.constructor." + xmiGuid)»
		// TODO: implementation of constructor for class '«classifier.asTypeName()»'
			throw new UnsupportedOperationException(
					"The implementation of this generated constructor is missing!");
		«ENDPROTECT»
	«ENDIF-»		
«ENDDEFINE»

«REM»
	generates the implementation body with a protected region, an eclipse task and
	an implementation which throws an exception that this method is not yet supported
«ENDREM»
«DEFINE _ImplementationBody FOR MOperation -»
		«PROTECT CSTART '/* ' CEND ' */' ID ("java.implementation." + xmiGuid)»
		// TODO: implementation of method '«classifier.asTypeName()».«asOperation()»(...)'
		throw new UnsupportedOperationException(
				"The implementation of this generated method stub is missing!");
		«ENDPROTECT»
«ENDDEFINE»

«REM»
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
«ENDREM»

«REM»
	generates the body of an operation with a default return statement and a region for own code implementations
	distincts the multi-valued return type
	@deprecated		replaced by {@link _ImplmentationBody} + {@link _ConstructorBody}
«ENDREM»
«DEFINE _DefaultReturnAndOwnCodeImpl FOR MOperation -»
	«IF isSingleValuedType() -»
		«getReturnTypeDeclaration(return.type.mapName().asTypeName())»
	«ELSE -»
		«EXPAND Type::MultiValuedType -» returnValue = null;
	«ENDIF -»
	«EXPAND _OwnCodeImpl("java.implementation." + xmiGuid) -»
	«getReturnTypeReturn(return.type.mapName().asTypeName())»
«ENDDEFINE»

«REM»
	generates the protected region of an operation
	@param	id	protected region id
	@deprecated
«ENDREM»
«DEFINE _OwnCodeImpl(String id) FOR MOperation -»
	«IF isConstructor() -»
		«PROTECT CSTART '/* ' CEND ' */' ID (id)»
		// TODO: implementation of constructor for class '«classifier.asTypeName()»'
		«ENDPROTECT»
	«ELSE -»
		«PROTECT CSTART '/* ' CEND ' */' ID (id)»
		// TODO: implementation of method '«classifier.asTypeName()».«asOperation()»(...)'
		«ENDPROTECT»
	«ENDIF -»
«ENDDEFINE»

«REM»
	generates synchronized key word using UML CallConcurrencyKind
«ENDREM»
«DEFINE _Concurrent FOR MOperation -»
	«IF hasStereotype("http://www.genesez.org/CallConcurrencyKind/Guarded")-»synchronized «ENDIF -»
«ENDDEFINE»

«REM»
	will be overriden by other cartridges to generate annotations by using aspects
«ENDREM»
«DEFINE _Annotation FOR MOperation-»
	«EXPAND Element::JavaAnnotation -»
«ENDDEFINE»

«REM»
	will be overriden by other cartridges to generate annotations by using aspects
«ENDREM»
«DEFINE _Annotation FOR MParameter-»
	«EXPAND Element::JavaAnnotation -»
«ENDDEFINE»

«REM»
	will be overriden by other cartridges to generate annotations by using aspects
«ENDREM»
«DEFINE _Annotation FOR MAttribute-»
	«EXPAND Element::JavaAnnotation -»
«ENDDEFINE»
