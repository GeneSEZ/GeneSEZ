<?xml version='1.0'?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" "http://www.oasis-open.org/docbook/xml/4.0/docbookx.dtd">
<book>

  <bookinfo>

    <title>Das GeneSEZ Generator Framework</title>

    <authorgroup>

      <author><firstname>Tobias</firstname><surname>Haubold</surname></author>

      <author><firstname>Frank</firstname><surname>Grimm</surname></author>

      <author><firstname>Oliver</firstname><surname>Arnold</surname></author>

      <author><firstname>Gerrit</firstname><surname>Beine</surname></author>

    </authorgroup>

    <edition>Handbuch Version 1.6</edition>
    <pubdate>2009</pubdate>

    <copyright><year>2006</year><year>2007</year><year>2008</year><year>2009</year><holder>GeneSEZ</holder></copyright>
  </bookinfo>

  <part>

    <title>Getting Started</title>

    <chapter>

      <title>Der GeneSEZ-Ansatz</title>

      <para>In diesem Kapitel sollen die Hintergr&uuml;nde f&uuml;r die 
      Entstehung des GeneSEZ-Frameworks n&auml;her beschrieben werden. Dazu 
      werden kurz die modellgetriebene Softwareentwicklung sowie einige 
      Herausforderungen, denen sich diese Art der Softwareentwicklung 
      gegen&uuml;bersieht, aufgezeigt. Davon ausgehend wird dann der 
      GeneSEZ-Ansatz vorgestellt, der einigen dieser Herausforderungen 
      begegnen soll.</para>

      <sect1>

        <title>Modellgetriebene Softwareentwicklung</title>

        <para>Die modellgetriebene Softwareentwicklung (kurz MDSD f&uuml;r 
        engl. model driven software development) besch&auml;ftigt sich 
        allgemein mit der Generierung von Quellcode einer Software aus 
        formalen Modellen.</para>

        <para>Dabei dienen Modelle nicht mehr nur als Dokumentation 
        oder Visualisierung von Realisierungsproblemen einer Software, 
        sondern r&uuml;cken selbst in den Mittelpunkt der 
        Softwareentwicklung. Dass es sich um formale Modelle handeln 
        muss, ergibt sich daraus, dass sie automatisch in Quellcode 
        transformiert werden sollen. Die Formalit&auml;t wird dabei durch 
        die Verwendung eines Metamodells gew&auml;hrleistet.</para>

        <para>Als Ziele der MDSD werden meist die Wiederverwendung von 
        Architekturen, die gleichbleibend hohe Qualit&auml;t des Quellcodes 
        sowie die Steigerung der Entwicklungsgeschwindigkeit 
        genannt.</para>

      </sect1>

      <sect1>

        <title>Herausforderungen und Hindernisse der MDSD</title>

        <sect2>

          <title>Wahl des Metamodells</title>

          <para>Wie bereits erw&auml;hnt, bildet die Grundlage der MDSD ein 
          Metamodell, welchem die Modelle der zu entwickelnden 
          Applikation gen&uuml;gen. Basierend auf diesem Metamodell werden 
          die Transformationen zur Generierung von Quellcode 
          entwickelt.</para>

          <para>Eine zentrale Herausforderung ist dabei die Wahl des 
          Metamodells. Hier werden meist entweder dom&auml;nenspezifische 
          Sprachen (sog. DSL f&uuml;r engl. domain specific language) oder 
          die Unified Modeling Language (UML) eingesetzt. DSLs sind 
          speziell f&uuml;r einen bestimmten Anwendungs- bzw. Problembereich 
          geeignet. Sie besitzen eine sehr pr&auml;zise Ausdrucksweise mit 
          der Semantik des Problembereichs und sind deshalb auch auf 
          diesen beschr&auml;nkt. H&auml;ufig sind DSLs nicht standardisiert, 
          wodurch die Kommunikation zwischen Entwicklern leiden kann, 
          da jeder Entwickler erst diese spezielle Sprache erlernen 
          muss. Werden DSLs durch die Entwickler selbst definiert, so 
          m&uuml;ssen diese auch in einem Entwicklungsprozess mit gepflegt 
          werden.</para>

          <para>Die UML dagegen ist ein Standard zur Modellierung von 
          Software, der von der OMG spezifiziert wurde. Sie ist 
          allgemeing&uuml;ltig und unter Entwicklern i.d.R. bereits bekannt. 
          Ein wesentlicher Nachteil der UML ist die Komplexit&auml;t und die 
          fehlende Referenzimplementierung. Jedoch existiert mit dem 
          Eclipse-UML2-Projekt eine Implementierung der UML, die einige 
          Toolhersteller nutzen bzw. durch eine Export-Funktionalit&auml;t 
          unterst&uuml;tzen, wodurch sich dieses Projekt de facto zu einer 
          Referenzimplementierung entwickelt.</para>

        </sect2>

        <sect2>

          <title>MDSD-Entwicklungsprozess</title>

          <para>Im Vergleich zur herk&ouml;mmlichen Softwareentwicklung 
          kommen bei modellgetriebener Softwareentwicklung einige 
          weitere Tools zum Einsatz. Dazu geh&ouml;rt eine Software zur 
          Erstellung der Modelle.</para>

          <para>Weiterhin erfordert ein MDSD-Entwicklungsprozess:</para>

          <para />

          <para>* Modellvalidierungen zur &uuml;berpr&uuml;fung der Modelle</para>

          <para>* Modellmodifikationen, um kleine &auml;nderungen an 
          Modellen durchf&uuml;hren zu k&ouml;nnen</para>

          <para>* Modell-zu-Modell-Transformationen</para>

          <para>* Modell-zu-Text-Transformationen</para>

          <para />

          <para>Die Softwarebausteine zur Unterst&uuml;tzung der genannten 
          Aufgaben m&uuml;ssen gut zusammenarbeiten. Aktualisierungen 
          einzelner Bestandteile k&ouml;nnen sich hinderlich auf die 
          Zusammenarbeit auswirken. Im Zusammenhang mit diesen 
          aufeinander aufbauenden Aufgaben und Werkzeugen wird auch oft 
          von der so genannten &quot;Tool-Chain&quot; (dt. 
          Werkzeugkette).</para>

        </sect2>

        <sect2>

          <title>Wiederverwendung</title>

          <para>In einem MDSD-Entwicklungsprozess kommen verschiedene 
          Quellcode-Artefakte zum Einsatz. Einen wesentlichen Teil 
          bilden dabei die Templates f&uuml;r 
          Modell-zu-Text-Transformationen, aber auch Skripte f&uuml;r 
          Modell-Modifikationen, Modell-zu-Modell-Transformationen und 
          Hilfsfunktionen. Mit Hilfe dieser Artefakte wird der 
          Infrastruktur-Quellcode generiert, der anschlie&szlig;end fertig 
          implementiert werden muss. Da die Erstellung dieser Artefakte 
          eine nicht zu vernachl&auml;ssigende Zeit in Anspruch nimmt, 
          sollten diese Artefakte in einem MDSD-Entwicklungsprozess so 
          oft wie m&ouml;glich wiederverwendet werden.</para>

          <para />

          <para>All genannten Artefakte sind von dem verwendeten 
          Metamodell abh&auml;ngig. Kommt hierbei die UML zum Einsatz, wird 
          die Auswertung der Modellinformationen durch die Komplexit&auml;t 
          und hochgradige Normalisierung erschwert. 
          Modellmodifikationen und Modell-zu-Modell-Transformationen 
          sind nur mit sehr viel Aufwand realisierbar. Modelle 
          domainspezifischer Sprachen sind auf der anderen Seite 
          aufgrund ihrer Beschr&auml;nkung auf einen Problembereich leichter 
          auswertbar. Modellmodifikationen und 
          Modell-zu-Modell-Transformationen sind durch den beschr&auml;nkten 
          Umfang ebenfalls realisierbar. Problematisch kann allerdings 
          die Zukunftssicherheit der DSL sein. Ein Problem entsteht 
          beispielsweise, wenn Software f&uuml;r einen anderen 
          Anwendungsbereich entwickelt werden muss, welche die DSL 
          bisher nicht abdeckt.</para>

        </sect2>

      </sect1>

      <sect1>

        <title>GeneSEZ-Ansatz</title>

        <para>Das wesentliche Alleinstellungsmerkmal des 
        GeneSEZ-Ansatzes f&uuml;r modellgetriebene Softwareentwicklung ist 
        das GeneSEZ-Metamodell. Dabei handelt es sich um ein 
        allgemeing&uuml;ltiges Metamodell, welches die Basis des 
        Entwicklungsprozesses bildet. Dadurch wird die bereits 
        angesprochene Wiederverwendung der Artefakte des 
        Entwicklungsprozesses sicher gestellt sowie eine Entkopplung 
        von der verwendeten Modellierungssoftware erreicht.</para>

        <sect2>

          <title>GeneSEZ-Metamodell</title>

          <para>Das GeneSEZ-Metamodell kann weitgehend als 
          domainspezifisches Modell aufgefasst werden, wobei die Domain 
          hier die Generierung von Quellcode selbst ist. Es ist ein 
          allgemeing&uuml;ltiges Metamodell und ist dadurch der UML sehr 
          &auml;hnlich. Allerdings ist es sehr viel einfacher strukturiert, 
          um die Zugriffe auf Modellinformationen zu vereinfachen. Dazu 
          geh&ouml;ren kurze Navigationspfade sowie keine unn&ouml;tigen 
          abstrakten Elemente, die bei normalisierten Modellen 
          enthalten w&auml;ren.</para>

          <para />

          <para>Durch diese Vorgehensweise werden dem 
          Template-Entwickler die Modellinformationen in sinnvoller 
          Weise pr&auml;sentiert und die einfache Erstellung von 
          Modellmodifikationen sowie Modell-zu-Modell-Transformationen 
          wird erm&ouml;glicht.</para>

        </sect2>

        <sect2>

          <title>Modell-Adapter</title>

          <para>Durch die feste Verankerung eines Metamodells im 
          MDSD-Entwicklungsprozess stellt sich nat&uuml;rlich die Frage, wie 
          darauf aufbauende Modelle erstellt werden k&ouml;nnen. Es kan 
          schlie&szlig;lich kaum erwartet werden, dass Modellierer nur wegen 
          der Nutzung des GeneSEZ-Ansatzes ihre bereits seit langer 
          Zeit genutzte Modellierungssoftware aufgeben. Deshalb wurde 
          das Konzept der Modelladapter eingef&uuml;hrt, die ein auf einem 
          anderem Metamodell beruhendes Modell in ein 
          GeneSEZ-Metamodell-basiertes Modell &uuml;berf&uuml;hren k&ouml;nnen.</para>

          <para />

          <para>Obwohl der GeneSEZ-Ansatz kein Ausgangs-Metamodell 
          vorschreibt und somit jeder Anwender sein pr&auml;feriertes 
          Metamodell zur Erstellung der Modelle nutzen kann, wird 
          jedoch der Einsatz der UML empfohlen. Diese ist weit 
          verbreitet, standardisiert und vielen Entwicklern bereits 
          bekannt. Durch die wohldefinierte Semantik der 
          UML-Modellelemente ist ein einheitliches Verst&auml;ndnis des 
          Modells bei Entwicklern gegeben. Modelle auf Basis der 
          Eclipse-UML2-Implementierung werden durch das 
          GeneSEZ-Framework &quot;out-of-the-box&quot; 
          unterst&uuml;tzt.</para>

          <para />

          <para>DSLs hingegen m&uuml;ssen von jedem Entwickler erst erlernt 
          werden, wodurch ein einheitliches Grundverst&auml;ndnis der DSL 
          nicht ohne Weiteres gegeben ist. Jedoch werden auch DSLs 
          durch den GeneSEZ-Ansatz unterst&uuml;tzt. Ist die DSL auf Basis 
          der UML definiert so wird diese &quot;out-of-the-box&quot; 
          unterst&uuml;tzt. Andere DSLs k&ouml;nnen aufgrund deren zahlreichen 
          Auspr&auml;gungen und vielf&auml;ltigen Definitionsm&ouml;glichkeiten nicht 
          &quot;out-of-the-box&quot; unterst&uuml;tzt werden. F&uuml;r solche 
          DSLs ist die Erstellung eines Modelladapters erforderlich, 
          der das domainspezifische Modell in ein GeneSEZ-Modell 
          transformiert.</para>

        </sect2>

        <sect2>

          <title>GeneSEZ-Tooling</title>

          <para>Das GeneSEZ-Framework basiert ausschlie&szlig;lich auf 
          Open-Source-Software. Ein wesentlicher Bestandteil ist das 
          Generator-Framework openArchitectureWare. Das 
          GeneSEZ-Framwork besteht aus dem GeneSEZ-Metamodell, einigen 
          weiteren Komponenten sowie den Artefakten zur 
          Quellcodegenerierung.</para>

        </sect2>

      </sect1>

      <sect1>

        <title>Abschlussbemerkungen</title>

        <para>Wesentlich f&uuml;r einen MDSD-Entwicklungsprozess ist das in 
        ihm verankerte Metamodell. Der Stellenwert des Metamodells ist 
        somit relativ hoch. Die Artefakte, die in einem 
        Entwicklungsprozess genutzt werden, basieren ebenfalls auf dem 
        Metamodell. Die Erstellung der Artefakte des GeneSEZ-Frameworks 
        hat eine nicht unwesentliche Zeit in Anspruch genommen. Der 
        Umfang des Metamodells ist verglichen mit denen der Artefakte 
        relativ kompakt. Daher sollte der Umfang der Artefakte in einem 
        Entwicklungsprozess nicht untersch&auml;tzt werden.</para>

        <para />

        <para>Im folgenden Bild ist beispielhaft ein m&ouml;glicher 
        modellgetriebener Entwicklungsprozess auf Basis des 
        GeneSEZ-Frameworks abgebildet:</para>

      </sect1>

    </chapter>

    <chapter>

      <title>Installation von GeneSEZ</title>

      <para>In diesem How-To soll beschrieben werden, wie das 
      GeneSEZ-Framework installiert werden kann. Das GeneSEZ-Framework 
      ist derzeit als Eclipse-Plug-In verf&uuml;gbar.</para>

      <sect1>

        <title>GeneSEZ</title>

        <para>Version: 1.6.x</para>

        <para />

        <para>* Abh&auml;ngigkeiten: Eclipse SDK, openArchitectureWare, EMF, 
        UML2</para>

        <para>* Homepage: http://genesez.de/</para>

        <para>* Update-Site: 
        http://genesez.de/updatesite/site.xml</para>

        <para>* ben&ouml;tigte Features:</para>

        <para>o Identifier: de.genesez.feature.feature.group » GeneSEZ 
        Framework</para>

      </sect1>

      <sect1>

        <title>Ben&ouml;tigte Eclipse-Plug-Ins</title>

        <para>Das GeneSEZ-Framework basiert auf openArchitectureWare 
        und setzt demnach die folgenden Eclipse-Plug-Ins voraus. 
        Hinweis: Es sind jeweils nur die notwendigen Features der 
        einzelnen Plug-Ins gelistet. Bei Bedarf k&ouml;nnen nat&uuml;rlich auch 
        weitere Features installiert werden.</para>

        <sect2>

          <title>Eclipse SDK</title>

          <para>Version: 3.3.x</para>

          <para />

          <para>* Update-Site: 
          http://download.eclipse.org/eclipse/updates/3.3/</para>

          <para>* z.B. die Eclipse Classic IDE</para>

          <para />

          <para>Version: 3.4.x</para>

          <para />

          <para>* Update-Site: 
          http://download.eclipse.org/eclipse/updates/3.4/</para>

          <para>* z.B. Feature:</para>

          <para>o Identifier: org.eclipse.sdk.ide&apos; » Eclipse 
          Classic SDK</para>

        </sect2>

        <sect2>

          <title>openArchitectureWare</title>

          <para>Version: 4.3.x</para>

          <para />

          <para>* Abh&auml;ngigkeiten: EMF, UML2</para>

          <para>* Homepage: http://openarchitectureware.org/, 
          http://www.eclipse.org/gmt/oaw/</para>

          <para>* Update-Site: 
          http://www.openarchitectureware.org/updatesite/milestone/</para>

          <para>* ben&ouml;tigte Features:</para>

          <para>o Identifier: 
          org.openarchitectureware.lib.feature.feature.group » 
          openArchitectureWare libraries</para>

          <para>o Identifier: 
          org.openarchitectureware.core.feature.feature.group » 
          openArchitectureWare core</para>

          <para>o Identifier: 
          org.openarchitectureware.plugins.feature.feature.group » 
          openArchitectureWare plugins</para>

          <para>o Identifier: 
          org.openarchitectureware.uml2.adapter.feature.group » 
          openArchitectureWare uml2 adapter</para>

        </sect2>

        <sect2>

          <title>EMF</title>

          <para>Version: 2.3.x</para>

          <para />

          <para>* Homepage: http://www.eclipse.org/modeling/emf/</para>

          <para>* Update-Site: 
          http://download.eclipse.org/modeling/emf/updates/releases/</para>

          <para>* ben&ouml;tigte Features:</para>

          <para>o Identifier: org.eclipse.emf.feature.group » Eclipse 
          Modeling Framework (EMF) Runtime + End-User Tools</para>

        </sect2>

        <sect2>

          <title>UML2</title>

          <para>Version: 2.1.x</para>

          <para />

          <para>* Abh&auml;ngigkeiten: EMF</para>

          <para>* Homepage: 
          http://www.eclipse.org/modeling/mdt/?project=uml2</para>

          <para>* Update-Site: 
          http://download.eclipse.org/modeling/mdt/updates/releases/</para>

          <para>* ben&ouml;tigte Features:</para>

          <para>o Identifier: org.eclipse.uml2.feature.group » UML2 
          End-User Features</para>

          <para />

          <para>Das GeneSEZ-Framework l&auml;uft sowohl unter Eclipse 3.3 
          als auch unter Eclipse 3.4. Unter Eclipse 3.4 m&uuml;ssen 
          allerdings die oben aufgef&uuml;hrten &auml;lteren Versionen von EMF 
          und UML2 installiert werden, da die neueren noch nicht von 
          openArchitectureWare und GeneSEZ unterst&uuml;tzt werden.</para>

        </sect2>

      </sect1>

      <sect1>

        <title>Benutzer-Installation</title>

        <para>Mit Eclipse 3.4 wurde auch ein neuer Update-Manager 
        namens p2 eingef&uuml;hrt. Daher wird in den folgenden 
        Beschreibungen unterschieden zwischen dem Update-Manager, der 
        bis Eclipse 3.3 f&uuml;r Updates zust&auml;ndig war, und p2, der 
        standardm&auml;&szlig;ig ab Eclipse 3.4 als Update-Manager bereit steht. 
        Die Verwendung von p2 ist aber auch in Eclipse 3.4 nicht 
        zwingend, so dass auch unter Eclipse 3.4 der bisherige 
        Update-Manager genutzt werden kann.</para>

        <sect2>

          <title>Update Manager (standardm&auml;&szlig;ig bis Eclipse 3.3)</title>

          <para>Die einfachste M&ouml;glichkeit der Installation ist die 
          Nutzung des Eclipse Update Manager. Dazu Help » Software 
          Updates » Find and Install... anklicken. Danach Search for 
          new features to install ausw&auml;hlen und next klicken.</para>

          <para />

          <para>Nun m&uuml;ssen die oben gelisteten Update-URLs von GeneSEZ, 
          openArchitectureWare, EMF und UML2 hinzugef&uuml;gt werden, sofern 
          sie noch nicht existieren (Der Update-Manager verhindert aber 
          auch das doppelte Einf&uuml;gen der gleichen URL.). Dazu auf New 
          Remote Site... klicken, einen sinnvollen Namen eingeben (z.B. 
          den des Plug-Ins) sowie die Update-URL. Dann auf OK 
          klicken.</para>

          <para>Sind die vier URLs angelegt, diese (und um 
          Seiteneffekte zu verhindern, nur diese) ausw&auml;hlen und auf 
          Finish klicken.</para>

          <para>Wenn die Aufforderung erscheint, einen Mirror zu 
          w&auml;hlen, kann ein beliebiger Mirror gew&auml;hlt werden. Dies hat 
          in der Regel nur Auswirkungen auf die 
          Download-Geschwindigkeit. Dann werden die installierbaren 
          Features angezeigt. Hier muss auf die Versionen geachtet 
          werden. Ggf. muss das H&auml;kchen aus Show the latest version of 
          a feature only entfernt werden, um eine &auml;ltere Version zu 
          installieren.</para>

          <para>Nun m&uuml;ssen alle Features, die installiert werden 
          sollen, ausgew&auml;hlt werden. Am besten in folgender 
          Reihenfolge, um unn&ouml;tige Fehlermeldungen des Update-Managers 
          zu vermeiden, die darauf hinweisen, dass referenzierte 
          Plug-Ins noch nicht installiert sind:</para>

          <para />

          <para>* EMF Runtime + End-User Tools</para>

          <para>* UML2 End-User Features</para>

          <para>* openArchitectureWare Library feature</para>

          <para>* openArchitectureWare core Feature</para>

          <para>* openArchitectureWare core plugins Feature</para>

          <para>* openArchitectureWare UML2 Adapter Feature</para>

          <para>* GeneSEZ Framework</para>

          <para>Sind alle ben&ouml;tigten Features ausgew&auml;hlt, kann auf Next 
          geklickt werden. Dann m&uuml;ssen die Lizenzen best&auml;tigt werden, 
          in dem I accept the terms in the license agreements 
          angeklickt wird. Dann kann auf Next geklickt werden.</para>

          <para />

          <para>Nun kann ausgew&auml;hlt werden, in welches Verzeichnis die 
          Plug-Ins installiert werden sollen. Standardm&auml;&szlig;ig ist dies 
          das Verzeichnis von Eclipse. Soll dieses verwendet werden, 
          einfach auf Finish klicken. Alternativ kann hier auch eine 
          sogenannte Extension Location angelegt werden und f&uuml;r jedes 
          Plug-In individuell der Speicherort festgelegt werden. Soll 
          eine Extension Location verwendet werden, einfach alle 
          Plug-Ins in der Liste markieren (auch mit Strg+A m&ouml;glich) und 
          dann auf Change Location ... klicken. Im sich dann &ouml;ffnenden 
          Dialog auf Add Location... klicken und einen Ordner im 
          Dateisystem w&auml;hlen. Dann auf OK klicken. Nun kann diese 
          Extension Location ausgew&auml;hlt werden und mit OK best&auml;tigt 
          werden. Dann kann mit Finish die Installation gestartet 
          werden.</para>

          <para>Nun werden die Plug-Ins von den Webseiten geladen. Vor 
          der Installation fragt der Update-Manager noch nach einer 
          Feature Verification. Hier kann einfach Install All gew&auml;hlt 
          werden, um die Installation der nicht signierten Plug-Ins zu 
          best&auml;tigen. Zum Schluss muss noch mit Klick auf Yes der 
          Neustart von Eclipse best&auml;tigt werden.</para>

          <para />

          <para>Nach dem Neustart kann mit Klick auf Help » Software 
          Updates » Manage Configuration eine &uuml;bersicht der 
          installierten Plug-Ins angezeigt werden. Hier sollten die 
          soeben installierten Plug-Ins ohne Fehler aufgelistet 
          sein.</para>

        </sect2>

        <sect2>

          <title>p2 (ab Eclipse 3.4)</title>

          <para>Das User Interface des p2 innerhalb von Eclipse ist 
          &auml;hnlich dem &auml;lteren Update Manager. Daher wird momentan an 
          dieser Stelle noch auf die Anleitung f&uuml;r den &auml;lteren Update 
          Manager verwiesen: Update Manager, Eclipse 3.3</para>

          <para />

          <para>Ein wesentlicher Unterschied ist, dass bei p2 keine 
          Extension Locations mehr spezifiziert werden k&ouml;nnen, in 
          welche die Plug-Ins installiert werden sollen. Die Plug-Ins 
          werden automatisch im Eclipse-Verzeichnis bzw. im genutzten 
          Bundle-Pool-Verzeichnis installiert.</para>

        </sect2>

      </sect1>

      <sect1>

        <title>Entwickler-Installation</title>

        <para>Der Quellcode des GeneSEZ-Frameworkss steht im 
        GeneSEZ-Repository zum Auschecken bereit.</para>

        <sect2>

          <title>GeneSEZ-Repository</title>

          <para>Der Zugriff auf das GeneSEZ-Repository ist erl&auml;utert 
          unter: GeneSEZ Source Control Management</para>

        </sect2>

        <sect2>

          <title>GeneSEZ-Plug-In-Projekte</title>

          <para>Das GeneSEZ Framework besteht aus einem Set von 
          Eclipse-Projekten. Die folgenden Projekte sind f&uuml;r die 
          Benutzung des GeneSEZ-Frameworks auf Basis des Quellcodes 
          erforderlich:</para>

          <para />

          <para>* de.genesez.build » enth&auml;lt ANT-Build-Skripte, die von 
          den anderen Projekten referenziert werden</para>

          <para>* de.genesez.metamodel » enth&auml;lt das 
          GeneSEZ-Metamodel</para>

          <para>* de.genesez.platforms.common » enth&auml;lt 
          allgemeing&uuml;ltige Komponenten und Skripte, die von den anderen 
          Projekten genutzt werden</para>

          <para />

          <para>Weiterhin ist f&uuml;r die Benutzung des GeneSEZ-Frameworks 
          auf Basis des Quellcodes noch mindestens eines der folgenden 
          Plattformprojekte erforderlich, je nachdem f&uuml;r welche 
          Plattform Quellcode generiert werden soll:</para>

          <para />

          <para>* de.genesez.platforms.java » notwendig um 
          Java-Quellcode zu generieren</para>

          <para>* de.genesez.platforms.dotnet » notwendig um 
          C#-Quellcode zu generieren</para>

          <para>* de.genesez.platforms.php » notwendig um PHP-Quellcode 
          zu generieren</para>

          <para />

          <para>Die folgenden beiden Projekte sind notwendig, um die 
          Eclipse-Plugins f&uuml;r das GeneSEZ-Framework zu erstellen und 
          auf der Update-Seite zu publizieren:</para>

          <para />

          <para>* de.genesez.features</para>

          <para>* de.genesez.updatesite</para>

        </sect2>

        <sect2>

          <title>GeneSEZ-Setup</title>

          <para>Bevor das GeneSEZ-Framework genutzt werden kann, muss 
          noch eine Konfiguration erfolgen, die Plug-In-Projekte m&uuml;ssen 
          versioniert werden und die Implementierung des 
          GeneSEZ-Metamodells erstellt werden.</para>

          <para />

          <para>Um die Konfiguration zu erstellen, muss im Projekt 
          de.genesez.build im Ordner build die Datei 
          environment.properties angelegt werden. Hierzu kann die Datei 
          environment.properties.template als Vorlage genutzt werden, 
          welche sich bereits im selben Verzeichnis befindet.</para>

          <para />

          <para>Die GeneSEZ-Build-Skripte nutzen einen automatisierten 
          Mechanismus, um alle GeneSEZ-Projekte zu versionieren. Hierzu 
          ist in den zu versionierenden Dateien ein spezieller 
          Platzhalter vorhanden, der u.a. Eclipse daran hindert, 
          Plug-In-Referenzen aufzul&ouml;sen, weshalb die Projekte auch noch 
          ziemlich viele Fehler aufweisen sollten.</para>

          <para />

          <para>Um die Projekte zu versionieren, muss das Build-Target 
          tag.all des Build-Skripts build.xml, welches sich im 
          Root-Verzeichnis des Projekts de.genesez.build befindet, 
          ausgef&uuml;hrt werden. Sind nicht alle zu versionierenden 
          Projekte ausgecheckt, so sollten die Projekte, die nicht 
          ausgecheckt sind, vorher in der Datei release.properties, 
          welche sich im build-Order des Build-Projektes befindet, 
          auskommentiert werden.</para>

          <para>Nun kann die Generierung der Implementierung des 
          GeneSEZ-Metamodells erfolgen. Dazu muss einfach das 
          Build-Skript build.xml im build-Ordner des 
          Metamodell-Projektes de.genesez.metamodel ausgef&uuml;hrt werden. 
          Zum Ausf&uuml;hren den Men&uuml;punkt Run As » Ant Build... w&auml;hlen und 
          im Tab JRE den Punkt Run in same JRE as the workspace 
          w&auml;hlen.</para>

          <para />

          <para>Nachdem die Metamodell-Implementierung generiert wurde, 
          sollte sich das GeneSEZ-Framework genauso nutzen lassen, wie 
          wenn die Plug-Ins installiert worden w&auml;ren.</para>

        </sect2>

      </sect1>

    </chapter>

    <chapter>

      <title>GeneSEZ: Just Try It Out</title>

      <para>Dieser Artikel verdeutlicht die Funktionweise und Anwendung 
      des GeneSEZ-Frameworks an einem kleinen Beispiel. Dazu wird ein 
      Projekt aus dem GeneSEZ-Repository ausgecheckt, die 
      Projektstruktur erl&auml;utert und ein vorhandenes UML-Modell in 
      Quellcode transformiert.</para>

      <sect1>

        <title>Checkout Beispielprojekt</title>

        <para>Um das Beispielprojekt aus dem GeneSEZ-Repository 
        auszuchecken, muss zuerst die GeneSEZ-Repository Location 
        konfiguriert werden. Dies wird genauer unter GeneSEZ Source 
        Control Management beschrieben.</para>

        <para />

        <para>Anschlie&szlig;end kann das Beispielprojekt 
        de.genesez.example.java.forms sowie das zugeh&ouml;rige 
        Generatorprojekt de.genesez.example.java.forms.generator 
        ausgecheckt werden.</para>

      </sect1>

      <sect1>

        <title>Projektstruktur</title>

        <para>F&uuml;r ein Softwareprojekt wird eine Aufteilung in 
        mindestens zwei Projekte vorgeschlagen. Dies ist zum Einen ein 
        so genanntes Generatorprojekt, welches Konfigurationen, 
        Bibliotheken und weitere spezifische Artefakte f&uuml;r den 
        modellgetriebenen Entwicklungsprozess beinhaltet. Neben diesem 
        existiert mindestens noch ein weiteres Projekt welches den 
        anwendungsspezifischen Quellcode beinhaltet. Durch diese 
        Aufteilung sind in jedem Projekt nur die Artefakte enthalten, 
        die f&uuml;r das jeweilige Projekt relevant sind.</para>

        <sect2>

          <title>Generatorprojekt</title>

          <para>Das Generatorprojekt ist ein 
          openArchitectureWare-Projekt, welches wiederum ein 
          Eclipse-Plug-In-Projekt ist. Dadurch k&ouml;nnen die ben&ouml;tigten 
          Bibliotheken f&uuml;r den Generator einfach als Eclipse-Plug-Ins 
          referenziert werden. Neben den spezifischen Verzeichnissen 
          und Dateien von Eclipse-Plug-In-Projekten existieren die 
          folgenden Verzeichnisse:</para>

          <para />

          <para>* config</para>

          <para>* model-exp</para>

          <para>* model-gen</para>

          <para />

          <para>Das Verzeichnis config enth&auml;lt den Workflow, welcher 
          die einzelnen Schritte beschreibt, die notwendig sind, um ein 
          Modell in Quellcode zu transformieren. Weiterhin kann 
          optional noch die Datei log4j.properties enthalten sein, 
          welche das von GeneSEZ und openArchitectureWare genutzte 
          Logging-Framework Log4J konfiguriert.</para>

          <para />

          <para>Im Verzeichnis model-exp befindet sich das Modell der 
          Anwendung im XMI-Format des Eclipse UML2-Projektes. Im Falle 
          des Beispielprojektes wurde das Modell mit dem 
          Modellierungswerkzeug Magic Draw erstellt und als Eclipse 
          UML2-Modell exportiert. Daraus ergibt sich auch der Name des 
          Verzeichnisses model-exp, der f&uuml;r &quot;exportiertes 
          Modell&quot; steht. Dieses Modell dient als Ausgangspunkt der 
          Codegenerierung.</para>

          <para />

          <para>Der Ordner model-gen enth&auml;lt ein serialisiertes 
          GeneSEZ-Modell, welches durch den Workflow erzeugt wurde. 
          Sich dieses Modell einmal n&auml;her anzusehen, kann z.B. n&uuml;tzlich 
          sein, um zu &uuml;berpr&uuml;fen, ob Modellmodifikationen korrekt 
          funktionieren. Die XMI-Datei kann mit Hilfe des Sample 
          Reflective Ecore Model Editor ge&ouml;ffnet werden. Dieser stellt 
          das Modell in einer Baumstruktur dar, &auml;hnlich wie der UML 
          Model Editor f&uuml;r Eclipse UML2-Modelle.</para>

          <para />

          <para>Weiterhin k&ouml;nnen sich noch weitere Dateien und 
          Verzeichnisse wie z.B. projektspezifische 
          Type-Mapping-Dateien und Artefakte f&uuml;r die Anpassung des 
          Generators im Generator-Projekt befinden.</para>

        </sect2>

        <sect2>

          <title>Anwendungsprojekt</title>

          <para>Bei gr&ouml;&szlig;eren Projekten ist es sinnvoll, mehrere 
          Anwendungsprojekte zu erstellen (z.B. wenn neben einer 
          Desktopoberfl&auml;che eine Weboberfl&auml;che entwickelt wird). 
          Ansonsten ist ein Anwendungsprojekt in der Regel ausreichend. 
          Das Anwendungsprojekt kann ein Eclipse-Projekt der 
          entsprechenden Zielplattform sein: ein Java-Projekt, ein 
          PHP-Projekt oder ein Web-Projekt (je nachdem, welche 
          Eclipse-Nature am besten geeignet ist). Es kann sich aber 
          genauso gut um ein Projekt einer anderen Entwicklungsumgebung 
          handeln (z.B. ein Visual Studio-Projekt f&uuml;r die 
          C#-Entwicklung). F&uuml;r den modellgetriebenen 
          Entwicklungsprozess an sich ist lediglich ein Verzeichnis im 
          Dateisystem notwendig (siehe unten), jedoch sollte dies 
          sinnvoll in einer Projektstruktur eingegliedert sein.</para>

          <para />

          <para>Die Verzeichnisstruktur ist sehr vom verwendeten 
          Projekt abh&auml;ngig. Deshalb werden hier nur die wichtigsten 
          Verzeichnisse kurz vorgestellt. Im Falle des 
          Beispielprojektes handelt es sich um ein Java-Projekt, das 
          die folgenden Verzeichnisse enth&auml;lt:</para>

          <para />

          <para>* src</para>

          <para>* src-gen</para>

          <para>* lib</para>

          <para>* model</para>

          <para />

          <para>Die Verzeichnisse src und src-gen enhalten den 
          Quellcode des Projektes. Der generierte Quellcode befindet 
          sich dabei im Verzeichnis src-gen und der manuell erstellte 
          in src.</para>

          <para />

          <para>Im lib-Verzeichnis sind die Bibliotheken f&uuml;r das 
          Projekt enthalten. Im Beispielprojekt ist hier die Bibliothek 
          zum Assoziations-Handling enthalten.</para>

          <para />

          <para>Der model-Ordner enth&auml;lt das Modell, welches mit der 
          eingesetzten Modelliersoftware erstellt wurde. Dieses Modell 
          ist dem Anwendungsprojekt zugeordnet, da aus diesem Modell 
          Teile des Quellcodes automatisch erzeugt werden, wodurch das 
          Modell selbst zum Quellcode wird.</para>

        </sect2>

      </sect1>

      <sect1>

        <title>Ausf&uuml;hren des Workflows</title>

        <sect2>

          <title>Hinweis GeneSEZ Version 1.6.0</title>

          <para>Durch einen Bug im GeneSEZ-Plug-In m&uuml;ssen bei Version 
          1.6.0 im Beispiel-Generator-Projekt noch folgende 
          Plug-In-Abh&auml;ngigkeiten und -Bibliotheken hinzugef&uuml;gt 
          werden:</para>

          <para />

          <para>* openArchitectureWare UML2 Adapter</para>

          <para>* GeneSEZ Metamodell</para>

          <para>* dom4j Bibliothek</para>

          <para />

          <para>Dazu im Ordner META-INF die Datei MANIFEST.MF &ouml;ffnen 
          und im Tab Dependencies unter Required Plug-Ins die beiden 
          Plug-Ins de.genesez.metamodel und 
          org.openarchitectureware.uml2.adapter hinzuf&uuml;gen. Die 
          Bibliothek dom4j.jar wird &uuml;ber den Build Path hinzugef&uuml;gt: 
          Rechtsklick auf das Projekt und » Build Path » Configure 
          Build Path... w&auml;hlen und dann im Tab Libraries auf Add 
          External JARs... klicken. Nun kann die Datei dom4j-1.6.1.jar 
          aus dem GeneSEZ-Plug-In-Verzeichnis gew&auml;hlt werden (z.B. 
          ...\eclipse-extensions\genesez\eclipse\plugins\de.genesez.platforms.common_1.6.0).</para>

          <para>Um den Workflow zu starten, einfach Rechtsklick auf die 
          Datei workflow.oaw im Verzeichnis config und Run As » oAW 
          Workflow w&auml;hlen. In der Konsole sollte bei erfolgreicher 
          Ausf&uuml;hrung in den letzten Zeilen die folgende Ausgabe 
          erscheinen:</para>

          <mediaobject><imageobject>
          <imagedata fileref="images/workflow.finish.png"/></imageobject></mediaobject>
          <para>Im Verzeichnis src-gen des Anwendungsprojektes sollte 
          nun der aktuelle generierte Quellcode vorhanden sein.</para>

        </sect2>

      </sect1>

      <sect1>

        <title>Workflow Details</title>

        <para>Der Workflow kann mit einem Doppelklick ge&ouml;ffnet werden. 
        Die Definition des Workflows ist &auml;hnlich der von 
        ANT-Build-Skripten. In der ersten H&auml;lfte sind Properties 
        definiert. Dies sind projektspezifische Einstellungen wie Pfad 
        und Dateiname des Modells sowie Standardwerte f&uuml;r die Workflow 
        Komponenten. In der zweiten H&auml;lfte des Workflows sind die 
        Workflowkomponenten definiert, die die Transformationsschritte 
        vom Modell bis zum Quellcode definieren:</para>

        <para />

        <para>1. Die erste Workflowkomponente liest ein UML2-Modell 
        ein, validiert es und transformiert es in ein 
        GeneSEZ-Modell</para>

        <para>2. Danach wird das GeneSEZ-Modell mit allgemeinen Regeln 
        auf Korrektheit &uuml;berpr&uuml;ft</para>

        <para>3. Als drittes wird das GeneSEZ-Modell auf 
        Java-Konformit&auml;t &uuml;berpr&uuml;ft</para>

        <para>4. Die vierte Workflowkomponente serialisiert das 
        GeneSEZ-Modell in eine Datei</para>

        <para>5. Als letztes wird das GeneSEZ-Modell mit Hilfe der 
        Java-Templates in Java-Quellcode transformiert</para>

        <para />

        <para>Die Parameter der einzelnen Workflow Komponenten sind in 
        der Workflow-Referenz erkl&auml;rt: GeneSEZ Workflow Referenz.</para>

      </sect1>

      <sect1>

        <title>Generierter Quellcode</title>

        <para>Wesentlich f&uuml;r die Akzeptanz der MDSD ist, dass der 
        generierte Quellcode den Coding-Guidelines der Entwickler 
        entspricht. Um dies zu erreichen, stehen mehrere M&ouml;glichkeiten 
        bereit.</para>

        <para />

        <para>Die Workflowkomponente zur Durchf&uuml;hrung einer 
        Modell-zu-Text-Transformation stellt Parameter bereit, um das 
        Aussehen des generierten Quellcodes zu beeinflussen. Dazu wird 
        hier auf die Referenz dieser Workflowkomponente verwiesen: 
        GeneSEZ Modell-zu-Text Workflow Komponente</para>

        <para />

        <para>Gr&ouml;&szlig;ere &auml;nderungen an der Struktur des Quellcodes k&ouml;nnen 
        mit Hilfe des Customization Guide erreicht werden: GeneSEZ 
        Customization Guide?</para>

        <para />

        <para>F&uuml;r Informationen, wie die GeneSEZ-Templates 
        Modellinformationen in Quellcode umsetzen, wird auf die 
        GeneSEZ-Generator-Pattern verwiesen.</para>

      </sect1>

    </chapter>

  </part>

  <part>

    <title>Benutzer-Referenz</title>

    <chapter>

      <title>Workflow und Workflow Komponenten</title>

      <para>F&uuml;r den GeneSEZ Workflow stehen einzelne Komponenten zur 
      Verf&uuml;gung. Die core-Komponenten sind die Standard-Komponenten. 
      Die internal werden nur von anderen Workflow-Komponenten 
      verwendet und sollten nicht direkt genutzt werden. Weiterhin gibt 
      es mit java eine plattformspezifische Workflow-Komponente f&uuml;r die 
      Java-Plattform.</para>

      <para>Die Workflow-Komponenten sind in der Abbildung als Klassen 
      dargestellt und die Parameter der Workflow-Komponenten als 
      Attribute.</para>

      <sect1>

        <title>Standard-Komponenten</title>

        <sect2>

          <title>makeGenesezModel</title>

          <para>Erstellt aus einer EMF-UML2-Modell-Datei ein 
          instantiiertes GeneSEZ-Modell. Dabei werden die beiden 
          internen Komponenten xmiReader und uml2genesez genutzt.</para>

          <para />

          <para>inputModelFile</para>

          <para>eine EMF-UML2-Modell-Datei</para>

          <para>genesezModel</para>

          <para>Name des Slots, auf dem das GeneSEZ-Modell gespeichert 
          wird</para>

          <para>excludePackages</para>

          <para>Mit Komma getrennte Liste von Package-Namen, welche 
          nicht mit transformiert werden sollen</para>

          <para>mapClassesInModelToExternal</para>

          <para>boolscher Wert, der angibt, ob Klassen, die direkt im 
          Modell liegen (d.h. auf der obersten Stufe im Modell liegen 
          und nicht in Packages eingeordnet sind), zu externen Typen 
          transformiert werden</para>

          <para>externalPackages</para>

          <para>Liste von Package-Namen, welche als Container f&uuml;r 
          externe Typen dienen (Komma getrennt)</para>

          <para>externalStereotypes</para>

          <para>Liste von Stereotypen, welche zur Markierung von 
          externen Typen verwendet werden (Komma getrennt)</para>

        </sect2>

        <sect2>

          <title>makeGenesezModelProfile</title>

          <para>Wie die Komponente makeGenesezModel, jedoch wird ein 
          UML-Profil als zus&auml;tzliches Metamodell registriert, welches 
          in der Transformation genutzt werden kann.</para>

          <para />

          <para>uml2ProfileFile</para>

          <para>Name eines EMF-UML2-Profils, das als Metamodell f&uuml;r die 
          Transformation genutzt wird</para>

          <para />

          <para>Die anderen Parameter sind identisch mit der Komponente 
          makeGenesezModel.</para>

        </sect2>

        <sect2>

          <title>performM2T</title>

          <para>F&uuml;hrt eine Modell-zu-Text Transformation durch.</para>

          <para />

          <para>rootTemplate</para>

          <para>Aufruf eines Define-Blocks eines Templates, welches die 
          Transformation startet/durchf&uuml;hrt</para>

          <para>outputDir</para>

          <para>Das Verzeichnis, in dem die generierten Dateien 
          gespeichert werden</para>

          <para>proRegDir</para>

          <para>Das Verzeichnis, welches nach Protected Regions 
          durchsucht wird (normalerweise das gleiche wie das 
          outputDir)</para>

          <para>aspectTemplates</para>

          <para>Liste von XPand-Templates mit Aspekt-Advices f&uuml;r das 
          XPand AOP</para>

          <para>aspectScripts</para>

          <para>Liste von XTend-Skripten mit Aspekt-Advices f&uuml;r XTend 
          AOP</para>

          <para>typeMappingFile</para>

          <para>Name der zu verwendenden Type-Mapping-Datei</para>

          <para>excludePackages</para>

          <para>Liste von (voll qualifizierten) Package-Namen, die von 
          der Modell-zu-Text Transformation ausgeschlossen werden 
          sollen</para>

          <para>useModelNameAsBasePackage</para>

          <para>boolscher Wert, der angibt, ob der Name des Modells als 
          Bezeichnung f&uuml;r das base package verwendet werden soll. Der 
          Standardwert ist false.</para>

          <para>basePackage</para>

          <para>String, der den Namen des zu verwendenden base packages 
          angibt</para>

          <para>generateSectionComments</para>

          <para>boolscher Wert, der angibt, ob verschiedene Abschnitte 
          in den generierten Artefakten mit einem einleitenden 
          Kommentar versehen werden sollen. Der Standardwert ist 
          true.</para>

          <para>disableAccessors</para>

          <para>boolscher Wert, der angibt, ob die (standardm&auml;&szlig;ige) 
          Generierung von Zugriffsfunktionen (z.B. Get- und 
          Set-Methoden in Java) f&uuml;r Attribute unterdr&uuml;ckt werden soll. 
          Der Standardwert ist false.</para>

          <para>useAccessorStereotype</para>

          <para>boolscher Wert, der angibt, ob der Stereotyp «accessor» 
          ausgewertet werden soll. Der Standardwert ist false.</para>

          <para>usePropertyVisibilityForAccessors</para>

          <para>boolscher Wert, der angibt, dass Properties immer die 
          Sichtbarkeit private erhalten und die Sichtbarkeit der 
          Property f&uuml;r die Zugriffsfunktionen (Accessors) verwendet 
          werden soll (wenn auf true gesetzt) bzw. dass Properties ihre 
          Sichtbarkeit behalten und die Zugriffsfunktionen immer die 
          Sichtbarkeit public erhalten (wenn auf false gesetzt). Der 
          Standardwert ist false.</para>

          <para>configFile</para>

          <para>Name einer Konfigurationsdatei. Wird aktuell nicht 
          verwendet.</para>

        </sect2>

        <sect2>

          <title>performM2M</title>

          <para>F&uuml;hrt eine Modell-zu-Modell-Transformation durch.</para>

          <para />

          <para>invokeScript</para>

          <para>Aufruf einer Funktion eines XTend-Skriptes, welches die 
          Transformation durchf&uuml;hrt</para>

          <para>outputModelSlot</para>

          <para>Name des Slots, auf dem das neu erstellte Modell 
          gespeichert wird</para>

          <para>configFile</para>

          <para>Name einer Konfigurationsdatei. Wird aktuell nicht 
          verwendet</para>

        </sect2>

        <sect2>

          <title>performMM</title>

          <para>F&uuml;hrt eine Modell-Modifikation durch. Dabei wird ein 
          Modell mit Hilfe eines XTend-Skriptes ge&auml;ndert.</para>

          <para />

          <para>invokeScript</para>

          <para>Aufruf einer Funktion eines XTend-Skriptes, welches die 
          Modifikation durchf&uuml;hrt</para>

          <para>configFile</para>

          <para>Name einer Konfigurationsdatei. Wird aktuell nicht 
          verwendet.</para>

        </sect2>

        <sect2>

          <title>constraintChecker</title>

          <para>Validiert ein instantiiertes Modell mit einer 
          openArchitectureWare-check-Datei.</para>

          <para />

          <para>modelSlot</para>

          <para>Name des Slots, auf dem das Modell gespeichert ist, das 
          validiert werden soll</para>

          <para>checkScript</para>

          <para>eine check-Datei, welche die Regeln zur &uuml;berpr&uuml;fung 
          enth&auml;lt</para>

          <para>abortOnError</para>

          <para>boolscher Wert, der angibt, ob der Workflow abgebrochen 
          werden soll, wenn Fehler im Modell gefunden werden</para>

        </sect2>

        <sect2>

          <title>xmiWriter</title>

          <para>Serialisiert ein instantiiertes Modell in eine 
          Datei.</para>

          <para />

          <para>modelSlot</para>

          <para>Name des Slots, auf dem das Modell gespeichert ist, das 
          serialisiert werden soll</para>

          <para>outputModelFile</para>

          <para>Name der Datei, die dann das serialisierte Modell 
          enth&auml;lt</para>

        </sect2>

        <sect2>

          <title>directoryCleaner</title>

          <para>L&ouml;scht den Inhalt von Verzeichnissen.</para>

          <para />

          <para>cleaningDirs</para>

          <para>Liste mit Verzeichnisnamen</para>

        </sect2>

      </sect1>

      <sect1>

        <title>Java spezifische Komponenten</title>

        <sect2>

          <title>performM2T</title>

          <para>F&uuml;hrt eine Modell-zu-Text-Transformation f&uuml;r die 
          Java-Plattform durch. Generierte Artefakte werden vom 
          Eclipse-Java-Beautifier sowie von einem XML-Beautifier 
          formatiert.</para>

          <para />

          <para>Die Parameter sind die gleichen wie bei der Komponente 
          performM2T</para>

        </sect2>

      </sect1>

      <sect1>

        <title>Interne Komponenten</title>

        <sect2>

          <title>xmiReader</title>

          <para>Liest die mit inputModelFile angegebene (z.B. von Magic 
          Draw exportierte) EMF-UML2-XMI-Datei ein, instantiiert das 
          UML2-Model und stellt das UML2-Modell auf den Slot bereit, 
          der mit dem Parameter modelSlot angegeben wurde. Slots sind 
          eine Art globale Variable, die von jeder Workflow-Komponente 
          genutzt werden k&ouml;nnen.</para>

          <para />

          <para>inputModelFile</para>

          <para>siehe Komponente makeGenesezModel</para>

          <para>modelSlot</para>

          <para>Name des Slots, auf dem das instantiierte Modell 
          gespeichert wird</para>

        </sect2>

        <sect2>

          <title>uml2genesez</title>

          <para>Transformiert ein (instantiiertes) UML2-Modell in ein 
          GeneSEZ-Model.</para>

          <para />

          <para>uml2Model</para>

          <para>Name des Slots, auf dem das UML2 Modell gespeichert 
          ist</para>

          <para>genesezModel</para>

          <para>siehe Komponente makeGenesezModel</para>

          <para>excludePackages</para>

          <para>siehe Komponente makeGenesezModel</para>

          <para>mapClassesInModelToExternal</para>

          <para>siehe Komponente makeGenesezModel</para>

          <para>externalPackages</para>

          <para>siehe Komponente makeGenesezModel</para>

          <para>externalStereotypes</para>

          <para>siehe Komponente makeGenesezModel</para>

        </sect2>

        <sect2>

          <title>uml2genesezProfile</title>

          <para>Transformiert ein (instantiiertes) UML2-Modell in ein 
          GeneSEZ-Model mit Angabe eines UML-Profils, das zus&auml;tzlich 
          als Metamodell registriert wird.</para>

          <para />

          <para>uml2ProfileFile</para>

          <para>siehe Komponente makeGenesezModelProfile</para>

          <para />

          <para>Die anderen Parameter sind identisch mit der Komponente 
          uml2genesez.</para>

        </sect2>

      </sect1>

    </chapter>

	<!-- xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="type.mapping.xml" / -->
<chapter>

  <title>Type Mapping</title>

  <para>Die Type-Mapping-Komponente dient dazu, im Modell verwendete 
  Typen auf Typen in einer Programmiersprache abzubilden. Die Abbildung 
  <xref linkend="genesez.type.system"/> zeigt eine &Uuml;bersicht der 
  m&ouml;glichen Typen:</para>

  <figure id="genesez.type.system">

    <title xreflabel="GeneSEZ Typ-System">Das GeneSEZ Typ-System</title>

    <mediaobject><imageobject><imagedata align="center"
     fileref="genesez.meta.model.type.system.png" scalefit="1"
     width="172mm"/></imageobject><textobject><para>Das GeneSEZ 
    Typ-System besteht aus den folgenden Typen: Class, Interface, 
    DataType, Enumeration, Generic, Primitive und 
    External.</para></textobject></mediaobject>
  </figure>

  <para><literal>MClassifier</literal> bezeichnet selbst erstellte 
  Typen im Modell. <literal>MGeneric</literal> stellt einen generischen 
  Typ dar und wird verwendet, um eine Klasse mit einem oder mehreren 
  Typen zu parametrisieren. <literal>MPrimitiveType</literal> stellt 
  die primitiven Typen der jeweiligen Programmiersprache dar. Dabei 
  handelt es sich meist um Hardware-nahe Typen, die in der Regel ohne 
  include- oder import-Anweisung verwendbar sind. <literal>
  MExternal</literal> stellt die Typen einer Programmiersprache dar, 
  die durch Standardbibliotheken oder andere verwendete externe 
  Bibliotheken verf&uuml;gbar gemacht werden.</para>

  <section>

    <title>Konzept des Type-Mapping</title>

    <para>Das Type-Mapping realisiert zwei verschiedene Aufgaben. Zum 
    einen werden mit einem <emphasis>Namens-Mapping</emphasis> die 
    Namen der Typen im Modell auf die zu verwendenden Namen in der 
    jeweiligen Zielsprache abgebildet. Bei <literal>
    MClassifier</literal> und <literal>MGeneric</literal> wird beim 
    Aufruf der Funktion <computeroutput>mapName()</computeroutput> kein 
    Namens-Mapping durchgef&uuml;hrt, da es sich ja um selbst modellierte 
    Typen handelt, deren Namen nicht abgebildet werden m&uuml;ssen. Hier 
    wird der <computeroutput>name</computeroutput> bzw. die 
    <computeroutput>specification</computeroutput> zur&uuml;ck 
    gegeben.</para>

    <para>Die zweite Aufgabe ist ein <emphasis>Typ-Mapping</emphasis>, 
    welches die Typ-Modifikatoren auswertet und gegebenenfalls den im 
    Modell verwendeten Typ ersetzt. Typ-Modifikatoren werden im Modell 
    nicht am Typ selbst festgelegt, sondern bei dem Modellelement, 
    welches den Typ aufweist (also z.B. bei einem Attribut). Die 
    Funktion <computeroutput>mapType()</computeroutput> realisiert das 
    Typ-Mapping. Folgende Typ-Modifikatoren werden ausgewertet:</para>

    <variablelist>

      <varlistentry>

        <term>multiplicity</term>

        <listitem>

          <para>Anzahl der zu speichernden Objekte eines Typs (d.h. ob 
          der Typ an sich ausreicht oder eine Collection oder ein Array 
          des Typs verwendet werden muss)</para>

        </listitem>

      </varlistentry>

      <varlistentry>

        <term>unique</term>

        <listitem>

          <para>gibt an, ob ein Objekt mehrmals vorkommen kann, wenn 
          die <literal>multiplicity</literal> gr&ouml;&szlig;er als 1 ist</para>

        </listitem>

      </varlistentry>

      <varlistentry>

        <term>ordered</term>

        <listitem>

          <para>gibt an, ob die Objekte geordnet abgelegt werden</para>

        </listitem>

      </varlistentry>

    </variablelist>

    <para>Die Typ-Modifikatoren <literal>unique</literal> und <literal>
    ordered</literal> beziehen sich auf 
    <emphasis>multi-value</emphasis> Typen, d.h. Typen, deren <literal>
    multiplicity</literal> gr&ouml;&szlig;er als 1 ist.</para>

    <para>Die Abbildungsvorschriften f&uuml;r das 
    <emphasis>Namens</emphasis>- und <emphasis>Typ</emphasis>-Mapping 
    werden in einer XML-Datei festgelegt.</para>

    <para>Weiterhin sind f&uuml;r die Auswahl des passenden Typs oft die im 
    Quellcode angestrebte Verwendung bzw. die vorliegenden 
    Rahmenbedingungen wesentlich. Hierzu k&ouml;nnen 
    <emphasis>Kontexte</emphasis> definiert werden, die ein spezielles 
    Mapping f&uuml;r eine bestimmte Situation/Verwendung darstellen.</para>

  </section>

  <section>

    <title>Aufbau einer Type-Mapping Datei</title>

    <para>Eine Type-Mapping Datei besteht aus 4 Abschnitten:</para>

    <variablelist>

      <varlistentry>

        <term>include</term>

        <listitem>

          <para>Angabe einer oder mehrerer Type-Mapping Dateien die 
          eingebunden bzw. erweitert werden soll</para>

        </listitem>

      </varlistentry>

      <varlistentry>

        <term>multiValuedTypes</term>

        <listitem>

          <para>Angabe wie Type-Modifikatoren behandelt werden</para>

        </listitem>

      </varlistentry>

      <varlistentry>

        <term>primitiveTypes</term>

        <listitem>

          <para>Angabe wie primitive Typen gemappt werden</para>

        </listitem>

      </varlistentry>

      <varlistentry>

        <term>externalTypes</term>

        <listitem>

          <para>Abbildung von externen Typen</para>

        </listitem>

      </varlistentry>

    </variablelist>

    <para>Das folgende Listing zeigt den schematischen Aufbau der 
    Type-Mapping Datei.</para>

    <programlisting>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; 
&lt;tns:typeMapping xmlns:tns=&quot;http://www.genesez.de/typemapping&quot; 
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt; 
    &lt;tns:include&gt; 
        &lt;tns:file&gt;
            de/genesez/platforms/common/typemapping/typemapping.xml
        &lt;/tns:file&gt; 
    &lt;/tns:include&gt; 
    &lt;tns:multiValuedTypes&gt; ... &lt;/tns:multiValuedTypes&gt; 
    &lt;tns:primitiveTypes&gt; ... &lt;/tns:primitiveTypes&gt; 
    &lt;tns:externalTypes&gt; ... &lt;/tns:externalTypes&gt; 
&lt;/tns:typeMapping&gt;</programlisting>
    <para>F&uuml;r die Type-Mapping Dateien gibt es ein 
    <ulink url="https://server.genesez.de/trac/browser/trunk/de.genesez.platforms.common/common/de/genesez/platforms/common/typemapping/typemapping.xsd">
    XML Schema</ulink> welches zur Validierung genutzt wird. Das Schema 
    wird immer automatisch aus dem Classpath (Ressource: <literal>
    de/genesez/platforms/common/typemapping/typemapping.xsd</literal>) 
    geladen und muss nicht explizit in der XML Datei per <literal>
    schemaLocation</literal> angegeben werden!</para>

    <section>

      <title>Includes</title>

      <para>Angabe einer oder mehrerer Type-Mapping Dateien mit einem 
      Identifier der genutzt wird um die referenzierten Type-Mapping 
      Dateien aus dem Classpath zu laden. Alle in dieser Datei 
      definierten Mappings werden eingebunden.</para>

      <programlisting>&lt;tns:include&gt; 
    &lt;tns:file&gt;
        de/genesez/platforms/common/typemapping/typemapping.xml
    &lt;/tns:file&gt; 
&lt;/tns:include&gt;</programlisting>
    </section>

    <section>

      <title>Multi-Value Types</title>

      <para>In diesem Abschnitt wird definiert, wie Typen unter 
      Ber&uuml;cksichtigung der Typ-Modifikatoren abgebildet werden. Dazu 
      stehen die beiden <emphasis>optionalen</emphasis> Attribute 
      <literal>unique</literal> und <literal>ordered</literal> 
      bereit.</para>

      <programlisting>&lt;tns:multiValuedType ordered=&quot;true&quot; unique=&quot;true&quot;&gt; 
    &lt;tns:default&gt;java.util.Set&lt;/tns:default&gt; 
&lt;/tns:multiValuedType&gt;</programlisting>
      <para>Die beiden Attribute sind optional da in der UML 
      Standardwerte festgelegt sind: <literal>unique == true</literal> 
      und <literal>ordered == false</literal>. Eine andere M&ouml;glichkeit 
      der Angabe f&uuml;r das obige Mapping unter Nutzung der Standardwerte 
      ist die folgende:</para>

      <programlisting>&lt;tns:multiValuedType ordered=&quot;true&quot;&gt; 
    &lt;tns:default&gt;java.util.Set&lt;/tns:default&gt; 
&lt;/tns:multiValuedType&gt;</programlisting>
      <para>F&uuml;r den Typ-Modifikator <literal>unique</literal> ist kein 
      Wert angegeben wodurch der Standartwert aus der UML genutzt wird. 
      Da dieser <literal>true</literal> ist entsteht ein identisches 
      Mapping wie bei der Angabe beider Modifikatoren.</para>

    </section>

    <section>

      <title>Primitive Types und External Types</title>

      <para>Um Mappings f&uuml;r primitive und externe Typen zu erstellen 
      wird die gleiche Syntax genutzt:</para>

      <programlisting>&lt;tns:type from=&quot;boolean&quot;&gt; 
    &lt;tns:to&gt; boolean &lt;/tns:to&gt; 
&lt;/tns:type&gt;</programlisting>
      <para>Das Element <literal>type</literal> steht f&uuml;r eine 
      Type-Mapping Definition. Mit dem <literal>from</literal> Attribut 
      wird der im Modell verwendete Name des abzubildenden Typs 
      angegeben. Mit dem Element <literal>to</literal> wird der Name 
      des Typs in der Zielsprache angegeben auf den der Typ abgebildet 
      wird. Im Beispiel oben wird der im UML-Metamodell enthaltene 
      primitive Typ <literal>Boolean</literal> auf den Typ <literal>
      boolean</literal> der Zielprogrammiersprache abgebildet.</para>

    </section>

    <section>

      <title>Kontexte</title>

      <para>Kontexte werden genutzt um die verschiedenen 
      Verwendungsm&ouml;glichkeiten von Typen in der Zielsprache zu 
      adressieren. Es k&ouml;nnen beliebig viele Kontext-Mappings f&uuml;r einen 
      Typ angegeben werden. Jedes Kontext-Mapping stellt einen 
      bestimmten Bereich bzw. Situation dar, in welcher ein Typ im 
      Xpand-Template gemappt wird. Diese Kontexte werden also nicht im 
      Modell angegeben, sondern bei dem Aufruf des Type-Mappings im 
      Xpand-Template.</para>

      <para>Zur Verringerung der Kopplung in Quellcode werden z.B. 
      Attributen mit dem Interface-Typ definiert und nur in deren 
      Initialisierung die gew&uuml;nschte konkrete Implementierung 
      verwendet. Um solche Probleme zu Adressieren k&ouml;nnen die 
      Standardmappings mit Kontext-bezogenen Mappings erweitert 
      werden.</para>

      <section>

        <title>Kontexte und Multi-Value Typen</title>

        <para>Das folgende Beispiel zeigt ein 
        <emphasis>Multi-Value</emphasis> Type-Mapping, das zwischen 
        Interface-Typ und konkreter Implementierung 
        unterscheidet:</para>

        <programlisting>&lt;tns:multiValuedType ordered=&quot;true&quot;&gt; 
    &lt;tns:default&gt; java.util.Set &lt;/tns:default&gt; 
    &lt;tns:context name=&quot;Implementation&quot;&gt;
        java.util.LinkedHashSet
    &lt;/tns:context&gt; 
&lt;/tns:multiValuedType&gt;</programlisting>
        <para>In der Programmiersprache Java k&ouml;nnte das obige Mapping 
        in folgendem Quellcode resultieren:</para>

        <programlisting>java.util.Set&lt;String&gt; strings = new java.util.LinkedHashSet&lt;String&gt;();</programlisting>
        <para>F&uuml;r den Typ der Variablen wird der Standardtyp 
        (Interface-Typ) genutzt. Nur bei der Initialisierung der 
        Variablen wird die konkrete Implementierung verwendet. Dies 
        resultiert in einer geringeren Kopplung zu genutzten 
        Implementierung.</para>

      </section>

      <section>

        <title>Kontexte und Primitive Typen</title>

        <para>Kontexte k&ouml;nnen dar&uuml;ber hinaus auch in 
        <emphasis>Primitive Type</emphasis> und External Type Mappings 
        verwendet werden. Ein Kontext kann bei Java z.B. dazu genutzt 
        werden um die Primitiven Typen auf ihre Wrapper-Typen in Java 
        abzubilden:</para>

        <programlisting>&lt;tns:type from=&quot;boolean&quot;&gt; 
    &lt;tns:to&gt;boolean&lt;/tns:to&gt; 
    &lt;tns:context name=&quot;Wrapper&quot;&gt;Boolean&lt;/tns:context&gt; 
&lt;/tns:type&gt;</programlisting>
        <para>Dadurch ist es m&ouml;glich bei einer speziellen Verwendung 
        des Typs <literal>Boolean</literal> auf den Wrapper Typ 
        <literal>Boolean</literal> zu mappen anstatt auf den Primitiven 
        Typ <literal>boolean</literal>. Notwendig ist dies z.B. bei 
        Multi-Value Typen:</para>

        <programlisting>java.util.Set&lt;Boolean&gt; bs = new java.util.LinkedHashSet&lt;Boolean&gt;();</programlisting>
        <para>Der Primitive Typ <literal>boolean</literal> kann in Java 
        nicht als generischer Parameter verwendet werden. Deshalb muss 
        sein Wrapper Typ genutzt werden.</para>

      </section>

      <section>

        <title>Kontexte und Externe Typen</title>

        <para>F&uuml;r <emphasis>External Type</emphasis> Mappings sind 
        Kontexte u.a. in Bezug auf die Generierung von 
        <emphasis>import</emphasis> bzw. <emphasis>include</emphasis> 
        Statements sinnvoll:</para>

        <programlisting>&lt;!-- container is the base class for custom authentication providers
     from the &apos;PEAR::Auth&apos; package --&gt; 
&lt;tns:type from=&quot;Auth_Container&quot;&gt; 
    &lt;!-- default mapping is to the class name --&gt; 
    &lt;tns:to&gt;Auth_Container&lt;/tns:to&gt; 
    &lt;!-- used to generate imports --&gt; 
    &lt;tns:context name=&quot;import&quot;&gt;Auth/Container.php&lt;/tns:context&gt; 
&lt;/tns:type&gt;</programlisting>
        <para>Standardm&auml;&szlig;ig wird der Typ in dem Beispiel auf den 
        Klassennamen abgebildet. Wird jedoch der Kontext <literal>
        import</literal> angegeben, wird der ben&ouml;tigte Teil f&uuml;r die PHP 
        <emphasis>include</emphasis> Anweisung zur&uuml;ckgegeben.</para>

      </section>

    </section>

  </section>

  <section>

    <title>Verwendung des Type-Mappings</title>

    <para>Das Type-Mapping kann in Xpand-Templates einfach durch das 
    Einbinden des Type-Mapping Xtend-Skriptes genutzt werden:</para>

    <programlisting>«REM» use the type mapping «ENDREM» 
«EXTENSION de::genesez::common::typemapping::TypeMapping»</programlisting>
    <para>Das Xtend-Skript stellt prinzipiell zwei verschiedene 
    Funktionen bereit, bei denen jeweils optional noch ein 
    Kontext-Parameter angegeben werden kann:</para>

    <variablelist>

      <varlistentry>

        <term><computeroutput>mapName()</computeroutput></term>

        <listitem>

          <para>bildet den als Parameter &uuml;bergebenen Typ auf den Namen 
          des Typs in der Zielsprache ab</para>

        </listitem>

      </varlistentry>

      <varlistentry>

        <term><computeroutput>mapType()</computeroutput></term>

        <listitem>

          <para>wertet die Typ-Modifikatoren (des Metamodellelementes) 
          aus und gibt die entsprechenden Multi-Value-Typen 
          zur&uuml;ck</para>

        </listitem>

      </varlistentry>

    </variablelist>

    <para>Als Beispiel hier die Deklaration von Attributen in 
    Java:</para>

    <programlisting>«IF isSingleValuedType() -» 
    «EXPAND _Modifier -» «type.mapName().asTypeName()» \
    «EXPAND Type::Generics» «asAttribute()» «EXPAND _DefaultValue»; 
«ELSE -» 
    «EXPAND _Modifier -» «mapType() -» \
        &lt;«type.mapName().asTypeName()»&gt; \
        «asAttribute()» = new «mapType(&quot;Implementation&quot;)» \
        &lt;«type.mapName().asTypeName() -»&gt;(); 
«ENDIF -»</programlisting>
    <para>Bei einem normalen, <emphasis>single-value</emphasis> Typen (
    <literal>multiplicity == 1</literal>) wird lediglich der verwendete 
    Typ auf den zu verwendenden Namen in der Zielsprache gemappt. Ist 
    der &uuml;bergebene Typ ein <literal>MClassifier</literal> oder ein 
    <literal>MGeneric</literal>, so wird das eigentliche Type-Mapping 
    nicht durchgef&uuml;hrt sondern lediglich der &uuml;bergebene Typ unver&auml;ndert 
    wieder zur&uuml;ckgegeben. Bei <literal>MExternal</literal> und <literal>
    MPrimitiveType</literal> werden die Informationen aus der 
    Type-Mapping-Datei ausgewertet und der Typ als 
    <emphasis>String</emphasis> zur&uuml;ckgegeben. Der Aufruf von 
    <computeroutput>asTypeName()</computeroutput> wird zur Anwendung 
    der <emphasis>Naming Conventions</emphasis> durchgef&uuml;hrt.</para>

    <para>Bei <emphasis>multi-value</emphasis> Typen ( <literal>
    multiplicity &gt; 1</literal>) wird zuerst der Typ gemappt. Im 
    obigen Beispiel wird dazu als Parameter ein <literal>
    MAttribute</literal> &uuml;bergeben. Das Type-Mapping wertet dann die 
    Typ-Modifikatoren <literal>unique</literal> und <literal>
    ordered</literal> aus und gibt den entsprechenden Multi-Value-Typ 
    zur&uuml;ck. Der eigentlich verwendete Typ im Modell wird auf den Namen 
    in der Zielsprache gemappt und als Typ-Parameter der Collection 
    angegeben.</para>

  </section>

  <section>

    <title>Zusammenhang Type-Mapping + Naming Conventions</title>

    <para>Wie bereits im letzten Abschnitt aufgezeigt wird nur das 
    Type-Mapping aufgerufen, welches dann selbst anhand des &uuml;bergebenen 
    Typs entscheidet, ob die Informationen der Type-Mapping-Datei 
    ausgewertet werden m&uuml;ssen oder nicht. Im Folgenden nun ein Beispiel 
    zur Generalisierung:</para>

    <programlisting>extends «generalization.first().mapName().asTypeName() -»</programlisting>
    <para>Hier wird nach dem Schl&uuml;sselwort <literal>extends</literal> 
    die (erste) Basisklasse generiert. Diese Basisklasse kann vom Typ 
    <literal>MClass</literal> oder auch vom Typ <literal>
    MExternal</literal> sein. Ist die Basisklasse vom Typ <literal>
    MClass</literal> ist es eine modellierte Klasse (des 
    Domain-Modells) und muss daher den <emphasis>Naming 
    Conventions</emphasis> unterworfen werden. Ist es ein <literal>
    MExternal</literal>, muss lediglich das Type-Mapping durchgef&uuml;hrt 
    werden.</para>

    <para>Um die Xpand-Templates nicht unn&ouml;tig mit dem Test, um welchen 
    Meta-Typ es sich handelt, zu verkomplizieren, wurden die Funktionen 
    f&uuml;r die Namensgebung so definiert, dass sie diese Aufgabe 
    erledigen. Die Funktion <computeroutput>mapName()</computeroutput> 
    liefert bei Typen, bei denen kein Type-Mapping durchgef&uuml;hrt werden 
    muss, den Typ unver&auml;ndert wieder zur&uuml;ck (z.B. <literal>
    MClassifier</literal>, <literal>MGeneric</literal>). Wird bei 
    <literal>MPrimitiveType</literal> oder <literal>MExternal</literal> 
    ein Type-Mapping durchgef&uuml;hrt, liefert die Funktion einen 
    <emphasis>String</emphasis> zur&uuml;ck.</para>

    <para>Die Funktion <computeroutput>asTypeName()</computeroutput> 
    f&uuml;r die Namensgebung erkennt am &uuml;bergebenen Parameter (Typ oder 
    String), ob das Type-Mapping durchgef&uuml;hrt wurde oder nicht. Wird 
    ein String &uuml;bergeben, wird dieser unver&auml;ndert zur&uuml;ckgegeben, da das 
    Type-Mapping den Typ bereits ermittelt hat. Wird ein Typ &uuml;bergeben, 
    werden die <emphasis>Naming Conventions</emphasis> angewandt und 
    ein String zur&uuml;ckgegeben.</para>

    <para>Somit werden auf elegante Weise beide Aspekte 
    behandelt.</para>

  </section>

</chapter>

    <chapter>

      <title>Externe Typen im Metamodell</title>

      <para>Mit dem Metamodellelement MExternal ist ein Konzept im 
      GeneSEZ-Metamodell vorhanden, welches in dieser Form nicht zur 
      UML geh&ouml;rt. Als externe Typen werden in diesem Zusammenhang im 
      Modell verwendete Typen (Klassen, Interfaces, Enumerations) 
      bezeichnet, die selbst nicht im Modell vorhanden sind. Sie 
      befinden sich stattdessen z.B. in Standard-Bibliotheken der 
      Programmiersprache oder in anderen Bibliotheken, die verwendet 
      werden sollen.</para>

      <sect1>

        <title>Definition im UML-Modell</title>

        <para>Im zugrunde liegenden UML-Modell werden externe Typen als 
        Klassen (bzw. Interfaces oder Enumerations) definiert und 
        speziell gekennzeichnet. Dazu gibt es mehrere 
        M&ouml;glichkeiten:</para>

        <para />

        <para>* Verwendung eines Stereotypes</para>

        <para>* Verwendung eines separaten Packages</para>

        <para>* Ablage des Typs direkt im Modell (der Typ hat eine 
        Containment-Beziehung zum Modell-Element und befindet sich 
        nicht in einem Package)</para>

        <para />

        <para>Die verschiedenen M&ouml;glichkeiten haben spezifische Vor- 
        und Nachteile. Die Annotation der einzelnen Klassen mit einem 
        Stereotyp ist jedoch allgemein zu bevorzugen, da hier in den 
        Modellen und verschiedenen Diagrammen die Semantik einer 
        externen Klasse am deutlichsten zum Ausdruck kommt. Beispiele 
        dazu sind weiter unten zu finden.</para>

      </sect1>

      <sect1>

        <title>Definition im Workflow</title>

        <para>Je nachdem, wie externe Typen im UML-Modell definiert 
        wurden, muss dies auch im Workflow angegeben werden. Dazu 
        werden die folgenden drei Parameter der Workflow-Komponenten 
        makeGenesezModel bzw. makeGenesezModelProfile genutzt:</para>

        <para />

        <para>* mapClassesInModelToExternal » Der Parameter kann als 
        Wert true oder false annehmen und gibt an, ob Typen, die direkt 
        im Modell abgelegt sind und somit zu keinem Package geh&ouml;ren, zu 
        externen Typen transformiert werden (true) oder normal 
        behandelt werden (false). Standardm&auml;&szlig;ig ist der Wert 
        false.</para>

        <para>* externalPackages » Als Wert f&uuml;r den Parameter kann eine 
        mit Komma (oder f&uuml;r eine bessere Lesbarkeit eine mit Komma und 
        Leerzeichen) separierte Liste mit Namen von Packages angegeben 
        werden, welche Container f&uuml;r externe Typen darstellen. Die 
        angegebenen Packages selbst werden ebenfalls nicht in ein 
        GeneSEZ-Package transformiert. Standardm&auml;&szlig;ig ist der Wert ein 
        leerer String.</para>

        <para>* externalStereotypes » Als Wert kann eine mit Komma 
        (oder f&uuml;r eine bessere Lesbarkeit eine mit Komma und 
        Leerzeichen) separierte Liste mit Namen von Stereotypen 
        angegeben werden. Diese Stereotypen k&ouml;nnen im UML-Modell sowohl 
        Typen als auch Packages zugewiesen werden. Ist einer dieser 
        Stereotypen einem Typ zugewiesen, so wird dieser in einen 
        externen Typ transformiert. Ist ein Stereotyp einem Package 
        zugewiesen, so wird dieses als Container f&uuml;r externe Typen 
        betrachtet und wird selbst nicht transformiert. Alle in dem 
        betreffenden Package enthaltenen Typen werden zu externen 
        Typen. Standardm&auml;&szlig;ig ist der Wert ein leerer String.</para>

      </sect1>

      <sect1>

        <title>Umgang in xPand-Templates</title>

        <para>Innerhalb von Templates ist es unwesentlich, ob ein Typ 
        ein externer Typ ist oder nicht. Diese Zuordnung wird durch das 
        GeneSEZ Type-Mapping realisiert.</para>

      </sect1>

      <sect1>

        <title>Beispiel</title>

        <para>Es folgen einige Beispiele, die den Einsatz der 
        vorgestellten M&ouml;glichkeiten zur Definition von externen Typen 
        zeigen. Wie in den Modellen deutlich wird, ist die Verwendung 
        eines Stereotypes zur Annotation von Klassen am 
        ausdrucksst&auml;rksten.</para>

        <sect2>

          <title>Verwendung eines Stereotypes zur Annotation einer 
          Klasse</title>

          <para>Zugeh&ouml;rige Parameter in der Workflow 
          Konfiguration:</para>

        </sect2>

        <sect2>

          <title>Verwendung eines Stereotypes zur Annotation eines 
          Packages</title>

          <para>Zugeh&ouml;rige Parameter in der Workflow Konfiguration 
          (identisch mit dem ersten Beispiel):</para>

        </sect2>

        <sect2>

          <title>Verwendung der Namen von Packages</title>

          <para>Zugeh&ouml;rige Parameter in der Workflow 
          Konfiguration:</para>

        </sect2>

        <sect2>

          <title>Mapping aller Klassen, die direkt im Modell enthalten 
          sind</title>

          <para>Zugeh&ouml;rige Parameter in der Workflow 
          Konfiguration:</para>

        </sect2>

      </sect1>

    </chapter>

    <chapter>

      <title>Das GeneSEZ-Logging-Konzept</title>

      <para>In diesem Artikel soll in aller K&uuml;rze das 
      GeneSEZ-Logging-Konzept-beschrieben werden. Dabei wird auf das 
      Logging in Java-Code, in Skripten und in Templates sowie auf die 
      Konfiguration eingegangen.</para>

      <para />

      <para>GeneSEZ basiert auf dem Framework openArchitectureWare, 
      welches die Logging-API des Apache Commons Logging Frameworks 
      nutzt und als Implementierung log4j verwendet. Das 
      GeneSEZ-Framework nutzt ebenfalls das Apache Commons Logging 
      Framework.</para>

      <sect1>

        <title>Java</title>

        <para>Das Logging von Java-Code aus unterscheidet sich nicht 
        von der gew&ouml;hnlichen Nutzung der Logging-API. Zuerst wird eine 
        Referenz auf ein Log-Objekt ben&ouml;tigt: Dann kann dieses 
        Log-Objekt genutzt werden, um Log-Ausgaben zu 
        realisieren:Weitere Informationen befinden sich im Manual zu 
        log4j: log4j 1.2 Manual</para>

      </sect1>

      <sect1>

        <title>Skripten + Templates</title>

        <para>F&uuml;r Log-Ausgaben aus den openArchitectureWare-Artefakten 
        steht als Frontend im Common-Projekt unter dem Namespace 
        de.genesez.platforms.common.log das eXtend-Skript Log.ext zur 
        Verf&uuml;gung. Die Funktionen dieses Skriptes rufen Methoden der 
        Java Klasse GenesezLogger auf, welche die Apache Commons 
        Logging-API nutzen.</para>

        <para />

        <para>Sollen Log-Ausgaben erfolgen, so sollte zuerst ein 
        benannter Logger ausgew&auml;hlt werden, damit die Ausgaben sp&auml;ter 
        im Log einem Artefakt zugeordnet werden k&ouml;nnen:</para>

        <para>Die weiteren Funktionen des Skripts dienen zum Logging 
        von Nachrichten mit dem jeweiligen Log-Level:</para>

      </sect1>

      <sect1>

        <title>Konfiguration</title>

        <para>Zur Konfiguration der verwendeten Implementierung log4j 
        hat openArchitectureWare bereits standardm&auml;&szlig;ig die Datei 
        log4j.properties im Classpath, die dementsprechend auch 
        standardm&auml;&szlig;ig genutzt wird. Das GeneSEZ-Framework stellt 
        ebenfalls eine log4j.properties im Namespace 
        de.genesez.platforms.common.log bereit. log4j sucht den 
        kompletten Classpath nach dieser Datei ab und nutzt die erste 
        Datei dieses Namens, die gefunden wird. Daher wird i.d.R. die 
        von openArchitectureWare genutzt, da diese im Classpath eher 
        gefunden wird.</para>

        <para />

        <para>Soll die Log-Konfiguration angepasst werden, so kann die 
        vom GeneSEZ-Framework bereitgestellte als Vorlage genutzt 
        werden. Dazu wird diese in das Konfigurationsverzeichnis des 
        aktuellen Generator-Projekts kopiert (siehe GeneSEZ 
        Projektstruktur).</para>

        <para />

        <para>Zur detaillierten Erkl&auml;rung der Inhalte der 
        Konfigurationsdatei sei auf das log4j Manual verwiesen: log4j 
        1.2 Manual</para>

      </sect1>

    </chapter>

    <chapter>

      <title>GeneSEZ UML Profil</title>

      <para>Um Konzepte des GeneSEZ-Metamodells in UML zu modellieren 
      sowie n&uuml;tzliche und fachlich relevante Informationen zur 
      Umsetzung im Modell zu hinterlegen, wurde ein GeneSEZ-UML-Profil 
      eingef&uuml;hrt. Dieses ist prinzipiell plattformunabh&auml;ngig, jedoch 
      m&uuml;ssen nicht alle Aspekte, die das UML-Profil enth&auml;lt, auch von 
      den plattform-spezifischen Template-Sets ausgewertet 
      werden.</para>

      <para />

      <para>Welche Aspekte die plattformspezifischen Templates 
      unterst&uuml;tzen, ist in der Dokumentation zu den jeweiligen 
      Plattformen zu finden.</para>

      <para />

      <para>source:trunk/de.genesez.docs/GeneSezProfile/genesez.profile.png</para>

      <para>Folgend werden die einzelnen Stereotypen und ihre Bedeutung 
      n&auml;her erl&auml;utert.</para>

    </chapter>

  </part>

</book>

