<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE book
	PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd"
	[
		<!ENTITY % isolat1 SYSTEM "http://www.w3.org/2003/entities/iso8879/isolat1.ent">
		%isolat1;
	]
>
<book>

  <bookinfo>

    <title>Das GeneSEZ Generator Framework</title>

    <authorgroup>

      <author><firstname>Tobias</firstname><surname>Haubold</surname></author>

      <author><firstname>Frank</firstname><surname>Grimm</surname></author>

      <author><firstname>Oliver</firstname><surname>Arnold</surname></author>

      <author><firstname>Gerrit</firstname><surname>Beine</surname></author>

    </authorgroup>

    <edition>Handbuch Version 1.6</edition>
    <pubdate>2009</pubdate>

    <copyright><year>2006</year><year>2007</year><year>2008</year><year>2009</year><holder>GeneSEZ</holder></copyright>
  </bookinfo>

  <part>

    <title>Getting Started</title>

    <chapter>

      <title>Der GeneSEZ-Ansatz</title>

      <para>In diesem Kapitel sollen die Hintergründe für die 
      Entstehung des GeneSEZ-Frameworks n&auml;her beschrieben werden. Dazu 
      werden kurz die modellgetriebene Softwareentwicklung sowie einige 
      Herausforderungen, denen sich diese Art der Softwareentwicklung 
      gegenübersieht, aufgezeigt. Davon ausgehend wird dann der 
      GeneSEZ-Ansatz vorgestellt, der einigen dieser Herausforderungen 
      begegnen soll.</para>

      <sect1>

        <title>Modellgetriebene Softwareentwicklung</title>

        <para>Die modellgetriebene Softwareentwicklung (kurz MDSD für 
        engl. model driven software development) besch&auml;ftigt sich 
        allgemein mit der Generierung von Quellcode einer Software aus 
        formalen Modellen.</para>

        <para>Dabei dienen Modelle nicht mehr nur als Dokumentation 
        oder Visualisierung von Realisierungsproblemen einer Software, 
        sondern rücken selbst in den Mittelpunkt der 
        Softwareentwicklung. Dass es sich um formale Modelle handeln 
        muss, ergibt sich daraus, dass sie automatisch in Quellcode 
        transformiert werden sollen. Die Formalit&auml;t wird dabei durch 
        die Verwendung eines Metamodells gew&auml;hrleistet.</para>

        <para>Als Ziele der MDSD werden meist die Wiederverwendung von 
        Architekturen, die gleichbleibend hohe Qualit&auml;t des Quellcodes 
        sowie die Steigerung der Entwicklungsgeschwindigkeit 
        genannt.</para>

      </sect1>

      <sect1>

        <title>Herausforderungen und Hindernisse der MDSD</title>

        <sect2>

          <title>Wahl des Metamodells</title>

          <para>Wie bereits erw&auml;hnt, bildet die Grundlage der MDSD ein 
          Metamodell, welchem die Modelle der zu entwickelnden 
          Applikation genügen. Basierend auf diesem Metamodell werden 
          die Transformationen zur Generierung von Quellcode 
          entwickelt.</para>

          <para>Eine zentrale Herausforderung ist dabei die Wahl des 
          Metamodells. Hier werden meist entweder dom&auml;nenspezifische 
          Sprachen (sog. DSL für engl. domain specific language) oder 
          die Unified Modeling Language (UML) eingesetzt. DSLs sind 
          speziell für einen bestimmten Anwendungs- bzw. Problembereich 
          geeignet. Sie besitzen eine sehr pr&auml;zise Ausdrucksweise mit 
          der Semantik des Problembereichs und sind deshalb auch auf 
          diesen beschr&auml;nkt. H&auml;ufig sind DSLs nicht standardisiert, 
          wodurch die Kommunikation zwischen Entwicklern leiden kann, 
          da jeder Entwickler erst diese spezielle Sprache erlernen 
          muss. Werden DSLs durch die Entwickler selbst definiert, so 
          müssen diese auch in einem Entwicklungsprozess mit gepflegt 
          werden.</para>

          <para>Die UML dagegen ist ein Standard zur Modellierung von 
          Software, der von der OMG spezifiziert wurde. Sie ist 
          allgemeingültig und unter Entwicklern i.d.R. bereits bekannt. 
          Ein wesentlicher Nachteil der UML ist die Komplexit&auml;t und die 
          fehlende Referenzimplementierung. Jedoch existiert mit dem 
          Eclipse-UML2-Projekt eine Implementierung der UML, die einige 
          Toolhersteller nutzen bzw. durch eine Export-Funktionalit&auml;t 
          unterstützen, wodurch sich dieses Projekt de facto zu einer 
          Referenzimplementierung entwickelt.</para>

        </sect2>

        <sect2>

          <title>MDSD-Entwicklungsprozess</title>

          <para>Im Vergleich zur herk&ouml;mmlichen Softwareentwicklung 
          kommen bei modellgetriebener Softwareentwicklung einige 
          weitere Tools zum Einsatz. Dazu geh&ouml;rt eine Software zur 
          Erstellung der Modelle.</para>

          <para>Weiterhin erfordert ein MDSD-Entwicklungsprozess:</para>

          <para />

          <para>* Modellvalidierungen zur überprüfung der Modelle</para>

          <para>* Modellmodifikationen, um kleine &auml;nderungen an 
          Modellen durchführen zu k&ouml;nnen</para>

          <para>* Modell-zu-Modell-Transformationen</para>

          <para>* Modell-zu-Text-Transformationen</para>

          <para />

          <para>Die Softwarebausteine zur Unterstützung der genannten 
          Aufgaben müssen gut zusammenarbeiten. Aktualisierungen 
          einzelner Bestandteile k&ouml;nnen sich hinderlich auf die 
          Zusammenarbeit auswirken. Im Zusammenhang mit diesen 
          aufeinander aufbauenden Aufgaben und Werkzeugen wird auch oft 
          von der so genannten &quot;Tool-Chain&quot; (dt. 
          Werkzeugkette).</para>

        </sect2>

        <sect2>

          <title>Wiederverwendung</title>

          <para>In einem MDSD-Entwicklungsprozess kommen verschiedene 
          Quellcode-Artefakte zum Einsatz. Einen wesentlichen Teil 
          bilden dabei die Templates für 
          Modell-zu-Text-Transformationen, aber auch Skripte für 
          Modell-Modifikationen, Modell-zu-Modell-Transformationen und 
          Hilfsfunktionen. Mit Hilfe dieser Artefakte wird der 
          Infrastruktur-Quellcode generiert, der anschlie&szlig;end fertig 
          implementiert werden muss. Da die Erstellung dieser Artefakte 
          eine nicht zu vernachl&auml;ssigende Zeit in Anspruch nimmt, 
          sollten diese Artefakte in einem MDSD-Entwicklungsprozess so 
          oft wie m&ouml;glich wiederverwendet werden.</para>

          <para />

          <para>All genannten Artefakte sind von dem verwendeten 
          Metamodell abh&auml;ngig. Kommt hierbei die UML zum Einsatz, wird 
          die Auswertung der Modellinformationen durch die Komplexit&auml;t 
          und hochgradige Normalisierung erschwert. 
          Modellmodifikationen und Modell-zu-Modell-Transformationen 
          sind nur mit sehr viel Aufwand realisierbar. Modelle 
          domainspezifischer Sprachen sind auf der anderen Seite 
          aufgrund ihrer Beschr&auml;nkung auf einen Problembereich leichter 
          auswertbar. Modellmodifikationen und 
          Modell-zu-Modell-Transformationen sind durch den beschr&auml;nkten 
          Umfang ebenfalls realisierbar. Problematisch kann allerdings 
          die Zukunftssicherheit der DSL sein. Ein Problem entsteht 
          beispielsweise, wenn Software für einen anderen 
          Anwendungsbereich entwickelt werden muss, welche die DSL 
          bisher nicht abdeckt.</para>

        </sect2>

      </sect1>

      <sect1>

        <title>GeneSEZ-Ansatz</title>

        <para>Das wesentliche Alleinstellungsmerkmal des 
        GeneSEZ-Ansatzes für modellgetriebene Softwareentwicklung ist 
        das GeneSEZ-Metamodell. Dabei handelt es sich um ein 
        allgemeingültiges Metamodell, welches die Basis des 
        Entwicklungsprozesses bildet. Dadurch wird die bereits 
        angesprochene Wiederverwendung der Artefakte des 
        Entwicklungsprozesses sicher gestellt sowie eine Entkopplung 
        von der verwendeten Modellierungssoftware erreicht.</para>

        <sect2>

          <title>GeneSEZ-Metamodell</title>

          <para>Das GeneSEZ-Metamodell kann weitgehend als 
          domainspezifisches Modell aufgefasst werden, wobei die Domain 
          hier die Generierung von Quellcode selbst ist. Es ist ein 
          allgemeingültiges Metamodell und ist dadurch der UML sehr 
          &auml;hnlich. Allerdings ist es sehr viel einfacher strukturiert, 
          um die Zugriffe auf Modellinformationen zu vereinfachen. Dazu 
          geh&ouml;ren kurze Navigationspfade sowie keine unn&ouml;tigen 
          abstrakten Elemente, die bei normalisierten Modellen 
          enthalten w&auml;ren.</para>

          <para />

          <para>Durch diese Vorgehensweise werden dem 
          Template-Entwickler die Modellinformationen in sinnvoller 
          Weise pr&auml;sentiert und die einfache Erstellung von 
          Modellmodifikationen sowie Modell-zu-Modell-Transformationen 
          wird erm&ouml;glicht.</para>

        </sect2>

        <sect2>

          <title>Modell-Adapter</title>

          <para>Durch die feste Verankerung eines Metamodells im 
          MDSD-Entwicklungsprozess stellt sich natürlich die Frage, wie 
          darauf aufbauende Modelle erstellt werden k&ouml;nnen. Es kan 
          schlie&szlig;lich kaum erwartet werden, dass Modellierer nur wegen 
          der Nutzung des GeneSEZ-Ansatzes ihre bereits seit langer 
          Zeit genutzte Modellierungssoftware aufgeben. Deshalb wurde 
          das Konzept der Modelladapter eingeführt, die ein auf einem 
          anderem Metamodell beruhendes Modell in ein 
          GeneSEZ-Metamodell-basiertes Modell überführen k&ouml;nnen.</para>

          <para />

          <para>Obwohl der GeneSEZ-Ansatz kein Ausgangs-Metamodell 
          vorschreibt und somit jeder Anwender sein pr&auml;feriertes 
          Metamodell zur Erstellung der Modelle nutzen kann, wird 
          jedoch der Einsatz der UML empfohlen. Diese ist weit 
          verbreitet, standardisiert und vielen Entwicklern bereits 
          bekannt. Durch die wohldefinierte Semantik der 
          UML-Modellelemente ist ein einheitliches Verst&auml;ndnis des 
          Modells bei Entwicklern gegeben. Modelle auf Basis der 
          Eclipse-UML2-Implementierung werden durch das 
          GeneSEZ-Framework &quot;out-of-the-box&quot; 
          unterstützt.</para>

          <para />

          <para>DSLs hingegen müssen von jedem Entwickler erst erlernt 
          werden, wodurch ein einheitliches Grundverst&auml;ndnis der DSL 
          nicht ohne Weiteres gegeben ist. Jedoch werden auch DSLs 
          durch den GeneSEZ-Ansatz unterstützt. Ist die DSL auf Basis 
          der UML definiert so wird diese &quot;out-of-the-box&quot; 
          unterstützt. Andere DSLs k&ouml;nnen aufgrund deren zahlreichen 
          Auspr&auml;gungen und vielf&auml;ltigen Definitionsm&ouml;glichkeiten nicht 
          &quot;out-of-the-box&quot; unterstützt werden. Für solche 
          DSLs ist die Erstellung eines Modelladapters erforderlich, 
          der das domainspezifische Modell in ein GeneSEZ-Modell 
          transformiert.</para>

        </sect2>

        <sect2>

          <title>GeneSEZ-Tooling</title>

          <para>Das GeneSEZ-Framework basiert ausschlie&szlig;lich auf 
          Open-Source-Software. Ein wesentlicher Bestandteil ist das 
          Generator-Framework openArchitectureWare. Das 
          GeneSEZ-Framwork besteht aus dem GeneSEZ-Metamodell, einigen 
          weiteren Komponenten sowie den Artefakten zur 
          Quellcodegenerierung.</para>

        </sect2>

      </sect1>

      <sect1>

        <title>Abschlussbemerkungen</title>

        <para>Wesentlich für einen MDSD-Entwicklungsprozess ist das in 
        ihm verankerte Metamodell. Der Stellenwert des Metamodells ist 
        somit relativ hoch. Die Artefakte, die in einem 
        Entwicklungsprozess genutzt werden, basieren ebenfalls auf dem 
        Metamodell. Die Erstellung der Artefakte des GeneSEZ-Frameworks 
        hat eine nicht unwesentliche Zeit in Anspruch genommen. Der 
        Umfang des Metamodells ist verglichen mit denen der Artefakte 
        relativ kompakt. Daher sollte der Umfang der Artefakte in einem 
        Entwicklungsprozess nicht untersch&auml;tzt werden.</para>

        <para />

        <para>Im folgenden Bild ist beispielhaft ein m&ouml;glicher 
        modellgetriebener Entwicklungsprozess auf Basis des 
        GeneSEZ-Frameworks abgebildet:</para>

      </sect1>

    </chapter>

    <chapter>

      <title>Installation von GeneSEZ</title>

      <para>In diesem How-To soll beschrieben werden, wie das 
      GeneSEZ-Framework installiert werden kann. Das GeneSEZ-Framework 
      ist derzeit als Eclipse-Plug-In verfügbar.</para>

      <sect1>

        <title>GeneSEZ</title>

        <para>Version: 1.6.x</para>

        <para />

        <para>* Abh&auml;ngigkeiten: Eclipse SDK, openArchitectureWare, EMF, 
        UML2</para>

        <para>* Homepage: http://genesez.de/</para>

        <para>* Update-Site: 
        http://genesez.de/updatesite/site.xml</para>

        <para>* ben&ouml;tigte Features:</para>

        <para>o Identifier: de.genesez.feature.feature.group » GeneSEZ 
        Framework</para>

      </sect1>

      <sect1>

        <title>Ben&ouml;tigte Eclipse-Plug-Ins</title>

        <para>Das GeneSEZ-Framework basiert auf openArchitectureWare 
        und setzt demnach die folgenden Eclipse-Plug-Ins voraus. 
        Hinweis: Es sind jeweils nur die notwendigen Features der 
        einzelnen Plug-Ins gelistet. Bei Bedarf k&ouml;nnen natürlich auch 
        weitere Features installiert werden.</para>

        <sect2>

          <title>Eclipse SDK</title>

          <para>Version: 3.3.x</para>

          <para />

          <para>* Update-Site: 
          http://download.eclipse.org/eclipse/updates/3.3/</para>

          <para>* z.B. die Eclipse Classic IDE</para>

          <para />

          <para>Version: 3.4.x</para>

          <para />

          <para>* Update-Site: 
          http://download.eclipse.org/eclipse/updates/3.4/</para>

          <para>* z.B. Feature:</para>

          <para>o Identifier: org.eclipse.sdk.ide&apos; » Eclipse 
          Classic SDK</para>

        </sect2>

        <sect2>

          <title>openArchitectureWare</title>

          <para>Version: 4.3.x</para>

          <para />

          <para>* Abh&auml;ngigkeiten: EMF, UML2</para>

          <para>* Homepage: http://openarchitectureware.org/, 
          http://www.eclipse.org/gmt/oaw/</para>

          <para>* Update-Site: 
          http://www.openarchitectureware.org/updatesite/milestone/</para>

          <para>* ben&ouml;tigte Features:</para>

          <para>o Identifier: 
          org.openarchitectureware.lib.feature.feature.group » 
          openArchitectureWare libraries</para>

          <para>o Identifier: 
          org.openarchitectureware.core.feature.feature.group » 
          openArchitectureWare core</para>

          <para>o Identifier: 
          org.openarchitectureware.plugins.feature.feature.group » 
          openArchitectureWare plugins</para>

          <para>o Identifier: 
          org.openarchitectureware.uml2.adapter.feature.group » 
          openArchitectureWare uml2 adapter</para>

        </sect2>

        <sect2>

          <title>EMF</title>

          <para>Version: 2.3.x</para>

          <para />

          <para>* Homepage: http://www.eclipse.org/modeling/emf/</para>

          <para>* Update-Site: 
          http://download.eclipse.org/modeling/emf/updates/releases/</para>

          <para>* ben&ouml;tigte Features:</para>

          <para>o Identifier: org.eclipse.emf.feature.group » Eclipse 
          Modeling Framework (EMF) Runtime + End-User Tools</para>

        </sect2>

        <sect2>

          <title>UML2</title>

          <para>Version: 2.1.x</para>

          <para />

          <para>* Abh&auml;ngigkeiten: EMF</para>

          <para>* Homepage: 
          http://www.eclipse.org/modeling/mdt/?project=uml2</para>

          <para>* Update-Site: 
          http://download.eclipse.org/modeling/mdt/updates/releases/</para>

          <para>* ben&ouml;tigte Features:</para>

          <para>o Identifier: org.eclipse.uml2.feature.group » UML2 
          End-User Features</para>

          <para />

          <para>Das GeneSEZ-Framework l&auml;uft sowohl unter Eclipse 3.3 
          als auch unter Eclipse 3.4. Unter Eclipse 3.4 müssen 
          allerdings die oben aufgeführten &auml;lteren Versionen von EMF 
          und UML2 installiert werden, da die neueren noch nicht von 
          openArchitectureWare und GeneSEZ unterstützt werden.</para>

        </sect2>

      </sect1>

      <sect1>

        <title>Benutzer-Installation</title>

        <para>Mit Eclipse 3.4 wurde auch ein neuer Update-Manager 
        namens p2 eingeführt. Daher wird in den folgenden 
        Beschreibungen unterschieden zwischen dem Update-Manager, der 
        bis Eclipse 3.3 für Updates zust&auml;ndig war, und p2, der 
        standardm&auml;&szlig;ig ab Eclipse 3.4 als Update-Manager bereit steht. 
        Die Verwendung von p2 ist aber auch in Eclipse 3.4 nicht 
        zwingend, so dass auch unter Eclipse 3.4 der bisherige 
        Update-Manager genutzt werden kann.</para>

        <sect2>

          <title>Update Manager (standardm&auml;&szlig;ig bis Eclipse 3.3)</title>

          <para>Die einfachste M&ouml;glichkeit der Installation ist die 
          Nutzung des Eclipse Update Manager. Dazu Help » Software 
          Updates » Find and Install... anklicken. Danach Search for 
          new features to install ausw&auml;hlen und next klicken.</para>

          <para />

          <para>Nun müssen die oben gelisteten Update-URLs von GeneSEZ, 
          openArchitectureWare, EMF und UML2 hinzugefügt werden, sofern 
          sie noch nicht existieren (Der Update-Manager verhindert aber 
          auch das doppelte Einfügen der gleichen URL.). Dazu auf New 
          Remote Site... klicken, einen sinnvollen Namen eingeben (z.B. 
          den des Plug-Ins) sowie die Update-URL. Dann auf OK 
          klicken.</para>

          <para>Sind die vier URLs angelegt, diese (und um 
          Seiteneffekte zu verhindern, nur diese) ausw&auml;hlen und auf 
          Finish klicken.</para>

          <para>Wenn die Aufforderung erscheint, einen Mirror zu 
          w&auml;hlen, kann ein beliebiger Mirror gew&auml;hlt werden. Dies hat 
          in der Regel nur Auswirkungen auf die 
          Download-Geschwindigkeit. Dann werden die installierbaren 
          Features angezeigt. Hier muss auf die Versionen geachtet 
          werden. Ggf. muss das H&auml;kchen aus Show the latest version of 
          a feature only entfernt werden, um eine &auml;ltere Version zu 
          installieren.</para>

          <para>Nun müssen alle Features, die installiert werden 
          sollen, ausgew&auml;hlt werden. Am besten in folgender 
          Reihenfolge, um unn&ouml;tige Fehlermeldungen des Update-Managers 
          zu vermeiden, die darauf hinweisen, dass referenzierte 
          Plug-Ins noch nicht installiert sind:</para>

          <para />

          <para>* EMF Runtime + End-User Tools</para>

          <para>* UML2 End-User Features</para>

          <para>* openArchitectureWare Library feature</para>

          <para>* openArchitectureWare core Feature</para>

          <para>* openArchitectureWare core plugins Feature</para>

          <para>* openArchitectureWare UML2 Adapter Feature</para>

          <para>* GeneSEZ Framework</para>

          <para>Sind alle ben&ouml;tigten Features ausgew&auml;hlt, kann auf Next 
          geklickt werden. Dann müssen die Lizenzen best&auml;tigt werden, 
          in dem I accept the terms in the license agreements 
          angeklickt wird. Dann kann auf Next geklickt werden.</para>

          <para />

          <para>Nun kann ausgew&auml;hlt werden, in welches Verzeichnis die 
          Plug-Ins installiert werden sollen. Standardm&auml;&szlig;ig ist dies 
          das Verzeichnis von Eclipse. Soll dieses verwendet werden, 
          einfach auf Finish klicken. Alternativ kann hier auch eine 
          sogenannte Extension Location angelegt werden und für jedes 
          Plug-In individuell der Speicherort festgelegt werden. Soll 
          eine Extension Location verwendet werden, einfach alle 
          Plug-Ins in der Liste markieren (auch mit Strg+A m&ouml;glich) und 
          dann auf Change Location ... klicken. Im sich dann &ouml;ffnenden 
          Dialog auf Add Location... klicken und einen Ordner im 
          Dateisystem w&auml;hlen. Dann auf OK klicken. Nun kann diese 
          Extension Location ausgew&auml;hlt werden und mit OK best&auml;tigt 
          werden. Dann kann mit Finish die Installation gestartet 
          werden.</para>

          <para>Nun werden die Plug-Ins von den Webseiten geladen. Vor 
          der Installation fragt der Update-Manager noch nach einer 
          Feature Verification. Hier kann einfach Install All gew&auml;hlt 
          werden, um die Installation der nicht signierten Plug-Ins zu 
          best&auml;tigen. Zum Schluss muss noch mit Klick auf Yes der 
          Neustart von Eclipse best&auml;tigt werden.</para>

          <para />

          <para>Nach dem Neustart kann mit Klick auf Help » Software 
          Updates » Manage Configuration eine übersicht der 
          installierten Plug-Ins angezeigt werden. Hier sollten die 
          soeben installierten Plug-Ins ohne Fehler aufgelistet 
          sein.</para>

        </sect2>

        <sect2>

          <title>p2 (ab Eclipse 3.4)</title>

          <para>Das User Interface des p2 innerhalb von Eclipse ist 
          &auml;hnlich dem &auml;lteren Update Manager. Daher wird momentan an 
          dieser Stelle noch auf die Anleitung für den &auml;lteren Update 
          Manager verwiesen: Update Manager, Eclipse 3.3</para>

          <para />

          <para>Ein wesentlicher Unterschied ist, dass bei p2 keine 
          Extension Locations mehr spezifiziert werden k&ouml;nnen, in 
          welche die Plug-Ins installiert werden sollen. Die Plug-Ins 
          werden automatisch im Eclipse-Verzeichnis bzw. im genutzten 
          Bundle-Pool-Verzeichnis installiert.</para>

        </sect2>

      </sect1>

      <sect1>

        <title>Entwickler-Installation</title>

        <para>Der Quellcode des GeneSEZ-Frameworkss steht im 
        GeneSEZ-Repository zum Auschecken bereit.</para>

        <sect2>

          <title>GeneSEZ-Repository</title>

          <para>Der Zugriff auf das GeneSEZ-Repository ist erl&auml;utert 
          unter: GeneSEZ Source Control Management</para>

        </sect2>

        <sect2>

          <title>GeneSEZ-Plug-In-Projekte</title>

          <para>Das GeneSEZ Framework besteht aus einem Set von 
          Eclipse-Projekten. Die folgenden Projekte sind für die 
          Benutzung des GeneSEZ-Frameworks auf Basis des Quellcodes 
          erforderlich:</para>

          <para />

          <para>* de.genesez.build » enth&auml;lt ANT-Build-Skripte, die von 
          den anderen Projekten referenziert werden</para>

          <para>* de.genesez.metamodel » enth&auml;lt das 
          GeneSEZ-Metamodel</para>

          <para>* de.genesez.platforms.common » enth&auml;lt 
          allgemeingültige Komponenten und Skripte, die von den anderen 
          Projekten genutzt werden</para>

          <para />

          <para>Weiterhin ist für die Benutzung des GeneSEZ-Frameworks 
          auf Basis des Quellcodes noch mindestens eines der folgenden 
          Plattformprojekte erforderlich, je nachdem für welche 
          Plattform Quellcode generiert werden soll:</para>

          <para />

          <para>* de.genesez.platforms.java » notwendig um 
          Java-Quellcode zu generieren</para>

          <para>* de.genesez.platforms.dotnet » notwendig um 
          C#-Quellcode zu generieren</para>

          <para>* de.genesez.platforms.php » notwendig um PHP-Quellcode 
          zu generieren</para>

          <para />

          <para>Die folgenden beiden Projekte sind notwendig, um die 
          Eclipse-Plugins für das GeneSEZ-Framework zu erstellen und 
          auf der Update-Seite zu publizieren:</para>

          <para />

          <para>* de.genesez.features</para>

          <para>* de.genesez.updatesite</para>

        </sect2>

        <sect2>

          <title>GeneSEZ-Setup</title>

          <para>Bevor das GeneSEZ-Framework genutzt werden kann, muss 
          noch eine Konfiguration erfolgen, die Plug-In-Projekte müssen 
          versioniert werden und die Implementierung des 
          GeneSEZ-Metamodells erstellt werden.</para>

          <para />

          <para>Um die Konfiguration zu erstellen, muss im Projekt 
          de.genesez.build im Ordner build die Datei 
          environment.properties angelegt werden. Hierzu kann die Datei 
          environment.properties.template als Vorlage genutzt werden, 
          welche sich bereits im selben Verzeichnis befindet.</para>

          <para />

          <para>Die GeneSEZ-Build-Skripte nutzen einen automatisierten 
          Mechanismus, um alle GeneSEZ-Projekte zu versionieren. Hierzu 
          ist in den zu versionierenden Dateien ein spezieller 
          Platzhalter vorhanden, der u.a. Eclipse daran hindert, 
          Plug-In-Referenzen aufzul&ouml;sen, weshalb die Projekte auch noch 
          ziemlich viele Fehler aufweisen sollten.</para>

          <para />

          <para>Um die Projekte zu versionieren, muss das Build-Target 
          tag.all des Build-Skripts build.xml, welches sich im 
          Root-Verzeichnis des Projekts de.genesez.build befindet, 
          ausgeführt werden. Sind nicht alle zu versionierenden 
          Projekte ausgecheckt, so sollten die Projekte, die nicht 
          ausgecheckt sind, vorher in der Datei release.properties, 
          welche sich im build-Order des Build-Projektes befindet, 
          auskommentiert werden.</para>

          <para>Nun kann die Generierung der Implementierung des 
          GeneSEZ-Metamodells erfolgen. Dazu muss einfach das 
          Build-Skript build.xml im build-Ordner des 
          Metamodell-Projektes de.genesez.metamodel ausgeführt werden. 
          Zum Ausführen den Menüpunkt Run As » Ant Build... w&auml;hlen und 
          im Tab JRE den Punkt Run in same JRE as the workspace 
          w&auml;hlen.</para>

          <para />

          <para>Nachdem die Metamodell-Implementierung generiert wurde, 
          sollte sich das GeneSEZ-Framework genauso nutzen lassen, wie 
          wenn die Plug-Ins installiert worden w&auml;ren.</para>

        </sect2>

      </sect1>

    </chapter>

    <chapter>

      <title>GeneSEZ: Just Try It Out</title>

      <para>Dieser Artikel verdeutlicht die Funktionweise und Anwendung 
      des GeneSEZ-Frameworks an einem kleinen Beispiel. Dazu wird ein 
      Projekt aus dem GeneSEZ-Repository ausgecheckt, die 
      Projektstruktur erl&auml;utert und ein vorhandenes UML-Modell in 
      Quellcode transformiert.</para>

      <sect1>

        <title>Checkout Beispielprojekt</title>

        <para>Um das Beispielprojekt aus dem GeneSEZ-Repository 
        auszuchecken, muss zuerst die GeneSEZ-Repository Location 
        konfiguriert werden. Dies wird genauer unter GeneSEZ Source 
        Control Management beschrieben.</para>

        <para />

        <para>Anschlie&szlig;end kann das Beispielprojekt 
        de.genesez.example.java.forms sowie das zugeh&ouml;rige 
        Generatorprojekt de.genesez.example.java.forms.generator 
        ausgecheckt werden.</para>

      </sect1>

      <sect1>

        <title>Projektstruktur</title>

        <para>Für ein Softwareprojekt wird eine Aufteilung in 
        mindestens zwei Projekte vorgeschlagen. Dies ist zum Einen ein 
        so genanntes Generatorprojekt, welches Konfigurationen, 
        Bibliotheken und weitere spezifische Artefakte für den 
        modellgetriebenen Entwicklungsprozess beinhaltet. Neben diesem 
        existiert mindestens noch ein weiteres Projekt welches den 
        anwendungsspezifischen Quellcode beinhaltet. Durch diese 
        Aufteilung sind in jedem Projekt nur die Artefakte enthalten, 
        die für das jeweilige Projekt relevant sind.</para>

        <sect2>

          <title>Generatorprojekt</title>

          <para>Das Generatorprojekt ist ein 
          openArchitectureWare-Projekt, welches wiederum ein 
          Eclipse-Plug-In-Projekt ist. Dadurch k&ouml;nnen die ben&ouml;tigten 
          Bibliotheken für den Generator einfach als Eclipse-Plug-Ins 
          referenziert werden. Neben den spezifischen Verzeichnissen 
          und Dateien von Eclipse-Plug-In-Projekten existieren die 
          folgenden Verzeichnisse:</para>

          <para />

          <para>* config</para>

          <para>* model-exp</para>

          <para>* model-gen</para>

          <para />

          <para>Das Verzeichnis config enth&auml;lt den Workflow, welcher 
          die einzelnen Schritte beschreibt, die notwendig sind, um ein 
          Modell in Quellcode zu transformieren. Weiterhin kann 
          optional noch die Datei log4j.properties enthalten sein, 
          welche das von GeneSEZ und openArchitectureWare genutzte 
          Logging-Framework Log4J konfiguriert.</para>

          <para />

          <para>Im Verzeichnis model-exp befindet sich das Modell der 
          Anwendung im XMI-Format des Eclipse UML2-Projektes. Im Falle 
          des Beispielprojektes wurde das Modell mit dem 
          Modellierungswerkzeug Magic Draw erstellt und als Eclipse 
          UML2-Modell exportiert. Daraus ergibt sich auch der Name des 
          Verzeichnisses model-exp, der für &quot;exportiertes 
          Modell&quot; steht. Dieses Modell dient als Ausgangspunkt der 
          Codegenerierung.</para>

          <para />

          <para>Der Ordner model-gen enth&auml;lt ein serialisiertes 
          GeneSEZ-Modell, welches durch den Workflow erzeugt wurde. 
          Sich dieses Modell einmal n&auml;her anzusehen, kann z.B. nützlich 
          sein, um zu überprüfen, ob Modellmodifikationen korrekt 
          funktionieren. Die XMI-Datei kann mit Hilfe des Sample 
          Reflective Ecore Model Editor ge&ouml;ffnet werden. Dieser stellt 
          das Modell in einer Baumstruktur dar, &auml;hnlich wie der UML 
          Model Editor für Eclipse UML2-Modelle.</para>

          <para />

          <para>Weiterhin k&ouml;nnen sich noch weitere Dateien und 
          Verzeichnisse wie z.B. projektspezifische 
          Type-Mapping-Dateien und Artefakte für die Anpassung des 
          Generators im Generator-Projekt befinden.</para>

        </sect2>

        <sect2>

          <title>Anwendungsprojekt</title>

          <para>Bei gr&ouml;&szlig;eren Projekten ist es sinnvoll, mehrere 
          Anwendungsprojekte zu erstellen (z.B. wenn neben einer 
          Desktopoberfl&auml;che eine Weboberfl&auml;che entwickelt wird). 
          Ansonsten ist ein Anwendungsprojekt in der Regel ausreichend. 
          Das Anwendungsprojekt kann ein Eclipse-Projekt der 
          entsprechenden Zielplattform sein: ein Java-Projekt, ein 
          PHP-Projekt oder ein Web-Projekt (je nachdem, welche 
          Eclipse-Nature am besten geeignet ist). Es kann sich aber 
          genauso gut um ein Projekt einer anderen Entwicklungsumgebung 
          handeln (z.B. ein Visual Studio-Projekt für die 
          C#-Entwicklung). Für den modellgetriebenen 
          Entwicklungsprozess an sich ist lediglich ein Verzeichnis im 
          Dateisystem notwendig (siehe unten), jedoch sollte dies 
          sinnvoll in einer Projektstruktur eingegliedert sein.</para>

          <para />

          <para>Die Verzeichnisstruktur ist sehr vom verwendeten 
          Projekt abh&auml;ngig. Deshalb werden hier nur die wichtigsten 
          Verzeichnisse kurz vorgestellt. Im Falle des 
          Beispielprojektes handelt es sich um ein Java-Projekt, das 
          die folgenden Verzeichnisse enth&auml;lt:</para>

          <para />

          <para>* src</para>

          <para>* src-gen</para>

          <para>* lib</para>

          <para>* model</para>

          <para />

          <para>Die Verzeichnisse src und src-gen enhalten den 
          Quellcode des Projektes. Der generierte Quellcode befindet 
          sich dabei im Verzeichnis src-gen und der manuell erstellte 
          in src.</para>

          <para />

          <para>Im lib-Verzeichnis sind die Bibliotheken für das 
          Projekt enthalten. Im Beispielprojekt ist hier die Bibliothek 
          zum Assoziations-Handling enthalten.</para>

          <para />

          <para>Der model-Ordner enth&auml;lt das Modell, welches mit der 
          eingesetzten Modelliersoftware erstellt wurde. Dieses Modell 
          ist dem Anwendungsprojekt zugeordnet, da aus diesem Modell 
          Teile des Quellcodes automatisch erzeugt werden, wodurch das 
          Modell selbst zum Quellcode wird.</para>

        </sect2>

      </sect1>

      <sect1>

        <title>Ausführen des Workflows</title>

        <sect2>

          <title>Hinweis GeneSEZ Version 1.6.0</title>

          <para>Durch einen Bug im GeneSEZ-Plug-In müssen bei Version 
          1.6.0 im Beispiel-Generator-Projekt noch folgende 
          Plug-In-Abh&auml;ngigkeiten und -Bibliotheken hinzugefügt 
          werden:</para>

          <para />

          <para>* openArchitectureWare UML2 Adapter</para>

          <para>* GeneSEZ Metamodell</para>

          <para>* dom4j Bibliothek</para>

          <para />

          <para>Dazu im Ordner META-INF die Datei MANIFEST.MF &ouml;ffnen 
          und im Tab Dependencies unter Required Plug-Ins die beiden 
          Plug-Ins de.genesez.metamodel und 
          org.openarchitectureware.uml2.adapter hinzufügen. Die 
          Bibliothek dom4j.jar wird über den Build Path hinzugefügt: 
          Rechtsklick auf das Projekt und » Build Path » Configure 
          Build Path... w&auml;hlen und dann im Tab Libraries auf Add 
          External JARs... klicken. Nun kann die Datei dom4j-1.6.1.jar 
          aus dem GeneSEZ-Plug-In-Verzeichnis gew&auml;hlt werden (z.B. 
          ...\eclipse-extensions\genesez\eclipse\plugins\de.genesez.platforms.common_1.6.0).</para>

          <para>Um den Workflow zu starten, einfach Rechtsklick auf die 
          Datei workflow.oaw im Verzeichnis config und Run As » oAW 
          Workflow w&auml;hlen. In der Konsole sollte bei erfolgreicher 
          Ausführung in den letzten Zeilen die folgende Ausgabe 
          erscheinen:</para>

          <mediaobject><imageobject>
          <imagedata fileref="images/workflow.finish.png"/></imageobject></mediaobject>
          <para>Im Verzeichnis src-gen des Anwendungsprojektes sollte 
          nun der aktuelle generierte Quellcode vorhanden sein.</para>

        </sect2>

      </sect1>

      <sect1>

        <title>Workflow Details</title>

        <para>Der Workflow kann mit einem Doppelklick ge&ouml;ffnet werden. 
        Die Definition des Workflows ist &auml;hnlich der von 
        ANT-Build-Skripten. In der ersten H&auml;lfte sind Properties 
        definiert. Dies sind projektspezifische Einstellungen wie Pfad 
        und Dateiname des Modells sowie Standardwerte für die Workflow 
        Komponenten. In der zweiten H&auml;lfte des Workflows sind die 
        Workflowkomponenten definiert, die die Transformationsschritte 
        vom Modell bis zum Quellcode definieren:</para>

        <para />

        <para>1. Die erste Workflowkomponente liest ein UML2-Modell 
        ein, validiert es und transformiert es in ein 
        GeneSEZ-Modell</para>

        <para>2. Danach wird das GeneSEZ-Modell mit allgemeinen Regeln 
        auf Korrektheit überprüft</para>

        <para>3. Als drittes wird das GeneSEZ-Modell auf 
        Java-Konformit&auml;t überprüft</para>

        <para>4. Die vierte Workflowkomponente serialisiert das 
        GeneSEZ-Modell in eine Datei</para>

        <para>5. Als letztes wird das GeneSEZ-Modell mit Hilfe der 
        Java-Templates in Java-Quellcode transformiert</para>

        <para />

        <para>Die Parameter der einzelnen Workflow Komponenten sind in 
        der Workflow-Referenz erkl&auml;rt: GeneSEZ Workflow Referenz.</para>

      </sect1>

      <sect1>

        <title>Generierter Quellcode</title>

        <para>Wesentlich für die Akzeptanz der MDSD ist, dass der 
        generierte Quellcode den Coding-Guidelines der Entwickler 
        entspricht. Um dies zu erreichen, stehen mehrere M&ouml;glichkeiten 
        bereit.</para>

        <para />

        <para>Die Workflowkomponente zur Durchführung einer 
        Modell-zu-Text-Transformation stellt Parameter bereit, um das 
        Aussehen des generierten Quellcodes zu beeinflussen. Dazu wird 
        hier auf die Referenz dieser Workflowkomponente verwiesen: 
        GeneSEZ Modell-zu-Text Workflow Komponente</para>

        <para />

        <para>Gr&ouml;&szlig;ere &auml;nderungen an der Struktur des Quellcodes k&ouml;nnen 
        mit Hilfe des Customization Guide erreicht werden: GeneSEZ 
        Customization Guide?</para>

        <para />

        <para>Für Informationen, wie die GeneSEZ-Templates 
        Modellinformationen in Quellcode umsetzen, wird auf die 
        GeneSEZ-Generator-Pattern verwiesen.</para>

      </sect1>

    </chapter>

  </part>

  <part>

    <title>Benutzer-Referenz</title>

    <chapter>

      <title>Workflow und Workflow Komponenten</title>

      <para>Für den GeneSEZ Workflow stehen einzelne Komponenten zur 
      Verfügung. Die core-Komponenten sind die Standard-Komponenten. 
      Die internal werden nur von anderen Workflow-Komponenten 
      verwendet und sollten nicht direkt genutzt werden. Weiterhin gibt 
      es mit java eine plattformspezifische Workflow-Komponente für die 
      Java-Plattform.</para>

      <para>Die Workflow-Komponenten sind in der Abbildung als Klassen 
      dargestellt und die Parameter der Workflow-Komponenten als 
      Attribute.</para>

      <sect1>

        <title>Standard-Komponenten</title>

        <sect2>

          <title>makeGenesezModel</title>

          <para>Erstellt aus einer EMF-UML2-Modell-Datei ein 
          instantiiertes GeneSEZ-Modell. Dabei werden die beiden 
          internen Komponenten xmiReader und uml2genesez genutzt.</para>

          <para />

          <para>inputModelFile</para>

          <para>eine EMF-UML2-Modell-Datei</para>

          <para>genesezModel</para>

          <para>Name des Slots, auf dem das GeneSEZ-Modell gespeichert 
          wird</para>

          <para>excludePackages</para>

          <para>Mit Komma getrennte Liste von Package-Namen, welche 
          nicht mit transformiert werden sollen</para>

          <para>mapClassesInModelToExternal</para>

          <para>boolscher Wert, der angibt, ob Klassen, die direkt im 
          Modell liegen (d.h. auf der obersten Stufe im Modell liegen 
          und nicht in Packages eingeordnet sind), zu externen Typen 
          transformiert werden</para>

          <para>externalPackages</para>

          <para>Liste von Package-Namen, welche als Container für 
          externe Typen dienen (Komma getrennt)</para>

          <para>externalStereotypes</para>

          <para>Liste von Stereotypen, welche zur Markierung von 
          externen Typen verwendet werden (Komma getrennt)</para>

        </sect2>

        <sect2>

          <title>makeGenesezModelProfile</title>

          <para>Wie die Komponente makeGenesezModel, jedoch wird ein 
          UML-Profil als zus&auml;tzliches Metamodell registriert, welches 
          in der Transformation genutzt werden kann.</para>

          <para />

          <para>uml2ProfileFile</para>

          <para>Name eines EMF-UML2-Profils, das als Metamodell für die 
          Transformation genutzt wird</para>

          <para />

          <para>Die anderen Parameter sind identisch mit der Komponente 
          makeGenesezModel.</para>

        </sect2>

        <sect2>

          <title>performM2T</title>

          <para>Führt eine Modell-zu-Text Transformation durch.</para>

          <para />

          <para>rootTemplate</para>

          <para>Aufruf eines Define-Blocks eines Templates, welches die 
          Transformation startet/durchführt</para>

          <para>outputDir</para>

          <para>Das Verzeichnis, in dem die generierten Dateien 
          gespeichert werden</para>

          <para>proRegDir</para>

          <para>Das Verzeichnis, welches nach Protected Regions 
          durchsucht wird (normalerweise das gleiche wie das 
          outputDir)</para>

          <para>aspectTemplates</para>

          <para>Liste von XPand-Templates mit Aspekt-Advices für das 
          XPand AOP</para>

          <para>aspectScripts</para>

          <para>Liste von XTend-Skripten mit Aspekt-Advices für XTend 
          AOP</para>

          <para>typeMappingFile</para>

          <para>Name der zu verwendenden Type-Mapping-Datei</para>

          <para>excludePackages</para>

          <para>Liste von (voll qualifizierten) Package-Namen, die von 
          der Modell-zu-Text Transformation ausgeschlossen werden 
          sollen</para>

          <para>useModelNameAsBasePackage</para>

          <para>boolscher Wert, der angibt, ob der Name des Modells als 
          Bezeichnung für das base package verwendet werden soll. Der 
          Standardwert ist false.</para>

          <para>basePackage</para>

          <para>String, der den Namen des zu verwendenden base packages 
          angibt</para>

          <para>generateSectionComments</para>

          <para>boolscher Wert, der angibt, ob verschiedene Abschnitte 
          in den generierten Artefakten mit einem einleitenden 
          Kommentar versehen werden sollen. Der Standardwert ist 
          true.</para>

          <para>disableAccessors</para>

          <para>boolscher Wert, der angibt, ob die (standardm&auml;&szlig;ige) 
          Generierung von Zugriffsfunktionen (z.B. Get- und 
          Set-Methoden in Java) für Attribute unterdrückt werden soll. 
          Der Standardwert ist false.</para>

          <para>useAccessorStereotype</para>

          <para>boolscher Wert, der angibt, ob der Stereotyp «accessor» 
          ausgewertet werden soll. Der Standardwert ist false.</para>

          <para>usePropertyVisibilityForAccessors</para>

          <para>boolscher Wert, der angibt, dass Properties immer die 
          Sichtbarkeit private erhalten und die Sichtbarkeit der 
          Property für die Zugriffsfunktionen (Accessors) verwendet 
          werden soll (wenn auf true gesetzt) bzw. dass Properties ihre 
          Sichtbarkeit behalten und die Zugriffsfunktionen immer die 
          Sichtbarkeit public erhalten (wenn auf false gesetzt). Der 
          Standardwert ist false.</para>

          <para>configFile</para>

          <para>Name einer Konfigurationsdatei. Wird aktuell nicht 
          verwendet.</para>

        </sect2>

        <sect2>

          <title>performM2M</title>

          <para>Führt eine Modell-zu-Modell-Transformation durch.</para>

          <para />

          <para>invokeScript</para>

          <para>Aufruf einer Funktion eines XTend-Skriptes, welches die 
          Transformation durchführt</para>

          <para>outputModelSlot</para>

          <para>Name des Slots, auf dem das neu erstellte Modell 
          gespeichert wird</para>

          <para>configFile</para>

          <para>Name einer Konfigurationsdatei. Wird aktuell nicht 
          verwendet</para>

        </sect2>

        <sect2>

          <title>performMM</title>

          <para>Führt eine Modell-Modifikation durch. Dabei wird ein 
          Modell mit Hilfe eines XTend-Skriptes ge&auml;ndert.</para>

          <para />

          <para>invokeScript</para>

          <para>Aufruf einer Funktion eines XTend-Skriptes, welches die 
          Modifikation durchführt</para>

          <para>configFile</para>

          <para>Name einer Konfigurationsdatei. Wird aktuell nicht 
          verwendet.</para>

        </sect2>

        <sect2>

          <title>constraintChecker</title>

          <para>Validiert ein instantiiertes Modell mit einer 
          openArchitectureWare-check-Datei.</para>

          <para />

          <para>modelSlot</para>

          <para>Name des Slots, auf dem das Modell gespeichert ist, das 
          validiert werden soll</para>

          <para>checkScript</para>

          <para>eine check-Datei, welche die Regeln zur überprüfung 
          enth&auml;lt</para>

          <para>abortOnError</para>

          <para>boolscher Wert, der angibt, ob der Workflow abgebrochen 
          werden soll, wenn Fehler im Modell gefunden werden</para>

        </sect2>

        <sect2>

          <title>xmiWriter</title>

          <para>Serialisiert ein instantiiertes Modell in eine 
          Datei.</para>

          <para />

          <para>modelSlot</para>

          <para>Name des Slots, auf dem das Modell gespeichert ist, das 
          serialisiert werden soll</para>

          <para>outputModelFile</para>

          <para>Name der Datei, die dann das serialisierte Modell 
          enth&auml;lt</para>

        </sect2>

        <sect2>

          <title>directoryCleaner</title>

          <para>L&ouml;scht den Inhalt von Verzeichnissen.</para>

          <para />

          <para>cleaningDirs</para>

          <para>Liste mit Verzeichnisnamen</para>

        </sect2>

      </sect1>

      <sect1>

        <title>Java spezifische Komponenten</title>

        <sect2>

          <title>performM2T</title>

          <para>Führt eine Modell-zu-Text-Transformation für die 
          Java-Plattform durch. Generierte Artefakte werden vom 
          Eclipse-Java-Beautifier sowie von einem XML-Beautifier 
          formatiert.</para>

          <para />

          <para>Die Parameter sind die gleichen wie bei der Komponente 
          performM2T</para>

        </sect2>

      </sect1>

      <sect1>

        <title>Interne Komponenten</title>

        <sect2>

          <title>xmiReader</title>

          <para>Liest die mit inputModelFile angegebene (z.B. von Magic 
          Draw exportierte) EMF-UML2-XMI-Datei ein, instantiiert das 
          UML2-Model und stellt das UML2-Modell auf den Slot bereit, 
          der mit dem Parameter modelSlot angegeben wurde. Slots sind 
          eine Art globale Variable, die von jeder Workflow-Komponente 
          genutzt werden k&ouml;nnen.</para>

          <para />

          <para>inputModelFile</para>

          <para>siehe Komponente makeGenesezModel</para>

          <para>modelSlot</para>

          <para>Name des Slots, auf dem das instantiierte Modell 
          gespeichert wird</para>

        </sect2>

        <sect2>

          <title>uml2genesez</title>

          <para>Transformiert ein (instantiiertes) UML2-Modell in ein 
          GeneSEZ-Model.</para>

          <para />

          <para>uml2Model</para>

          <para>Name des Slots, auf dem das UML2 Modell gespeichert 
          ist</para>

          <para>genesezModel</para>

          <para>siehe Komponente makeGenesezModel</para>

          <para>excludePackages</para>

          <para>siehe Komponente makeGenesezModel</para>

          <para>mapClassesInModelToExternal</para>

          <para>siehe Komponente makeGenesezModel</para>

          <para>externalPackages</para>

          <para>siehe Komponente makeGenesezModel</para>

          <para>externalStereotypes</para>

          <para>siehe Komponente makeGenesezModel</para>

        </sect2>

        <sect2>

          <title>uml2genesezProfile</title>

          <para>Transformiert ein (instantiiertes) UML2-Modell in ein 
          GeneSEZ-Model mit Angabe eines UML-Profils, das zus&auml;tzlich 
          als Metamodell registriert wird.</para>

          <para />

          <para>uml2ProfileFile</para>

          <para>siehe Komponente makeGenesezModelProfile</para>

          <para />

          <para>Die anderen Parameter sind identisch mit der Komponente 
          uml2genesez.</para>

        </sect2>

      </sect1>

    </chapter>

	<xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="type.mapping.xml" />

    <chapter>

      <title>Externe Typen im Metamodell</title>

      <para>Mit dem Metamodellelement MExternal ist ein Konzept im 
      GeneSEZ-Metamodell vorhanden, welches in dieser Form nicht zur 
      UML geh&ouml;rt. Als externe Typen werden in diesem Zusammenhang im 
      Modell verwendete Typen (Klassen, Interfaces, Enumerations) 
      bezeichnet, die selbst nicht im Modell vorhanden sind. Sie 
      befinden sich stattdessen z.B. in Standard-Bibliotheken der 
      Programmiersprache oder in anderen Bibliotheken, die verwendet 
      werden sollen.</para>

      <sect1>

        <title>Definition im UML-Modell</title>

        <para>Im zugrunde liegenden UML-Modell werden externe Typen als 
        Klassen (bzw. Interfaces oder Enumerations) definiert und 
        speziell gekennzeichnet. Dazu gibt es mehrere 
        M&ouml;glichkeiten:</para>

        <para />

        <para>* Verwendung eines Stereotypes</para>

        <para>* Verwendung eines separaten Packages</para>

        <para>* Ablage des Typs direkt im Modell (der Typ hat eine 
        Containment-Beziehung zum Modell-Element und befindet sich 
        nicht in einem Package)</para>

        <para />

        <para>Die verschiedenen M&ouml;glichkeiten haben spezifische Vor- 
        und Nachteile. Die Annotation der einzelnen Klassen mit einem 
        Stereotyp ist jedoch allgemein zu bevorzugen, da hier in den 
        Modellen und verschiedenen Diagrammen die Semantik einer 
        externen Klasse am deutlichsten zum Ausdruck kommt. Beispiele 
        dazu sind weiter unten zu finden.</para>

      </sect1>

      <sect1>

        <title>Definition im Workflow</title>

        <para>Je nachdem, wie externe Typen im UML-Modell definiert 
        wurden, muss dies auch im Workflow angegeben werden. Dazu 
        werden die folgenden drei Parameter der Workflow-Komponenten 
        makeGenesezModel bzw. makeGenesezModelProfile genutzt:</para>

        <para />

        <para>* mapClassesInModelToExternal » Der Parameter kann als 
        Wert true oder false annehmen und gibt an, ob Typen, die direkt 
        im Modell abgelegt sind und somit zu keinem Package geh&ouml;ren, zu 
        externen Typen transformiert werden (true) oder normal 
        behandelt werden (false). Standardm&auml;&szlig;ig ist der Wert 
        false.</para>

        <para>* externalPackages » Als Wert für den Parameter kann eine 
        mit Komma (oder für eine bessere Lesbarkeit eine mit Komma und 
        Leerzeichen) separierte Liste mit Namen von Packages angegeben 
        werden, welche Container für externe Typen darstellen. Die 
        angegebenen Packages selbst werden ebenfalls nicht in ein 
        GeneSEZ-Package transformiert. Standardm&auml;&szlig;ig ist der Wert ein 
        leerer String.</para>

        <para>* externalStereotypes » Als Wert kann eine mit Komma 
        (oder für eine bessere Lesbarkeit eine mit Komma und 
        Leerzeichen) separierte Liste mit Namen von Stereotypen 
        angegeben werden. Diese Stereotypen k&ouml;nnen im UML-Modell sowohl 
        Typen als auch Packages zugewiesen werden. Ist einer dieser 
        Stereotypen einem Typ zugewiesen, so wird dieser in einen 
        externen Typ transformiert. Ist ein Stereotyp einem Package 
        zugewiesen, so wird dieses als Container für externe Typen 
        betrachtet und wird selbst nicht transformiert. Alle in dem 
        betreffenden Package enthaltenen Typen werden zu externen 
        Typen. Standardm&auml;&szlig;ig ist der Wert ein leerer String.</para>

      </sect1>

      <sect1>

        <title>Umgang in xPand-Templates</title>

        <para>Innerhalb von Templates ist es unwesentlich, ob ein Typ 
        ein externer Typ ist oder nicht. Diese Zuordnung wird durch das 
        GeneSEZ Type-Mapping realisiert.</para>

      </sect1>

      <sect1>

        <title>Beispiel</title>

        <para>Es folgen einige Beispiele, die den Einsatz der 
        vorgestellten M&ouml;glichkeiten zur Definition von externen Typen 
        zeigen. Wie in den Modellen deutlich wird, ist die Verwendung 
        eines Stereotypes zur Annotation von Klassen am 
        ausdrucksst&auml;rksten.</para>

        <sect2>

          <title>Verwendung eines Stereotypes zur Annotation einer 
          Klasse</title>

          <para>Zugeh&ouml;rige Parameter in der Workflow 
          Konfiguration:</para>

        </sect2>

        <sect2>

          <title>Verwendung eines Stereotypes zur Annotation eines 
          Packages</title>

          <para>Zugeh&ouml;rige Parameter in der Workflow Konfiguration 
          (identisch mit dem ersten Beispiel):</para>

        </sect2>

        <sect2>

          <title>Verwendung der Namen von Packages</title>

          <para>Zugeh&ouml;rige Parameter in der Workflow 
          Konfiguration:</para>

        </sect2>

        <sect2>

          <title>Mapping aller Klassen, die direkt im Modell enthalten 
          sind</title>

          <para>Zugeh&ouml;rige Parameter in der Workflow 
          Konfiguration:</para>

        </sect2>

      </sect1>

    </chapter>

    <chapter>

      <title>Das GeneSEZ-Logging-Konzept</title>

      <para>In diesem Artikel soll in aller Kürze das 
      GeneSEZ-Logging-Konzept-beschrieben werden. Dabei wird auf das 
      Logging in Java-Code, in Skripten und in Templates sowie auf die 
      Konfiguration eingegangen.</para>

      <para />

      <para>GeneSEZ basiert auf dem Framework openArchitectureWare, 
      welches die Logging-API des Apache Commons Logging Frameworks 
      nutzt und als Implementierung log4j verwendet. Das 
      GeneSEZ-Framework nutzt ebenfalls das Apache Commons Logging 
      Framework.</para>

      <sect1>

        <title>Java</title>

        <para>Das Logging von Java-Code aus unterscheidet sich nicht 
        von der gew&ouml;hnlichen Nutzung der Logging-API. Zuerst wird eine 
        Referenz auf ein Log-Objekt ben&ouml;tigt: Dann kann dieses 
        Log-Objekt genutzt werden, um Log-Ausgaben zu 
        realisieren:Weitere Informationen befinden sich im Manual zu 
        log4j: log4j 1.2 Manual</para>

      </sect1>

      <sect1>

        <title>Skripten + Templates</title>

        <para>Für Log-Ausgaben aus den openArchitectureWare-Artefakten 
        steht als Frontend im Common-Projekt unter dem Namespace 
        de.genesez.platforms.common.log das eXtend-Skript Log.ext zur 
        Verfügung. Die Funktionen dieses Skriptes rufen Methoden der 
        Java Klasse GenesezLogger auf, welche die Apache Commons 
        Logging-API nutzen.</para>

        <para />

        <para>Sollen Log-Ausgaben erfolgen, so sollte zuerst ein 
        benannter Logger ausgew&auml;hlt werden, damit die Ausgaben sp&auml;ter 
        im Log einem Artefakt zugeordnet werden k&ouml;nnen:</para>

        <para>Die weiteren Funktionen des Skripts dienen zum Logging 
        von Nachrichten mit dem jeweiligen Log-Level:</para>

      </sect1>

      <sect1>

        <title>Konfiguration</title>

        <para>Zur Konfiguration der verwendeten Implementierung log4j 
        hat openArchitectureWare bereits standardm&auml;&szlig;ig die Datei 
        log4j.properties im Classpath, die dementsprechend auch 
        standardm&auml;&szlig;ig genutzt wird. Das GeneSEZ-Framework stellt 
        ebenfalls eine log4j.properties im Namespace 
        de.genesez.platforms.common.log bereit. log4j sucht den 
        kompletten Classpath nach dieser Datei ab und nutzt die erste 
        Datei dieses Namens, die gefunden wird. Daher wird i.d.R. die 
        von openArchitectureWare genutzt, da diese im Classpath eher 
        gefunden wird.</para>

        <para />

        <para>Soll die Log-Konfiguration angepasst werden, so kann die 
        vom GeneSEZ-Framework bereitgestellte als Vorlage genutzt 
        werden. Dazu wird diese in das Konfigurationsverzeichnis des 
        aktuellen Generator-Projekts kopiert (siehe GeneSEZ 
        Projektstruktur).</para>

        <para />

        <para>Zur detaillierten Erkl&auml;rung der Inhalte der 
        Konfigurationsdatei sei auf das log4j Manual verwiesen: log4j 
        1.2 Manual</para>

      </sect1>

    </chapter>

    <chapter>

      <title>GeneSEZ UML Profil</title>

      <para>Um Konzepte des GeneSEZ-Metamodells in UML zu modellieren 
      sowie nützliche und fachlich relevante Informationen zur 
      Umsetzung im Modell zu hinterlegen, wurde ein GeneSEZ-UML-Profil 
      eingeführt. Dieses ist prinzipiell plattformunabh&auml;ngig, jedoch 
      müssen nicht alle Aspekte, die das UML-Profil enth&auml;lt, auch von 
      den plattform-spezifischen Template-Sets ausgewertet 
      werden.</para>

      <para />

      <para>Welche Aspekte die plattformspezifischen Templates 
      unterstützen, ist in der Dokumentation zu den jeweiligen 
      Plattformen zu finden.</para>

      <para />

      <para>source:trunk/de.genesez.docs/GeneSezProfile/genesez.profile.png</para>

      <para>Folgend werden die einzelnen Stereotypen und ihre Bedeutung 
      n&auml;her erl&auml;utert.</para>

    </chapter>

  </part>

</book>

