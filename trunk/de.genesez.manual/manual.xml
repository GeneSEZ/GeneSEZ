<?xml version='1.0'?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" "http://www.oasis-open.org/docbook/xml/4.0/docbookx.dtd">
<book>

  <title>Das GeneSEZ Generator Framework</title>

  <part>

    <title>Getting Started</title>

    <chapter>

      <title>Der GeneSEZ-Ansatz</title>

      <para>In diesem Artikel sollen die Hintergründe für die 
      Entstehung des GeneSEZ-Frameworks näher beschrieben werden. Dazu 
      werden kurz die modellgetriebene Softwareentwicklung sowie einige 
      Herausforderungen, denen sich diese Art der Softwareentwicklung 
      gegenübersieht, aufgezeigt. Davon ausgehend wird dann der 
      GeneSEZ-Ansatz vorgestellt, der einigen dieser Herausforderungen 
      begegnen soll.</para>

      <sect1>

        <title>Modellgetriebene Softwareentwicklung</title>

        <para>Die modellgetriebene Softwareentwicklung (kurz MDSD für 
        engl. model driven software development) beschäftigt sich 
        allgemein mit der Generierung von Quellcode einer Software aus 
        formalen Modellen.</para>

        <para>Dabei dienen Modelle nicht mehr nur als Dokumentation 
        oder Visualisierung von Realisierungsproblemen einer Software, 
        sondern rücken selbst in den Mittelpunkt der 
        Softwareentwicklung. Dass es sich um formale Modelle handeln 
        muss, ergibt sich daraus, dass sie automatisch in Quellcode 
        transformiert werden sollen. Die Formalität wird dabei durch 
        die Verwendung eines Metamodells gewährleistet.</para>

        <para>Als Ziele der MDSD werden meist die Wiederverwendung von 
        Architekturen, die gleichbleibend hohe Qualität des Quellcodes 
        sowie die Steigerung der Entwicklungsgeschwindigkeit 
        genannt.</para>

      </sect1>

      <sect1>

        <title>Herausforderungen und Hindernisse der MDSD</title>

        <sect2>

          <title>Wahl des Metamodells</title>

          <para>Wie bereits erwähnt, bildet die Grundlage der MDSD ein 
          Metamodell, welchem die Modelle der zu entwickelnden 
          Applikation genügen. Basierend auf diesem Metamodell werden 
          die Transformationen zur Generierung von Quellcode 
          entwickelt.</para>

          <para>Eine zentrale Herausforderung ist dabei die Wahl des 
          Metamodells. Hier werden meist entweder domänenspezifische 
          Sprachen (sog. DSL für engl. domain specific language) oder 
          die Unified Modeling Language (UML) eingesetzt. DSLs sind 
          speziell für einen bestimmten Anwendungs- bzw. Problembereich 
          geeignet. Sie besitzen eine sehr präzise Ausdrucksweise mit 
          der Semantik des Problembereichs und sind deshalb auch auf 
          diesen beschränkt. Häufig sind DSLs nicht standardisiert, 
          wodurch die Kommunikation zwischen Entwicklern leiden kann, 
          da jeder Entwickler erst diese spezielle Sprache erlernen 
          muss. Werden DSLs durch die Entwickler selbst definiert, so 
          müssen diese auch in einem Entwicklungsprozess mit gepflegt 
          werden.</para>

          <para>Die UML dagegen ist ein Standard zur Modellierung von 
          Software, der von der OMG spezifiziert wurde. Sie ist 
          allgemeingültig und unter Entwicklern i.d.R. bereits bekannt. 
          Ein wesentlicher Nachteil der UML ist die Komplexität und die 
          fehlende Referenzimplementierung. Jedoch existiert mit dem 
          Eclipse-UML2-Projekt eine Implementierung der UML, die einige 
          Toolhersteller nutzen bzw. durch eine Export-Funktionalität 
          unterstützen, wodurch sich dieses Projekt de facto zu einer 
          Referenzimplementierung entwickelt.</para>

        </sect2>

        <sect2>

          <title>MDSD-Entwicklungsprozess</title>

          <para>Im Vergleich zur herkömmlichen Softwareentwicklung 
          kommen bei modellgetriebener Softwareentwicklung einige 
          weitere Tools zum Einsatz. Dazu gehört eine Software zur 
          Erstellung der Modelle.</para>

          <para>Weiterhin erfordert ein MDSD-Entwicklungsprozess:</para>

          <para />

          <para>* Modellvalidierungen zur Überprüfung der Modelle</para>

          <para>* Modellmodifikationen, um kleine Änderungen an 
          Modellen durchführen zu können</para>

          <para>* Modell-zu-Modell-Transformationen</para>

          <para>* Modell-zu-Text-Transformationen</para>

          <para />

          <para>Die Softwarebausteine zur Unterstützung der genannten 
          Aufgaben müssen gut zusammenarbeiten. Aktualisierungen 
          einzelner Bestandteile können sich hinderlich auf die 
          Zusammenarbeit auswirken. Im Zusammenhang mit diesen 
          aufeinander aufbauenden Aufgaben und Werkzeugen wird auch oft 
          von der so genannten &quot;Tool-Chain&quot; (dt. 
          Werkzeugkette).</para>

        </sect2>

        <sect2>

          <title>Wiederverwendung</title>

          <para>In einem MDSD-Entwicklungsprozess kommen verschiedene 
          Quellcode-Artefakte zum Einsatz. Einen wesentlichen Teil 
          bilden dabei die Templates für 
          Modell-zu-Text-Transformationen, aber auch Skripte für 
          Modell-Modifikationen, Modell-zu-Modell-Transformationen und 
          Hilfsfunktionen. Mit Hilfe dieser Artefakte wird der 
          Infrastruktur-Quellcode generiert, der anschließend fertig 
          implementiert werden muss. Da die Erstellung dieser Artefakte 
          eine nicht zu vernachlässigende Zeit in Anspruch nimmt, 
          sollten diese Artefakte in einem MDSD-Entwicklungsprozess so 
          oft wie möglich wiederverwendet werden.</para>

          <para />

          <para>All genannten Artefakte sind von dem verwendeten 
          Metamodell abhängig. Kommt hierbei die UML zum Einsatz, wird 
          die Auswertung der Modellinformationen durch die Komplexität 
          und hochgradige Normalisierung erschwert. 
          Modellmodifikationen und Modell-zu-Modell-Transformationen 
          sind nur mit sehr viel Aufwand realisierbar. Modelle 
          domainspezifischer Sprachen sind auf der anderen Seite 
          aufgrund ihrer Beschränkung auf einen Problembereich leichter 
          auswertbar. Modellmodifikationen und 
          Modell-zu-Modell-Transformationen sind durch den beschränkten 
          Umfang ebenfalls realisierbar. Problematisch kann allerdings 
          die Zukunftssicherheit der DSL sein. Ein Problem entsteht 
          beispielsweise, wenn Software für einen anderen 
          Anwendungsbereich entwickelt werden muss, welche die DSL 
          bisher nicht abdeckt.</para>

        </sect2>

      </sect1>

      <sect1>

        <title>GeneSEZ-Ansatz</title>

        <para>Das wesentliche Alleinstellungsmerkmal des 
        GeneSEZ-Ansatzes für modellgetriebene Softwareentwicklung ist 
        das GeneSEZ-Metamodell. Dabei handelt es sich um ein 
        allgemeingültiges Metamodell, welches die Basis des 
        Entwicklungsprozesses bildet. Dadurch wird die bereits 
        angesprochene Wiederverwendung der Artefakte des 
        Entwicklungsprozesses sicher gestellt sowie eine Entkopplung 
        von der verwendeten Modellierungssoftware erreicht.</para>

        <sect2>

          <title>GeneSEZ-Metamodell</title>

          <para>Das GeneSEZ-Metamodell kann weitgehend als 
          domainspezifisches Modell aufgefasst werden, wobei die Domain 
          hier die Generierung von Quellcode selbst ist. Es ist ein 
          allgemeingültiges Metamodell und ist dadurch der UML sehr 
          ähnlich. Allerdings ist es sehr viel einfacher strukturiert, 
          um die Zugriffe auf Modellinformationen zu vereinfachen. Dazu 
          gehören kurze Navigationspfade sowie keine unnötigen 
          abstrakten Elemente, die bei normalisierten Modellen 
          enthalten wären.</para>

          <para />

          <para>Durch diese Vorgehensweise werden dem 
          Template-Entwickler die Modellinformationen in sinnvoller 
          Weise präsentiert und die einfache Erstellung von 
          Modellmodifikationen sowie Modell-zu-Modell-Transformationen 
          wird ermöglicht.</para>

        </sect2>

        <sect2>

          <title>Modell-Adapter</title>

          <para>Durch die feste Verankerung eines Metamodells im 
          MDSD-Entwicklungsprozess stellt sich natürlich die Frage, wie 
          darauf aufbauende Modelle erstellt werden können. Es kan 
          schließlich kaum erwartet werden, dass Modellierer nur wegen 
          der Nutzung des GeneSEZ-Ansatzes ihre bereits seit langer 
          Zeit genutzte Modellierungssoftware aufgeben. Deshalb wurde 
          das Konzept der Modelladapter eingeführt, die ein auf einem 
          anderem Metamodell beruhendes Modell in ein 
          GeneSEZ-Metamodell-basiertes Modell überführen können.</para>

          <para />

          <para>Obwohl der GeneSEZ-Ansatz kein Ausgangs-Metamodell 
          vorschreibt und somit jeder Anwender sein präferiertes 
          Metamodell zur Erstellung der Modelle nutzen kann, wird 
          jedoch der Einsatz der UML empfohlen. Diese ist weit 
          verbreitet, standardisiert und vielen Entwicklern bereits 
          bekannt. Durch die wohldefinierte Semantik der 
          UML-Modellelemente ist ein einheitliches Verständnis des 
          Modells bei Entwicklern gegeben. Modelle auf Basis der 
          Eclipse-UML2-Implementierung werden durch das 
          GeneSEZ-Framework &quot;out-of-the-box&quot; 
          unterstützt.</para>

          <para />

          <para>DSLs hingegen müssen von jedem Entwickler erst erlernt 
          werden, wodurch ein einheitliches Grundverständnis der DSL 
          nicht ohne Weiteres gegeben ist. Jedoch werden auch DSLs 
          durch den GeneSEZ-Ansatz unterstützt. Ist die DSL auf Basis 
          der UML definiert so wird diese &quot;out-of-the-box&quot; 
          unterstützt. Andere DSLs können aufgrund deren zahlreichen 
          Ausprägungen und vielfältigen Definitionsmöglichkeiten nicht 
          &quot;out-of-the-box&quot; unterstützt werden. Für solche 
          DSLs ist die Erstellung eines Modelladapters erforderlich, 
          der das domainspezifische Modell in ein GeneSEZ-Modell 
          transformiert.</para>

        </sect2>

        <sect2>

          <title>GeneSEZ-Tooling</title>

          <para>Das GeneSEZ-Framework basiert ausschließlich auf 
          Open-Source-Software. Ein wesentlicher Bestandteil ist das 
          Generator-Framework openArchitectureWare. Das 
          GeneSEZ-Framwork besteht aus dem GeneSEZ-Metamodell, einigen 
          weiteren Komponenten sowie den Artefakten zur 
          Quellcodegenerierung.</para>

        </sect2>

      </sect1>

      <sect1>

        <title>Abschlussbemerkungen</title>

        <para>Wesentlich für einen MDSD-Entwicklungsprozess ist das in 
        ihm verankerte Metamodell. Der Stellenwert des Metamodells ist 
        somit relativ hoch. Die Artefakte, die in einem 
        Entwicklungsprozess genutzt werden, basieren ebenfalls auf dem 
        Metamodell. Die Erstellung der Artefakte des GeneSEZ-Frameworks 
        hat eine nicht unwesentliche Zeit in Anspruch genommen. Der 
        Umfang des Metamodells ist verglichen mit denen der Artefakte 
        relativ kompakt. Daher sollte der Umfang der Artefakte in einem 
        Entwicklungsprozess nicht unterschätzt werden.</para>

        <para />

        <para>Im folgenden Bild ist beispielhaft ein möglicher 
        modellgetriebener Entwicklungsprozess auf Basis des 
        GeneSEZ-Frameworks abgebildet:</para>

      </sect1>

    </chapter>

    <chapter>

      <title>Installation von GeneSEZ</title>

      <para>In diesem How-To soll beschrieben werden, wie das 
      GeneSEZ-Framework installiert werden kann. Das GeneSEZ-Framework 
      ist derzeit als Eclipse-Plug-In verfügbar.</para>

      <sect1>

        <title>GeneSEZ</title>

        <para>Version: 1.6.x</para>

        <para />

        <para>* Abhängigkeiten: Eclipse SDK, openArchitectureWare, EMF, 
        UML2</para>

        <para>* Homepage: http://genesez.de/</para>

        <para>* Update-Site: 
        http://genesez.de/updatesite/site.xml</para>

        <para>* benötigte Features:</para>

        <para>o Identifier: de.genesez.feature.feature.group » GeneSEZ 
        Framework</para>

      </sect1>

      <sect1>

        <title>Benötigte Eclipse-Plug-Ins</title>

        <para>Das GeneSEZ-Framework basiert auf openArchitectureWare 
        und setzt demnach die folgenden Eclipse-Plug-Ins voraus. 
        Hinweis: Es sind jeweils nur die notwendigen Features der 
        einzelnen Plug-Ins gelistet. Bei Bedarf können natürlich auch 
        weitere Features installiert werden.</para>

        <sect2>

          <title>Eclipse SDK</title>

          <para>Version: 3.3.x</para>

          <para />

          <para>* Update-Site: 
          http://download.eclipse.org/eclipse/updates/3.3/</para>

          <para>* z.B. die Eclipse Classic IDE</para>

          <para />

          <para>Version: 3.4.x</para>

          <para />

          <para>* Update-Site: 
          http://download.eclipse.org/eclipse/updates/3.4/</para>

          <para>* z.B. Feature:</para>

          <para>o Identifier: org.eclipse.sdk.ide&apos; » Eclipse 
          Classic SDK</para>

        </sect2>

        <sect2>

          <title>openArchitectureWare</title>

          <para>Version: 4.3.x</para>

          <para />

          <para>* Abhängigkeiten: EMF, UML2</para>

          <para>* Homepage: http://openarchitectureware.org/, 
          http://www.eclipse.org/gmt/oaw/</para>

          <para>* Update-Site: 
          http://www.openarchitectureware.org/updatesite/milestone/</para>

          <para>* benötigte Features:</para>

          <para>o Identifier: 
          org.openarchitectureware.lib.feature.feature.group » 
          openArchitectureWare libraries</para>

          <para>o Identifier: 
          org.openarchitectureware.core.feature.feature.group » 
          openArchitectureWare core</para>

          <para>o Identifier: 
          org.openarchitectureware.plugins.feature.feature.group » 
          openArchitectureWare plugins</para>

          <para>o Identifier: 
          org.openarchitectureware.uml2.adapter.feature.group » 
          openArchitectureWare uml2 adapter</para>

        </sect2>

        <sect2>

          <title>EMF</title>

          <para>Version: 2.3.x</para>

          <para />

          <para>* Homepage: http://www.eclipse.org/modeling/emf/</para>

          <para>* Update-Site: 
          http://download.eclipse.org/modeling/emf/updates/releases/</para>

          <para>* benötigte Features:</para>

          <para>o Identifier: org.eclipse.emf.feature.group » Eclipse 
          Modeling Framework (EMF) Runtime + End-User Tools</para>

        </sect2>

        <sect2>

          <title>UML2</title>

          <para>Version: 2.1.x</para>

          <para />

          <para>* Abhängigkeiten: EMF</para>

          <para>* Homepage: 
          http://www.eclipse.org/modeling/mdt/?project=uml2</para>

          <para>* Update-Site: 
          http://download.eclipse.org/modeling/mdt/updates/releases/</para>

          <para>* benötigte Features:</para>

          <para>o Identifier: org.eclipse.uml2.feature.group » UML2 
          End-User Features</para>

          <para />

          <para>Das GeneSEZ-Framework läuft sowohl unter Eclipse 3.3 
          als auch unter Eclipse 3.4. Unter Eclipse 3.4 müssen 
          allerdings die oben aufgeführten älteren Versionen von EMF 
          und UML2 installiert werden, da die neueren noch nicht von 
          openArchitectureWare und GeneSEZ unterstützt werden.</para>

        </sect2>

      </sect1>

      <sect1>

        <title>Benutzer-Installation</title>

        <para>Mit Eclipse 3.4 wurde auch ein neuer Update-Manager 
        namens p2 eingeführt. Daher wird in den folgenden 
        Beschreibungen unterschieden zwischen dem Update-Manager, der 
        bis Eclipse 3.3 für Updates zuständig war, und p2, der 
        standardmäßig ab Eclipse 3.4 als Update-Manager bereit steht. 
        Die Verwendung von p2 ist aber auch in Eclipse 3.4 nicht 
        zwingend, so dass auch unter Eclipse 3.4 der bisherige 
        Update-Manager genutzt werden kann.</para>

        <sect2>

          <title>Update Manager (standardmäßig bis Eclipse 3.3)</title>

          <para>Die einfachste Möglichkeit der Installation ist die 
          Nutzung des Eclipse Update Manager. Dazu Help » Software 
          Updates » Find and Install... anklicken. Danach Search for 
          new features to install auswählen und next klicken.</para>

          <para />

          <para>Nun müssen die oben gelisteten Update-URLs von GeneSEZ, 
          openArchitectureWare, EMF und UML2 hinzugefügt werden, sofern 
          sie noch nicht existieren (Der Update-Manager verhindert aber 
          auch das doppelte Einfügen der gleichen URL.). Dazu auf New 
          Remote Site... klicken, einen sinnvollen Namen eingeben (z.B. 
          den des Plug-Ins) sowie die Update-URL. Dann auf OK 
          klicken.</para>

          <para>Sind die vier URLs angelegt, diese (und um 
          Seiteneffekte zu verhindern, nur diese) auswählen und auf 
          Finish klicken.</para>

          <para>Wenn die Aufforderung erscheint, einen Mirror zu 
          wählen, kann ein beliebiger Mirror gewählt werden. Dies hat 
          in der Regel nur Auswirkungen auf die 
          Download-Geschwindigkeit. Dann werden die installierbaren 
          Features angezeigt. Hier muss auf die Versionen geachtet 
          werden. Ggf. muss das Häkchen aus Show the latest version of 
          a feature only entfernt werden, um eine ältere Version zu 
          installieren.</para>

          <para>Nun müssen alle Features, die installiert werden 
          sollen, ausgewählt werden. Am besten in folgender 
          Reihenfolge, um unnötige Fehlermeldungen des Update-Managers 
          zu vermeiden, die darauf hinweisen, dass referenzierte 
          Plug-Ins noch nicht installiert sind:</para>

          <para />

          <para>* EMF Runtime + End-User Tools</para>

          <para>* UML2 End-User Features</para>

          <para>* openArchitectureWare Library feature</para>

          <para>* openArchitectureWare core Feature</para>

          <para>* openArchitectureWare core plugins Feature</para>

          <para>* openArchitectureWare UML2 Adapter Feature</para>

          <para>* GeneSEZ Framework</para>

          <para>Sind alle benötigten Features ausgewählt, kann auf Next 
          geklickt werden. Dann müssen die Lizenzen bestätigt werden, 
          in dem I accept the terms in the license agreements 
          angeklickt wird. Dann kann auf Next geklickt werden.</para>

          <para />

          <para>Nun kann ausgewählt werden, in welches Verzeichnis die 
          Plug-Ins installiert werden sollen. Standardmäßig ist dies 
          das Verzeichnis von Eclipse. Soll dieses verwendet werden, 
          einfach auf Finish klicken. Alternativ kann hier auch eine 
          sogenannte Extension Location angelegt werden und für jedes 
          Plug-In individuell der Speicherort festgelegt werden. Soll 
          eine Extension Location verwendet werden, einfach alle 
          Plug-Ins in der Liste markieren (auch mit Strg+A möglich) und 
          dann auf Change Location ... klicken. Im sich dann öffnenden 
          Dialog auf Add Location... klicken und einen Ordner im 
          Dateisystem wählen. Dann auf OK klicken. Nun kann diese 
          Extension Location ausgewählt werden und mit OK bestätigt 
          werden. Dann kann mit Finish die Installation gestartet 
          werden.</para>

          <para>Nun werden die Plug-Ins von den Webseiten geladen. Vor 
          der Installation fragt der Update-Manager noch nach einer 
          Feature Verification. Hier kann einfach Install All gewählt 
          werden, um die Installation der nicht signierten Plug-Ins zu 
          bestätigen. Zum Schluss muss noch mit Klick auf Yes der 
          Neustart von Eclipse bestätigt werden.</para>

          <para />

          <para>Nach dem Neustart kann mit Klick auf Help » Software 
          Updates » Manage Configuration eine Übersicht der 
          installierten Plug-Ins angezeigt werden. Hier sollten die 
          soeben installierten Plug-Ins ohne Fehler aufgelistet 
          sein.</para>

        </sect2>

        <sect2>

          <title>p2 (ab Eclipse 3.4)</title>

          <para>Das User Interface des p2 innerhalb von Eclipse ist 
          ähnlich dem älteren Update Manager. Daher wird momentan an 
          dieser Stelle noch auf die Anleitung für den älteren Update 
          Manager verwiesen: Update Manager, Eclipse 3.3</para>

          <para />

          <para>Ein wesentlicher Unterschied ist, dass bei p2 keine 
          Extension Locations mehr spezifiziert werden können, in 
          welche die Plug-Ins installiert werden sollen. Die Plug-Ins 
          werden automatisch im Eclipse-Verzeichnis bzw. im genutzten 
          Bundle-Pool-Verzeichnis installiert.</para>

        </sect2>

        <sect2 />

      </sect1>

      <sect1>

        <title>Entwickler-Installation</title>

        <para>Der Quellcode des GeneSEZ-Frameworkss steht im 
        GeneSEZ-Repository zum Auschecken bereit.</para>

        <sect2>

          <title>GeneSEZ-Repository</title>

          <para>Der Zugriff auf das GeneSEZ-Repository ist erläutert 
          unter: GeneSEZ Source Control Management</para>

        </sect2>

        <sect2>

          <title>GeneSEZ-Plug-In-Projekte</title>

          <para>Das GeneSEZ Framework besteht aus einem Set von 
          Eclipse-Projekten. Die folgenden Projekte sind für die 
          Benutzung des GeneSEZ-Frameworks auf Basis des Quellcodes 
          erforderlich:</para>

          <para />

          <para>* de.genesez.build » enthält ANT-Build-Skripte, die von 
          den anderen Projekten referenziert werden</para>

          <para>* de.genesez.metamodel » enthält das 
          GeneSEZ-Metamodel</para>

          <para>* de.genesez.platforms.common » enthält 
          allgemeingültige Komponenten und Skripte, die von den anderen 
          Projekten genutzt werden</para>

          <para />

          <para>Weiterhin ist für die Benutzung des GeneSEZ-Frameworks 
          auf Basis des Quellcodes noch mindestens eines der folgenden 
          Plattformprojekte erforderlich, je nachdem für welche 
          Plattform Quellcode generiert werden soll:</para>

          <para />

          <para>* de.genesez.platforms.java » notwendig um 
          Java-Quellcode zu generieren</para>

          <para>* de.genesez.platforms.dotnet » notwendig um 
          C#-Quellcode zu generieren</para>

          <para>* de.genesez.platforms.php » notwendig um PHP-Quellcode 
          zu generieren</para>

          <para />

          <para>Die folgenden beiden Projekte sind notwendig, um die 
          Eclipse-Plugins für das GeneSEZ-Framework zu erstellen und 
          auf der Update-Seite zu publizieren:</para>

          <para />

          <para>* de.genesez.features</para>

          <para>* de.genesez.updatesite</para>

        </sect2>

        <sect2>

          <title>GeneSEZ-Setup</title>

          <para>Bevor das GeneSEZ-Framework genutzt werden kann, muss 
          noch eine Konfiguration erfolgen, die Plug-In-Projekte müssen 
          versioniert werden und die Implementierung des 
          GeneSEZ-Metamodells erstellt werden.</para>

          <para />

          <para>Um die Konfiguration zu erstellen, muss im Projekt 
          de.genesez.build im Ordner build die Datei 
          environment.properties angelegt werden. Hierzu kann die Datei 
          environment.properties.template als Vorlage genutzt werden, 
          welche sich bereits im selben Verzeichnis befindet.</para>

          <para />

          <para>Die GeneSEZ-Build-Skripte nutzen einen automatisierten 
          Mechanismus, um alle GeneSEZ-Projekte zu versionieren. Hierzu 
          ist in den zu versionierenden Dateien ein spezieller 
          Platzhalter vorhanden, der u.a. Eclipse daran hindert, 
          Plug-In-Referenzen aufzulösen, weshalb die Projekte auch noch 
          ziemlich viele Fehler aufweisen sollten.</para>

          <para />

          <para>Um die Projekte zu versionieren, muss das Build-Target 
          tag.all des Build-Skripts build.xml, welches sich im 
          Root-Verzeichnis des Projekts de.genesez.build befindet, 
          ausgeführt werden. Sind nicht alle zu versionierenden 
          Projekte ausgecheckt, so sollten die Projekte, die nicht 
          ausgecheckt sind, vorher in der Datei release.properties, 
          welche sich im build-Order des Build-Projektes befindet, 
          auskommentiert werden.</para>

          <para>Nun kann die Generierung der Implementierung des 
          GeneSEZ-Metamodells erfolgen. Dazu muss einfach das 
          Build-Skript build.xml im build-Ordner des 
          Metamodell-Projektes de.genesez.metamodel ausgeführt werden. 
          Zum Ausführen den Menüpunkt Run As » Ant Build... wählen und 
          im Tab JRE den Punkt Run in same JRE as the workspace 
          wählen.</para>

          <para />

          <para>Nachdem die Metamodell-Implementierung generiert wurde, 
          sollte sich das GeneSEZ-Framework genauso nutzen lassen, wie 
          wenn die Plug-Ins installiert worden wären.</para>

        </sect2>

      </sect1>

    </chapter>

    <chapter>

      <title>GeneSEZ: Just Try It Out</title>

      <para>Dieser Artikel verdeutlicht die Funktionweise und Anwendung 
      des GeneSEZ-Frameworks an einem kleinen Beispiel. Dazu wird ein 
      Projekt aus dem GeneSEZ-Repository ausgecheckt, die 
      Projektstruktur erläutert und ein vorhandenes UML-Modell in 
      Quellcode transformiert.</para>

      <sect1>

        <title>Checkout Beispielprojekt</title>

        <para>Um das Beispielprojekt aus dem GeneSEZ-Repository 
        auszuchecken, muss zuerst die GeneSEZ-Repository Location 
        konfiguriert werden. Dies wird genauer unter GeneSEZ Source 
        Control Management beschrieben.</para>

        <para />

        <para>Anschließend kann das Beispielprojekt 
        de.genesez.example.java.forms sowie das zugehörige 
        Generatorprojekt de.genesez.example.java.forms.generator 
        ausgecheckt werden.</para>

      </sect1>

      <sect1>

        <title>Projektstruktur</title>

        <para>Für ein Softwareprojekt wird eine Aufteilung in 
        mindestens zwei Projekte vorgeschlagen. Dies ist zum Einen ein 
        so genanntes Generatorprojekt, welches Konfigurationen, 
        Bibliotheken und weitere spezifische Artefakte für den 
        modellgetriebenen Entwicklungsprozess beinhaltet. Neben diesem 
        existiert mindestens noch ein weiteres Projekt welches den 
        anwendungsspezifischen Quellcode beinhaltet. Durch diese 
        Aufteilung sind in jedem Projekt nur die Artefakte enthalten, 
        die für das jeweilige Projekt relevant sind.</para>

        <sect2>

          <title>Generatorprojekt</title>

          <para>Das Generatorprojekt ist ein 
          openArchitectureWare-Projekt, welches wiederum ein 
          Eclipse-Plug-In-Projekt ist. Dadurch können die benötigten 
          Bibliotheken für den Generator einfach als Eclipse-Plug-Ins 
          referenziert werden. Neben den spezifischen Verzeichnissen 
          und Dateien von Eclipse-Plug-In-Projekten existieren die 
          folgenden Verzeichnisse:</para>

          <para />

          <para>* config</para>

          <para>* model-exp</para>

          <para>* model-gen</para>

          <para />

          <para>Das Verzeichnis config enthält den Workflow, welcher 
          die einzelnen Schritte beschreibt, die notwendig sind, um ein 
          Modell in Quellcode zu transformieren. Weiterhin kann 
          optional noch die Datei log4j.properties enthalten sein, 
          welche das von GeneSEZ und openArchitectureWare genutzte 
          Logging-Framework Log4J konfiguriert.</para>

          <para />

          <para>Im Verzeichnis model-exp befindet sich das Modell der 
          Anwendung im XMI-Format des Eclipse UML2-Projektes. Im Falle 
          des Beispielprojektes wurde das Modell mit dem 
          Modellierungswerkzeug Magic Draw erstellt und als Eclipse 
          UML2-Modell exportiert. Daraus ergibt sich auch der Name des 
          Verzeichnisses model-exp, der für &quot;exportiertes 
          Modell&quot; steht. Dieses Modell dient als Ausgangspunkt der 
          Codegenerierung.</para>

          <para />

          <para>Der Ordner model-gen enthält ein serialisiertes 
          GeneSEZ-Modell, welches durch den Workflow erzeugt wurde. 
          Sich dieses Modell einmal näher anzusehen, kann z.B. nützlich 
          sein, um zu überprüfen, ob Modellmodifikationen korrekt 
          funktionieren. Die XMI-Datei kann mit Hilfe des Sample 
          Reflective Ecore Model Editor geöffnet werden. Dieser stellt 
          das Modell in einer Baumstruktur dar, ähnlich wie der UML 
          Model Editor für Eclipse UML2-Modelle.</para>

          <para />

          <para>Weiterhin können sich noch weitere Dateien und 
          Verzeichnisse wie z.B. projektspezifische 
          Type-Mapping-Dateien und Artefakte für die Anpassung des 
          Generators im Generator-Projekt befinden.</para>

        </sect2>

        <sect2>

          <title>Anwendungsprojekt</title>

          <para>Bei größeren Projekten ist es sinnvoll, mehrere 
          Anwendungsprojekte zu erstellen (z.B. wenn neben einer 
          Desktopoberfläche eine Weboberfläche entwickelt wird). 
          Ansonsten ist ein Anwendungsprojekt in der Regel ausreichend. 
          Das Anwendungsprojekt kann ein Eclipse-Projekt der 
          entsprechenden Zielplattform sein: ein Java-Projekt, ein 
          PHP-Projekt oder ein Web-Projekt (je nachdem, welche 
          Eclipse-Nature am besten geeignet ist). Es kann sich aber 
          genauso gut um ein Projekt einer anderen Entwicklungsumgebung 
          handeln (z.B. ein Visual Studio-Projekt für die 
          C#-Entwicklung). Für den modellgetriebenen 
          Entwicklungsprozess an sich ist lediglich ein Verzeichnis im 
          Dateisystem notwendig (siehe unten), jedoch sollte dies 
          sinnvoll in einer Projektstruktur eingegliedert sein.</para>

          <para />

          <para>Die Verzeichnisstruktur ist sehr vom verwendeten 
          Projekt abhängig. Deshalb werden hier nur die wichtigsten 
          Verzeichnisse kurz vorgestellt. Im Falle des 
          Beispielprojektes handelt es sich um ein Java-Projekt, das 
          die folgenden Verzeichnisse enthält:</para>

          <para />

          <para>* src</para>

          <para>* src-gen</para>

          <para>* lib</para>

          <para>* model</para>

          <para />

          <para>Die Verzeichnisse src und src-gen enhalten den 
          Quellcode des Projektes. Der generierte Quellcode befindet 
          sich dabei im Verzeichnis src-gen und der manuell erstellte 
          in src.</para>

          <para />

          <para>Im lib-Verzeichnis sind die Bibliotheken für das 
          Projekt enthalten. Im Beispielprojekt ist hier die Bibliothek 
          zum Assoziations-Handling enthalten.</para>

          <para />

          <para>Der model-Ordner enthält das Modell, welches mit der 
          eingesetzten Modelliersoftware erstellt wurde. Dieses Modell 
          ist dem Anwendungsprojekt zugeordnet, da aus diesem Modell 
          Teile des Quellcodes automatisch erzeugt werden, wodurch das 
          Modell selbst zum Quellcode wird.</para>

        </sect2>

      </sect1>

      <sect1>

        <title>Ausführen des Workflows</title>

        <sect2>

          <title>Hinweis GeneSEZ Version 1.6.0</title>

          <para>Durch einen Bug im GeneSEZ-Plug-In müssen bei Version 
          1.6.0 im Beispiel-Generator-Projekt noch folgende 
          Plug-In-Abhängigkeiten und -Bibliotheken hinzugefügt 
          werden:</para>

          <para />

          <para>* openArchitectureWare UML2 Adapter</para>

          <para>* GeneSEZ Metamodell</para>

          <para>* dom4j Bibliothek</para>

          <para />

          <para>Dazu im Ordner META-INF die Datei MANIFEST.MF öffnen 
          und im Tab Dependencies unter Required Plug-Ins die beiden 
          Plug-Ins de.genesez.metamodel und 
          org.openarchitectureware.uml2.adapter hinzufügen. Die 
          Bibliothek dom4j.jar wird über den Build Path hinzugefügt: 
          Rechtsklick auf das Projekt und » Build Path » Configure 
          Build Path... wählen und dann im Tab Libraries auf Add 
          External JARs... klicken. Nun kann die Datei dom4j-1.6.1.jar 
          aus dem GeneSEZ-Plug-In-Verzeichnis gewählt werden (z.B. 
          ...\eclipse-extensions\genesez\eclipse\plugins\de.genesez.platforms.common_1.6.0).</para>

          <para />

          <para>Um den Workflow zu starten, einfach Rechtsklick auf die 
          Datei workflow.oaw im Verzeichnis config und Run As » oAW 
          Workflow wählen. In der Konsole sollte bei erfolgreicher 
          Ausführung in den letzten Zeilen die folgende Ausgabe 
          erscheinen:</para>

          <para>Im Verzeichnis src-gen des Anwendungsprojektes sollte 
          nun der aktuelle generierte Quellcode vorhanden sein.</para>

        </sect2>

      </sect1>

      <sect1>

        <title>Workflow Details</title>

        <para>Der Workflow kann mit einem Doppelklick geöffnet werden. 
        Die Definition des Workflows ist ähnlich der von 
        ANT-Build-Skripten. In der ersten Hälfte sind Properties 
        definiert. Dies sind projektspezifische Einstellungen wie Pfad 
        und Dateiname des Modells sowie Standardwerte für die Workflow 
        Komponenten. In der zweiten Hälfte des Workflows sind die 
        Workflowkomponenten definiert, die die Transformationsschritte 
        vom Modell bis zum Quellcode definieren:</para>

        <para />

        <para>1. Die erste Workflowkomponente liest ein UML2-Modell 
        ein, validiert es und transformiert es in ein 
        GeneSEZ-Modell</para>

        <para>2. Danach wird das GeneSEZ-Modell mit allgemeinen Regeln 
        auf Korrektheit überprüft</para>

        <para>3. Als drittes wird das GeneSEZ-Modell auf 
        Java-Konformität überprüft</para>

        <para>4. Die vierte Workflowkomponente serialisiert das 
        GeneSEZ-Modell in eine Datei</para>

        <para>5. Als letztes wird das GeneSEZ-Modell mit Hilfe der 
        Java-Templates in Java-Quellcode transformiert</para>

        <para />

        <para>Die Parameter der einzelnen Workflow Komponenten sind in 
        der Workflow-Referenz erklärt: GeneSEZ Workflow Referenz.</para>

      </sect1>

      <sect1>

        <title>Generierter Quellcode</title>

        <para>Wesentlich für die Akzeptanz der MDSD ist, dass der 
        generierte Quellcode den Coding-Guidelines der Entwickler 
        entspricht. Um dies zu erreichen, stehen mehrere Möglichkeiten 
        bereit.</para>

        <para />

        <para>Die Workflowkomponente zur Durchführung einer 
        Modell-zu-Text-Transformation stellt Parameter bereit, um das 
        Aussehen des generierten Quellcodes zu beeinflussen. Dazu wird 
        hier auf die Referenz dieser Workflowkomponente verwiesen: 
        GeneSEZ Modell-zu-Text Workflow Komponente</para>

        <para />

        <para>Größere Änderungen an der Struktur des Quellcodes können 
        mit Hilfe des Customization Guide erreicht werden: GeneSEZ 
        Customization Guide?</para>

        <para />

        <para>Für Informationen, wie die GeneSEZ-Templates 
        Modellinformationen in Quellcode umsetzen, wird auf die 
        GeneSEZ-Generator-Pattern verwiesen.</para>

      </sect1>

    </chapter>

  </part>

  <part>

    <title>Benutzer-Referenz</title>

    <chapter>

      <title>Workflow und Workflow Komponenten</title>

      <para>Für den GeneSEZ Workflow stehen einzelne Komponenten zur 
      Verfügung. Die core-Komponenten sind die Standard-Komponenten. 
      Die internal werden nur von anderen Workflow-Komponenten 
      verwendet und sollten nicht direkt genutzt werden. Weiterhin gibt 
      es mit java eine plattformspezifische Workflow-Komponente für die 
      Java-Plattform.</para>

      <para>Die Workflow-Komponenten sind in der Abbildung als Klassen 
      dargestellt und die Parameter der Workflow-Komponenten als 
      Attribute.</para>

      <sect1>

        <title>Standard-Komponenten</title>

        <sect2>

          <title>makeGenesezModel</title>

          <para>Erstellt aus einer EMF-UML2-Modell-Datei ein 
          instantiiertes GeneSEZ-Modell. Dabei werden die beiden 
          internen Komponenten xmiReader und uml2genesez genutzt.</para>

          <para />

          <para>inputModelFile</para>

          <para>eine EMF-UML2-Modell-Datei</para>

          <para>genesezModel</para>

          <para>Name des Slots, auf dem das GeneSEZ-Modell gespeichert 
          wird</para>

          <para>excludePackages</para>

          <para>Mit Komma getrennte Liste von Package-Namen, welche 
          nicht mit transformiert werden sollen</para>

          <para>mapClassesInModelToExternal</para>

          <para>boolscher Wert, der angibt, ob Klassen, die direkt im 
          Modell liegen (d.h. auf der obersten Stufe im Modell liegen 
          und nicht in Packages eingeordnet sind), zu externen Typen 
          transformiert werden</para>

          <para>externalPackages</para>

          <para>Liste von Package-Namen, welche als Container für 
          externe Typen dienen (Komma getrennt)</para>

          <para>externalStereotypes</para>

          <para>Liste von Stereotypen, welche zur Markierung von 
          externen Typen verwendet werden (Komma getrennt)</para>

        </sect2>

        <sect2>

          <title>makeGenesezModelProfile</title>

          <para>Wie die Komponente makeGenesezModel, jedoch wird ein 
          UML-Profil als zusätzliches Metamodell registriert, welches 
          in der Transformation genutzt werden kann.</para>

          <para />

          <para>uml2ProfileFile</para>

          <para>Name eines EMF-UML2-Profils, das als Metamodell für die 
          Transformation genutzt wird</para>

          <para />

          <para>Die anderen Parameter sind identisch mit der Komponente 
          makeGenesezModel.</para>

        </sect2>

        <sect2>

          <title>performM2T</title>

          <para>Führt eine Modell-zu-Text Transformation durch.</para>

          <para />

          <para>rootTemplate</para>

          <para>Aufruf eines Define-Blocks eines Templates, welches die 
          Transformation startet/durchführt</para>

          <para>outputDir</para>

          <para>Das Verzeichnis, in dem die generierten Dateien 
          gespeichert werden</para>

          <para>proRegDir</para>

          <para>Das Verzeichnis, welches nach Protected Regions 
          durchsucht wird (normalerweise das gleiche wie das 
          outputDir)</para>

          <para>aspectTemplates</para>

          <para>Liste von XPand-Templates mit Aspekt-Advices für das 
          XPand AOP</para>

          <para>aspectScripts</para>

          <para>Liste von XTend-Skripten mit Aspekt-Advices für XTend 
          AOP</para>

          <para>typeMappingFile</para>

          <para>Name der zu verwendenden Type-Mapping-Datei</para>

          <para>excludePackages</para>

          <para>Liste von (voll qualifizierten) Package-Namen, die von 
          der Modell-zu-Text Transformation ausgeschlossen werden 
          sollen</para>

          <para>useModelNameAsBasePackage</para>

          <para>boolscher Wert, der angibt, ob der Name des Modells als 
          Bezeichnung für das base package verwendet werden soll. Der 
          Standardwert ist false.</para>

          <para>basePackage</para>

          <para>String, der den Namen des zu verwendenden base packages 
          angibt</para>

          <para>generateSectionComments</para>

          <para>boolscher Wert, der angibt, ob verschiedene Abschnitte 
          in den generierten Artefakten mit einem einleitenden 
          Kommentar versehen werden sollen. Der Standardwert ist 
          true.</para>

          <para>disableAccessors</para>

          <para>boolscher Wert, der angibt, ob die (standardmäßige) 
          Generierung von Zugriffsfunktionen (z.B. Get- und 
          Set-Methoden in Java) für Attribute unterdrückt werden soll. 
          Der Standardwert ist false.</para>

          <para>useAccessorStereotype</para>

          <para>boolscher Wert, der angibt, ob der Stereotyp «accessor» 
          ausgewertet werden soll. Der Standardwert ist false.</para>

          <para>usePropertyVisibilityForAccessors</para>

          <para>boolscher Wert, der angibt, dass Properties immer die 
          Sichtbarkeit private erhalten und die Sichtbarkeit der 
          Property für die Zugriffsfunktionen (Accessors) verwendet 
          werden soll (wenn auf true gesetzt) bzw. dass Properties ihre 
          Sichtbarkeit behalten und die Zugriffsfunktionen immer die 
          Sichtbarkeit public erhalten (wenn auf false gesetzt). Der 
          Standardwert ist false.</para>

          <para>configFile</para>

          <para>Name einer Konfigurationsdatei. Wird aktuell nicht 
          verwendet.</para>

        </sect2>

        <sect2>

          <title>performM2M</title>

          <para>Führt eine Modell-zu-Modell-Transformation durch.</para>

          <para />

          <para>invokeScript</para>

          <para>Aufruf einer Funktion eines XTend-Skriptes, welches die 
          Transformation durchführt</para>

          <para>outputModelSlot</para>

          <para>Name des Slots, auf dem das neu erstellte Modell 
          gespeichert wird</para>

          <para>configFile</para>

          <para>Name einer Konfigurationsdatei. Wird aktuell nicht 
          verwendet</para>

        </sect2>

        <sect2>

          <title>performMM</title>

          <para>Führt eine Modell-Modifikation durch. Dabei wird ein 
          Modell mit Hilfe eines XTend-Skriptes geändert.</para>

          <para />

          <para>invokeScript</para>

          <para>Aufruf einer Funktion eines XTend-Skriptes, welches die 
          Modifikation durchführt</para>

          <para>configFile</para>

          <para>Name einer Konfigurationsdatei. Wird aktuell nicht 
          verwendet.</para>

        </sect2>

        <sect2>

          <title>constraintChecker</title>

          <para>Validiert ein instantiiertes Modell mit einer 
          openArchitectureWare-check-Datei.</para>

          <para />

          <para>modelSlot</para>

          <para>Name des Slots, auf dem das Modell gespeichert ist, das 
          validiert werden soll</para>

          <para>checkScript</para>

          <para>eine check-Datei, welche die Regeln zur Überprüfung 
          enthält</para>

          <para>abortOnError</para>

          <para>boolscher Wert, der angibt, ob der Workflow abgebrochen 
          werden soll, wenn Fehler im Modell gefunden werden</para>

        </sect2>

        <sect2>

          <title>xmiWriter</title>

          <para>Serialisiert ein instantiiertes Modell in eine 
          Datei.</para>

          <para />

          <para>modelSlot</para>

          <para>Name des Slots, auf dem das Modell gespeichert ist, das 
          serialisiert werden soll</para>

          <para>outputModelFile</para>

          <para>Name der Datei, die dann das serialisierte Modell 
          enthält</para>

        </sect2>

        <sect2>

          <title>directoryCleaner</title>

          <para>Löscht den Inhalt von Verzeichnissen.</para>

          <para />

          <para>cleaningDirs</para>

          <para>Liste mit Verzeichnisnamen</para>

        </sect2>

      </sect1>

      <sect1>

        <title>Java spezifische Komponenten</title>

        <sect2>

          <title>performM2T</title>

          <para>Führt eine Modell-zu-Text-Transformation für die 
          Java-Plattform durch. Generierte Artefakte werden vom 
          Eclipse-Java-Beautifier sowie von einem XML-Beautifier 
          formatiert.</para>

          <para />

          <para>Die Parameter sind die gleichen wie bei der Komponente 
          performM2T</para>

        </sect2>

      </sect1>

      <sect1>

        <title>Interne Komponenten</title>

        <sect2>

          <title>xmiReader</title>

          <para>Liest die mit inputModelFile angegebene (z.B. von Magic 
          Draw exportierte) EMF-UML2-XMI-Datei ein, instantiiert das 
          UML2-Model und stellt das UML2-Modell auf den Slot bereit, 
          der mit dem Parameter modelSlot angegeben wurde. Slots sind 
          eine Art globale Variable, die von jeder Workflow-Komponente 
          genutzt werden können.</para>

          <para />

          <para>inputModelFile</para>

          <para>siehe Komponente makeGenesezModel</para>

          <para>modelSlot</para>

          <para>Name des Slots, auf dem das instantiierte Modell 
          gespeichert wird</para>

        </sect2>

        <sect2>

          <title>uml2genesez</title>

          <para>Transformiert ein (instantiiertes) UML2-Modell in ein 
          GeneSEZ-Model.</para>

          <para />

          <para>uml2Model</para>

          <para>Name des Slots, auf dem das UML2 Modell gespeichert 
          ist</para>

          <para>genesezModel</para>

          <para>siehe Komponente makeGenesezModel</para>

          <para>excludePackages</para>

          <para>siehe Komponente makeGenesezModel</para>

          <para>mapClassesInModelToExternal</para>

          <para>siehe Komponente makeGenesezModel</para>

          <para>externalPackages</para>

          <para>siehe Komponente makeGenesezModel</para>

          <para>externalStereotypes</para>

          <para>siehe Komponente makeGenesezModel</para>

        </sect2>

        <sect2>

          <title>uml2genesezProfile</title>

          <para>Transformiert ein (instantiiertes) UML2-Modell in ein 
          GeneSEZ-Model mit Angabe eines UML-Profils, das zusätzlich 
          als Metamodell registriert wird.</para>

          <para />

          <para>uml2ProfileFile</para>

          <para>siehe Komponente makeGenesezModelProfile</para>

          <para />

          <para>Die anderen Parameter sind identisch mit der Komponente 
          uml2genesez.</para>

        </sect2>

      </sect1>

    </chapter>

    <chapter>

      <title>Type-Mapping</title>

      <para>Die Type-Mapping-Komponente dient dazu, im Modell 
      verwendete Typen auf Typen in einer Programmiersprache 
      abzubilden. Folgend eine Übersicht der möglichen Typen:</para>

      <para>MClassifier bezeichnet hierbei selbst erstellte Typen im 
      Modell. MGeneric stellt einen generischen Typ dar und wird 
      verwendet, um eine Klasse mit einem Typ zu parametrisieren. 
      MPrimitiveType stellt die primitiven Typen der jeweiligen 
      Programmiersprache dar. Dabei handelt es sich meist um 
      Hardware-nahe Typen, die in der Regel ohne include- oder 
      import-Anweisung verwendbar sind. MExternal stellt die Typen 
      einer Programmiersprache dar, die durch Standardbibliotheken oder 
      andere verwendete externe Bibliotheken verfügbar gemacht 
      werden.</para>

      <sect1>

        <title>Konzept Type-Mapping</title>

        <para>Das Type-Mapping realisiert zwei verschiedene Aufgaben. 
        Zum einen werden mit einem Namens-Mapping die Namen der Typen 
        im Modell auf die zu verwendenden Namen in der jeweiligen 
        Zielsprache abgebildet. Bei MClassifier und MGeneric wird beim 
        Aufruf der Funktion mapName() kein Namens-Mapping durchgeführt, 
        da es sich ja um selbst modellierte Typen handelt, deren Namen 
        nicht abgebildet werden muss. Hier wird der name bzw. die 
        specification zurück gegeben.</para>

        <para />

        <para>Die zweite Aufgabe ist ein Typ-Mapping, welches die 
        Typ-Modifikatoren auswertet und ggf. den im Modell verwendeten 
        Typ ersetzt. Typ-Modifikatoren werden im Modell nicht am Typ 
        selbst festgelegt, sondern bei dem Modellelement, welches den 
        Typ aufweist (also z.B. bei einem Attribut). Die Funktion 
        mapType() realisiert das Typ-Mapping. Folgende 
        Typ-Modifikatoren werden ausgewertet:</para>

        <para />

        <para>* multiplicity » Anzahl der zu speichernden Objekte eines 
        Typs (d.h. ob der Typ an sich ausreicht oder eine Collection 
        oder ein Array des Typs verwendet werden muss)</para>

        <para>* unique » gibt an, ob ein Objekt mehrmals vorkommen 
        kann, wenn die multiplicity größer als 1 ist</para>

        <para>* ordered » gibt an, ob die Objekte geordnet abgelegt 
        werden</para>

        <para />

        <para>Die Typ-Modifikatoren unique und ordered beziehen sich 
        auf multi-valued Typen, d.h. Typen, deren multiplicity größer 
        als 1 ist.</para>

        <para />

        <para>Die Abbildungsvorschriften für das Namens- und 
        Typ-Mapping werden in einer XML-Datei festgelegt.</para>

        <para />

        <para>Weiterhin sind für die Auswahl des passenden Typs oft die 
        im Quellcode angestrebte Verwendung bzw. die vorliegenden 
        Rahmenbedingungen wesentlich. Hierzu können Kontexte definiert 
        werden, die ein spezielles Mapping für eine bestimmte 
        Situation/Verwendung darstellen.</para>

      </sect1>

      <sect1>

        <title>Aufbau einer Type-Mapping Datei</title>

        <para>Eine Type-Mapping Datei besteht aus 4 Abschnitten:</para>

        <para />

        <para>* header » Angabe einer Type-Mapping-Datei die erweitert, 
        bzw. eingebunden werden soll</para>

        <para>* collectionTypes » Angabe, wie Type-Modifikatoren 
        behandelt werden</para>

        <para>* primitiveTypes » Angabe, wie primitive Typen gemappt 
        werden</para>

        <para>* externalTypes » Abbildung von externen Typen</para>

        <sect2>

          <title>Header</title>

          <para>Angabe einer Type-Mapping-Datei mit dem absoluten oder 
          relativen Dateinamen. Alle in dieser Datei definierten 
          Mappings werden eingebunden.</para>

        </sect2>

        <sect2>

          <title>Mapping-Definition</title>

          <para>Für alle 3 Bereiche, die das Abbilden der Typen 
          collection, primitive und external beschreiben, wird eine 
          gemeinsame Syntax genutzt:</para>

          <para />

          <para>Mit map wird der im Modell verwendete Name angegeben. 
          Mit defaultType wird ein Standardtyp angegeben, auf den der 
          Modelltyp abgebildet wird. Im Beispiel oben wird der im 
          UML-Metamodell enthaltene primitive Typ Boolean auf den Typ 
          boolean der Zielprogrammiersprache abgebildet.</para>

          <para />

          <para>Weiterhin können beliebig viele so genannte Kontexte 
          angegeben werden. Diese stellen bestimmte Bereiche bzw. 
          Situationen dar, in welchen ein Typ in den xPand-Templates 
          gemappt wird. Diese Kontexte werden also nicht im Modell 
          angegeben, sondern bei dem Aufruf des Type-Mappings im 
          xPand-Template. Folgend ein Beispiel, welches einen Kontext 
          import definiert, um eine import / include</para>

          <para>Anweisung zu generieren.Standardmäßig wird der Typ in 
          dem Beispiel auf den Klassennamen abgebildet. Wird jedoch der 
          Kontext import angegeben, wird der benötigte Teil für die 
          import / include Anweisung zurückgegeben.</para>

        </sect2>

        <sect2>

          <title>Collections</title>

          <para>In diesem Abschnitt wird definiert, wie Typen unter 
          Berücksichtigung der Typ-Modifikatoren abgebildet werden. 
          Dazu stehen die beiden optionalen Attribute unique und 
          ordered bereit. Sind diese in der XML-Datei nicht angegeben, 
          wird der UML-Standard mit unique == true und ordered == false 
          verwendet.</para>

          <para>Im obigem Beispiel werden auch wieder unterschiedliche 
          Kontexte eingesetzt. Bei der Verwendung des Typs wird stets 
          das Standardmapping zurück geliefert. Bei der Initialisierung 
          / Erstellung eines Objektes hingegen wird auf eine konkrete 
          Implementierung gemappt. In der Programmiersprache Java 
          könnte das obige Mapping in folgendem Quellcode 
          resultieren:</para>

          <para>Eine andere Möglichkeit der Angabe für das obige 
          Mapping unter Nutzung der Standardwerte ist die 
          folgende:</para>

          <para>Standardmäßig hat der Typ-Modifikator unique in der UML 
          den Wert true. Somit entsteht ein identisches Mapping wie bei 
          der Angabe beider Modifikatoren.</para>

        </sect2>

      </sect1>

      <sect1>

        <title>Verwendung des Type-Mappings</title>

        <para>Das Type-Mapping kann in xPand-Templates einfach durch 
        das Einbinden des Type-Mapping eXtend-Skriptes genutzt 
        werden:</para>

        <para />

        <para>Das eXtend-Skript stellt prinzipiell zwei verschiedene 
        Funktionen bereit, bei denen optional noch ein 
        Kontext-Parameter angegeben werden kann:</para>

        <para />

        <para>* mapName() » bildet den als Parameter übergebenen Typ 
        auf den Namen des Typs in der Zielsprache ab</para>

        <para>* mapType() » wertet die Typ-Modifikatoren (des 
        Metamodellelementes) aus und gibt die entsprechenden 
        Collection-Typen zurück</para>

        <para />

        <para>Als Beispiel hier die Deklaration von Attributen in 
        Java:</para>

        <para />

        <para>Bei einem normalen, single-valued Typ (multiplicity == 1) 
        wird lediglich der verwendete Typ auf den zu verwendenden Namen 
        in der Zielsprache gemappt. Ist der übergebene Typ ein 
        MClassifier oder ein MGeneric, so wird das eigentliche 
        Type-Mapping nicht durchgeführt sondern lediglich der 
        übergebene Typ unverändert wieder zurückgegeben. Bei MExternal 
        und MPrimitiveType werden die Informationen aus der 
        Type-Mapping-Datei ausgewertet und der Typ als String 
        zurückgegeben. Der Aufruf von asTypeName() wird zur Anwendung 
        der Naming Conventions durchgeführt.</para>

        <para />

        <para>Bei multi-valued Typen (multiplicity != 1) wird zuerst 
        der Typ gemappt. Im obigen Beispiel wird dazu als Parameter ein 
        MAttribute übergeben. Das Type-Mapping wertet dann die 
        Typ-Modifikatoren unique und ordered aus und gibt den 
        entsprechenden Collection-Typ zurück. Der eigentlich verwendete 
        Typ im Modell wird auf den Namen in der Zielsprache gemappt und 
        als Typ-Parameter der Collection angegeben.</para>

        <para />

      </sect1>

      <sect1>

        <title>Type-Mapping + Naming Conventions</title>

        <para>Wie bereits im letzten Abschnitt aufgezeigt wird nur das 
        Type-Mapping aufgerufen, welches dann selbst anhand des 
        übergebenen Typs entscheidet, ob die Informationen der 
        Type-Mapping-Datei ausgewertet werden müssen oder nicht. Im 
        Folgenden nun ein Beispiel zur Generalisierung:</para>

        <para />

        <para>Hier wird nach dem Schlüsselwort extends die (erste) 
        Basisklasse generiert. Diese Basisklasse kann vom Typ MClass 
        oder auch vom Typ MExternal sein. Ist die Basisklasse vom Typ 
        MClass ist es eine modellierte Klasse (des Domain-Modells) und 
        muss daher den Naming Conventions unterworfen werden. Ist es 
        ein MExternal, muss lediglich das Type-Mapping durchgeführt 
        werden.</para>

        <para />

        <para>Um die xPand-Templates nicht unnötig mit dem Test, um 
        welchen Meta-Typ es sich handelt, zu verkomplizieren, wurden 
        die Funktionen für die Namensgebung so definiert, dass sie 
        diese Aufgabe erledigen. Die Funktion mapName liefert bei 
        Typen, bei denen kein Type-Mapping durchgeführt werden muss, 
        den Typ unverändert wieder zurück (z.B. MClassifier, MGeneric). 
        Wird bei MPrimitiveType oder MExternal ein Type-Mapping 
        durchgeführt, liefert die Funktion einen String zurück.</para>

        <para />

        <para>Die Funktion asTypeName für die Namensgebung erkennt am 
        übergebenen Parameter (Typ oder String), ob das Type-Mapping 
        durchgeführt wurde oder nicht. Wird ein String übergeben, wird 
        dieser unverändert zurückgegeben, da das Type-Mapping den Typ 
        bereits ermittelt hat. Wird ein Typ übergeben, werden die 
        Naming Conventions angewandt und ein String 
        zurückgegeben.</para>

        <para />

        <para>Somit werden auf elegante Weise beide Aspekte 
        behandelt.</para>

        <orderedlist/>

      </sect1>

    </chapter>

    <chapter>

      <title>Externe Typen im Metamodell</title>

      <para>Mit dem Metamodellelement MExternal ist ein Konzept im 
      GeneSEZ-Metamodell vorhanden, welches in dieser Form nicht zur 
      UML gehört. Als externe Typen werden in diesem Zusammenhang im 
      Modell verwendete Typen (Klassen, Interfaces, Enumerations) 
      bezeichnet, die selbst nicht im Modell vorhanden sind. Sie 
      befinden sich stattdessen z.B. in Standard-Bibliotheken der 
      Programmiersprache oder in anderen Bibliotheken, die verwendet 
      werden sollen.</para>

      <sect1>

        <title>Definition im UML-Modell</title>

        <para>Im zugrunde liegenden UML-Modell werden externe Typen als 
        Klassen (bzw. Interfaces oder Enumerations) definiert und 
        speziell gekennzeichnet. Dazu gibt es mehrere Möglichkeiten: 
        </para>

        <para> </para>

        <para>    * Verwendung eines Stereotypes </para>

        <para>    * Verwendung eines separaten Packages </para>

        <para>    * Ablage des Typs direkt im Modell (der Typ hat eine 
        Containment-Beziehung zum Modell-Element und befindet sich 
        nicht in einem Package)  </para>

        <para> </para>

        <para>Die verschiedenen Möglichkeiten haben spezifische Vor- 
        und Nachteile. Die Annotation der einzelnen Klassen mit einem 
        Stereotyp ist jedoch allgemein zu bevorzugen, da hier in den 
        Modellen und verschiedenen Diagrammen die Semantik einer 
        externen Klasse am deutlichsten zum Ausdruck kommt. Beispiele 
        dazu sind weiter unten zu finden. </para>

      </sect1>

      <sect1>

        <title>Definition im Workflow </title>

        <para>Je nachdem, wie externe Typen im UML-Modell definiert 
        wurden, muss dies auch im Workflow angegeben werden. Dazu 
        werden die folgenden drei Parameter der Workflow-Komponenten 
        makeGenesezModel bzw. makeGenesezModelProfile genutzt: </para>

        <para> </para>

        <para>    * mapClassesInModelToExternal » Der Parameter kann 
        als Wert true oder false annehmen und gibt an, ob Typen, die 
        direkt im Modell abgelegt sind und somit zu keinem Package 
        gehören, zu externen Typen transformiert werden (true) oder 
        normal behandelt werden (false). Standardmäßig ist der Wert 
        false. </para>

        <para>    * externalPackages » Als Wert für den Parameter kann 
        eine mit Komma (oder für eine bessere Lesbarkeit eine mit Komma 
        und Leerzeichen) separierte Liste mit Namen von Packages 
        angegeben werden, welche Container für externe Typen 
        darstellen. Die angegebenen Packages selbst werden ebenfalls 
        nicht in ein GeneSEZ-Package transformiert. Standardmäßig ist 
        der Wert ein leerer String. </para>

        <para>    * externalStereotypes » Als Wert kann eine mit Komma 
        (oder für eine bessere Lesbarkeit eine mit Komma und 
        Leerzeichen) separierte Liste mit Namen von Stereotypen 
        angegeben werden. Diese Stereotypen können im UML-Modell sowohl 
        Typen als auch Packages zugewiesen werden. Ist einer dieser 
        Stereotypen einem Typ zugewiesen, so wird dieser in einen 
        externen Typ transformiert. Ist ein Stereotyp einem Package 
        zugewiesen, so wird dieses als Container für externe Typen 
        betrachtet und wird selbst nicht transformiert. Alle in dem 
        betreffenden Package enthaltenen Typen werden zu externen 
        Typen. Standardmäßig ist der Wert ein leerer String. </para>

      </sect1>

      <sect1>

        <title>Umgang in xPand-Templates</title>

        <para>Innerhalb von Templates ist es unwesentlich, ob ein Typ 
        ein externer Typ ist oder nicht. Diese Zuordnung wird durch das 
        GeneSEZ Type-Mapping realisiert. </para>

      </sect1>

      <sect1>

        <title>Beispiel </title>

        <para>Es folgen einige Beispiele, die den Einsatz der 
        vorgestellten Möglichkeiten zur Definition von externen Typen 
        zeigen. Wie in den Modellen deutlich wird, ist die Verwendung 
        eines Stereotypes zur Annotation von Klassen am 
        ausdrucksstärksten. </para>

        <sect2>

          <title>Verwendung eines Stereotypes zur Annotation einer 
          Klasse</title>

          <para>Zugehörige Parameter in der Workflow Konfiguration: 
          </para>

        </sect2>

        <sect2>

          <title>Verwendung eines Stereotypes zur Annotation eines 
          Packages </title>

          <para>Zugehörige Parameter in der Workflow Konfiguration 
          (identisch mit dem ersten Beispiel):</para>

        </sect2>

        <sect2>

          <title>Verwendung der Namen von Packages</title>

          <para>Zugehörige Parameter in der Workflow Konfiguration: 
          </para>

        </sect2>

        <sect2>

          <title>Mapping aller Klassen, die direkt im Modell enthalten 
          sind </title>

          <para>Zugehörige Parameter in der Workflow Konfiguration: 
          </para>

        </sect2>

      </sect1>

    </chapter>

    <chapter>

      <title>Das GeneSEZ-Logging-Konzept</title>

      <para>In diesem Artikel soll in aller Kürze das 
      GeneSEZ-Logging-Konzept-beschrieben werden. Dabei wird auf das 
      Logging in Java-Code, in Skripten und in Templates sowie auf die 
      Konfiguration eingegangen. </para>

      <para> </para>

      <para>GeneSEZ basiert auf dem Framework openArchitectureWare, 
      welches die Logging-API des Apache Commons Logging Frameworks 
      nutzt und als Implementierung log4j verwendet. Das 
      GeneSEZ-Framework nutzt ebenfalls das Apache Commons Logging 
      Framework.</para>

      <sect1>

        <title>Java </title>

        <para>Das Logging von Java-Code aus unterscheidet sich nicht 
        von der gewöhnlichen Nutzung der Logging-API. Zuerst wird eine 
        Referenz auf ein Log-Objekt benötigt: Dann kann dieses 
        Log-Objekt genutzt werden, um Log-Ausgaben zu 
        realisieren:Weitere Informationen befinden sich im Manual zu 
        log4j: log4j 1.2 Manual</para>

      </sect1>

      <sect1>

        <title>Skripten + Templates</title>

        <para>Für Log-Ausgaben aus den openArchitectureWare-Artefakten 
        steht als Frontend im Common-Projekt unter dem Namespace 
        de.genesez.platforms.common.log das eXtend-Skript Log.ext zur 
        Verfügung. Die Funktionen dieses Skriptes rufen Methoden der 
        Java Klasse GenesezLogger auf, welche die Apache Commons 
        Logging-API nutzen. </para>

        <para> </para>

        <para>Sollen Log-Ausgaben erfolgen, so sollte zuerst ein 
        benannter Logger ausgewählt werden, damit die Ausgaben später 
        im Log einem Artefakt zugeordnet werden können: </para>

        <para>Die weiteren Funktionen des Skripts dienen zum Logging 
        von Nachrichten mit dem jeweiligen Log-Level: </para>

      </sect1>

      <sect1>

        <title>Konfiguration</title>

        <para>Zur Konfiguration der verwendeten Implementierung log4j 
        hat openArchitectureWare bereits standardmäßig die Datei 
        log4j.properties im Classpath, die dementsprechend auch 
        standardmäßig genutzt wird. Das GeneSEZ-Framework stellt 
        ebenfalls eine log4j.properties im Namespace 
        de.genesez.platforms.common.log bereit. log4j sucht den 
        kompletten Classpath nach dieser Datei ab und nutzt die erste 
        Datei dieses Namens, die gefunden wird. Daher wird i.d.R. die 
        von openArchitectureWare genutzt, da diese im Classpath eher 
        gefunden wird. </para>

        <para> </para>

        <para>Soll die Log-Konfiguration angepasst werden, so kann die 
        vom GeneSEZ-Framework bereitgestellte als Vorlage genutzt 
        werden. Dazu wird diese in das Konfigurationsverzeichnis des 
        aktuellen Generator-Projekts kopiert (siehe GeneSEZ 
        Projektstruktur). </para>

        <para> </para>

        <para>Zur detaillierten Erklärung der Inhalte der 
        Konfigurationsdatei sei auf das log4j Manual verwiesen: log4j 
        1.2 Manual </para>

      </sect1>

    </chapter>

    <chapter>

      <title>GeneSEZ UML Profil</title>

      <para>Um Konzepte des GeneSEZ-Metamodells in UML zu modellieren 
      sowie nützliche und fachlich relevante Informationen zur 
      Umsetzung im Modell zu hinterlegen, wurde ein GeneSEZ-UML-Profil 
      eingeführt. Dieses ist prinzipiell plattformunabhängig, jedoch 
      müssen nicht alle Aspekte, die das UML-Profil enthält, auch von 
      den plattform-spezifischen Template-Sets ausgewertet werden. 
      </para>

      <para> </para>

      <para>Welche Aspekte die plattformspezifischen Templates 
      unterstützen, ist in der Dokumentation zu den jeweiligen 
      Plattformen zu finden. </para>

      <para> </para>

      <para>source:trunk/de.genesez.docs/GeneSezProfile/genesez.profile.png 
      </para>

      <para>Folgend werden die einzelnen Stereotypen und ihre Bedeutung 
      näher erläutert. </para>

    </chapter>

  </part>

</book>

