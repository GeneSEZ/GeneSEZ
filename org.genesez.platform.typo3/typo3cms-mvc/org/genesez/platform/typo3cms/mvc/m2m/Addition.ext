/**
 * Additions of the model before generation of source code.  
 *  
 * @author	Nico Herbig <nico.herbig@fh-zwickau.de>
 * @date	2011-08-11
 */

//	based on genesez meta model
import gcore;

// use common logging scripts
extension org::genesez::util::logging::Logging;

// use GeneSEZ profile scripts
extension org::genesez::metamodel::core::util::profile::GeneSEZProfile;

// use TYPO3 profile access helper scripts
extension org::genesez::platform::typo3v4::profile::AccessHelper;

// use TYPO3 MVC Extbase profile + access helper scripts
extension org::genesez::platform::typo3v4::mvc::profile::ExtbaseProfile;
extension org::genesez::platform::typo3v4::mvc::profile::ExtbaseAccessHelper;

// use TYPO3 MVC Fluid profile + access helper scripts
extension org::genesez::platform::typo3v4::mvc::profile::FluidProfile;
extension org::genesez::platform::typo3v4::mvc::profile::FluidAccessHelper;

// use TYPO3 naming context and common naming scripts
extension org::genesez::metamodel::core::util::mapping::NameMapping;
extension org::genesez::platform::typo3v4::mvc::convention::NamingContext;

// use TYPO3 MVC access helper scripts which overrides
// common access helper scripts if script name is equal 
extension org::genesez::platform::typo3v4::mvc::util::AccessHelper;
extension org::genesez::metamodel::core::util::AccessElement;

// use common navigation scripts
extension org::genesez::metamodel::core::util::NavigateElement;

// use common create template scripts
extension org::genesez::metamodel::core::util::CreateElement;
extension org::genesez::metamodel::core::util::CloneElement;


/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	MPackage (MModel)
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

Void modelAdditions(MModel this) :
	useLogger("org.genesez.platform.typo3") ->
	setInternalNamingContext( namingContextGeneral() ) ->
	// perform model additions for all stereotypes which are validators
	anyStereotype.select( e | e.isLocalValidator() ).makeValidator() ->
	// perform model additions for model
	packageAdditions();


Void packageAdditions(MPackage this) :
	// perform model additions for all classes
	classifier.typeSelect(MClass).classAdditions() ->
	
	// perform model additions for all nested packages
	nestedPackage.packageAdditions();


/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	MClass
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

Void classAdditions(MClass this) :
	logTrace("--------------------------------------------------------------------------------") ->
	logTrace("call classAdditions for class: " + name) ->
	addSingletonInterface() ->
	addDependencyInjection() ->
	switch {
		case isController() :
			controllerAdditions()
		case isEntity() :
			entityAdditions()
		case isValueObject() :
			valueObjectAdditions()
		case isRepository() :
			repositoryAdditions()
		case isValidator() :
			validatorAdditions()
		case isViewHelper() :
			viewHelperAdditions()
		default :
			Void
	};	


/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	TYPO3 MVC Extbase additions
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/


addSingletonInterface(MClass this) :
	logTrace("call addSingletonInterface for class: " + name) ->
	// checks if the class has a stereotype 
	hasT3SingletonStereotype()
		// if true, then create the singleton interface
		? realization.add( createExternal( navModel(), "T3_LIB_SINGLETON" ) )
		: Void;


addDependencyInjection(MClass this) :
	logTrace("call addDependencyInjection for class: " + name) ->
	// checks if the class has a stereotype 
	hasT3ExtbaseDependencyInjectionStereotype()
		? (	
			// inject configuration manager if it should
			injectConfigurationManagerType() ->
			// inject object manager if it should
			injectObjectManagerType() ->
			// inject persistence manager if it should
			injectPersistenceManagerType()
		) : Void;


Void injectConfigurationManagerType(MClass this) :
	logTrace("call addDependencyInjectConfigurationManagerType for class: " + name) ->
	// checks if the configuration manager should be generated
	getT3ExtbaseDependencyInjectionInjectConfigurationManagerType() != prT3ExtbaseConfigurationManagerTypeNone()
		// if true, then create the super controller type which is specified
		? (	let a = makeInjectAttribute( "configurationManager", createExternal( navModel(), getT3ExtbaseDependencyInjectionInjectConfigurationManagerType() ) ) :
				// add comment to discribe the attribute
				a.makeComment("TYPO3 Extbase configuration manager") 
		) : Void;


Void injectObjectManagerType(MClass this) :
	logTrace("call addDependenyInjectionObjectManagerType for class: " + name) ->
	// checks if the object manager should be generated
	getT3ExtbaseDependencyInjectionInjectObjectManagerType() != prT3ExtbaseObjectManagerTypeNone()
		// if true, then create the super controller type which is specified
		? (	let a = makeInjectAttribute( "objectManager", createExternal( navModel(), getT3ExtbaseDependencyInjectionInjectObjectManagerType() ) ) :
				// add comment to discribe the attribute
				a.makeComment("TYPO3 Extbase object manager") 
		) : Void;


Void injectPersistenceManagerType(MClass this) :
	logTrace("call addDependenyInjectionPersistenceManagerType for class: " + name) ->
	// checks if the persistence manager should be generated
	getT3ExtbaseDependencyInjectionInjectPersistenceManagerType() != prT3ExtbasePersistenceManagerTypeNone()
		// if true, then create the super controller type which is specified
		? (	let a = makeInjectAttribute( "persistenceManager", createExternal( navModel(), getT3ExtbaseDependencyInjectionInjectPersistenceManagerType() ) ) :
				// add comment to discribe the attribute
				a.makeComment("TYPO3 Extbase persistence manager") 
		) : Void;


private MAttribute makeInjectAttribute(MClass this, String name, MType dependencyInjectionType) :
	let a = createAttribute( xmiGuid + "." + name, name ) :
		// (visibility, derived, multiplicity, unique, ordered)
		a.processProperty("protected", false, 1, false, false) ->
		// (defaultvalue, static, final)
		a.processAttribute("", false, false) ->
		// add dependency injection type
		a.setType(
			dependencyInjectionType
		) ->
		// add stereotype to mark this attribute as dependency injection
		a.stereotype.add( 
			let s = makeStereotype( navModel(), prDi(), prDi() ) :
				a.makeTaggedValue( makeTag( s, prDiSetter(), "Boolean" ), "true" ) ->
				s
		) ->
		a;


/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	TYPO3 MVC Extbase Controller additions
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

/**
 * Model additions for an TYPO3 MVC Extbase controller.
 */
Void controllerAdditions(MClass controller) :
	logTrace("call controllerAdditions for controller: " + controller.name) ->
	// add super controller type 
	controller.addControllerType() ->
	// add 'initalizeAction' if it should
	controller.addControllerInitializeAction() ->
	// add 'errorAction' if it should
	controller.addControllerErrorAction() ->
	// add 'getErrorFlashMessage' if it should
	controller.addControllerGetErrorFlashMessage() ->
	// add 'initalizeAction' for all actions which have the sterotype
	controller.operation.select( o | o.hasT3ExtbaseControllerActionCreateInitializeAction("true") )
		.addControllerActionInitializeAction();


cached MClass makeController(MClass domainObject) :
	logTrace("call makeController for domain object: " + domainObject.name) ->
	// checks if the controller doesn't already exists
	( domainObject.hasT3ExtbaseDomainObjectCreateController("true") || domainObject.hasT3ExtbaseDomainObjectCreatePlugin("true") ) &&
	!domainObject.existsController()
		? (	let c = createClass( domainObject.navModel(), domainObject.xmiGuid + ".controller", domainObject.asControllerName() ) :
				logTrace("create new controller class for domain object: " + domainObject.name) ->
				c.processController(domainObject)
		) : domainObject.model().allControllers().selectFirst( c | c.nameS() == domainObject.asControllerName() );


MClass processController(MClass this, MClass domainObject) :
	logTrace("call processController for class: " + name) ->
	// (visibility, abstract, final)
	processClassifier("public", false, false) ->
	// add comment to discribe the controller
	makeComment("Controller for a domain object.") ->
	// add super controller type
	addControllerType() ->
	// add property to inject the repository
	addControllerRepository(domainObject) ->
	// add controller actions
	addControllerListAction(domainObject) ->
	addControllerShowAction(domainObject) ->
	addControllerNewAction(domainObject) ->
	addControllerCreateAction(domainObject) ->
	addControllerEditAction(domainObject) ->
	addControllerUpdateAction(domainObject) ->
	addControllerDeleteAction(domainObject) ->
	// add stereotype to mark this class as controller
	stereotype.add( 
		makeStereotype( navModel(), prT3ExtbaseController(), prT3ExtbaseController() ) 
	) ->
	this;


/**
 * Add the super controller type to the controller class.
 */
Void addControllerType(MClass this) :
	logTrace("call addControllerType for controller: " + name) ->
	// checks if the class has a stereotype 
	hasT3ExtbaseControllerStereotype()
		// if true, then create the super controller type which is specified
		? (	let controllerType = getT3ExtbaseControllerControllerType() :
				switch {
					// check, if no super controller type should be generated 
					case controllerType == prT3ExtbaseControllerTypeNone() :
						Void
					case controllerType == prT3ExtbaseControllerTypeExtbaseControllerInterface() :
						realization.add( createExternal( navModel(), controllerType ) )
					case generalization.isEmpty :
						generalization.add( createExternal( navModel(), controllerType ) )
					default : Void
				}
		)
		// else create the default one
		: (	generalization.isEmpty 
				? generalization.add( createExternal( navModel(), prT3ExtbaseControllerTypeExtbaseActionController() ) )
				: Void
		);


Void addControllerRepository(MClass this, MClass domainObject) :
	let a = createAttribute( xmiGuid + "." + domainObject.asRepositoryName().toFirstLower(), domainObject.asRepositoryName().toFirstLower() ) :
		// (visibility, derived, multiplicity, unique, ordered)
		a.processProperty("protected", false, 1, false, false) ->
		// (defaultvalue, static, final)
		a.processAttribute("", false, false) ->
		// add comment to discribe the attribute
		a.makeComment("Repository for a domain objects") ->
		// add repository type
		a.setType(
			makeRepository(domainObject) 
		) ->
		// add stereotype to mark this attribute as dependency injection
		a.stereotype.add( 
			let s = makeStereotype( model(), prDi(), prDi() ) :
				a.makeTaggedValue( makeTag( s, prDiSetter(), "Boolean" ), "true" ) ->
				s
		);


/**
 * Add the 'initalizeAction' to the controller class.
 */
Void addControllerInitializeAction(MClass this) :
	logTrace("call addControllerInitializeAction for controller: " + name) ->
	// checks if the initalize action should be created and doesn't already exists
	hasT3ExtbaseControllerCreateInitializeAction("true")
	&& operation.select( o | o.name() == "initalizeAction" ).isEmpty
		? ( let o = makeOperation("initializeAction", "protected", false, false, false) :
				// add comment to discribe the operation
				o.makeComment("Override initalizeAction to solve tasks which all actions have in common.")
		) : Void;


/**
 * Add the 'errorAction' to the controller class.
 */
Void addControllerErrorAction(MClass this) :
	logTrace("call addControllerErrorAction for controller: " + name) ->
	// checks if the error action should be created and doesn't already exists
	hasT3ExtbaseControllerCreateErrorAction("true")
	&& operation.select( o | o.name() == "errorAction" ).isEmpty
		? (	let o = makeOperation("errorAction", "protected", false, false, false) :
				// add comment to discribe the operation
				o.makeComment("Override errorAction to show that errors happend.")
		) : Void;


/**
 * Add the 'getErrorFlashMessage' to the controller class.
 */
Void addControllerGetErrorFlashMessage(MClass this) :
	logTrace("call addControllerGetErrorFlashMessage for controller: " + name) ->
	// checks if the get error flash message method should be created and doesn't already exists
	hasT3ExtbaseControllerCreateGetErrorFlashMessage("true")
	&& operation.select(o| o.name() == "getErrorFlashMessage" ).isEmpty
		? (	let o = makeOperation("getErrorFlashMessage", "protected", false, false, false) :
				// add comment to discribe the operation
				o.makeComment("Override getErrorFlashMessage to customize the flash message.") ->
				o.setReturn(
					let return = makeParameter( o, o.xmiGuid + "." + "return", "", "", "return", createPrimitiveTypeString(model()) ) :
						// add comment to discribe the parameter
						return.makeComment("The flash message") ->
						return
				) ->
				// add stereotype to mark this operation as no controller action
				o.stereotype.add( 
					makeStereotype( model(), prT3ExtbaseControllerNoAction(), prT3ExtbaseControllerNoAction() ) 
				)
		) :  Void;


Void addControllerActionInitializeAction(MOperation this) :
	logTrace("call addControllerActionInitializeAction for controller: " + name) ->
	// checks if the initalize action for an action should be created and doesn't already exists
	hasT3ExtbaseControllerActionCreateInitializeAction("true") 
	&& classifier.operation.select( o | o.name() == "initalize" + name().toFirstUpper() ).isEmpty
		? (let o = makeOperation(classifier, "initalize" + name().toFirstUpper(), "protected", false, false, false) :
				// add comment to discribe the operation
				o.makeComment("Define initialize" + name().toFirstUpper() + " to solve tasks before the action is called.")
		) : Void;


Void addControllerListAction(MClass this, MClass domainObject) :
	let o = makeControllerAction("listAction") :
		o.makeComment("Displays a list of domain objects");


Void addControllerShowAction(MClass this, MClass domainObject) :
	let o = makeControllerAction("showAction") :
		// add comment to discribe the operation
		o.makeComment("Displays one single domain object.") ->
		o.parameter.add(
			let p = makeParameter(o, domainObject.name( namingContextObject() ), "", "in", domainObject) :
				p.makeComment("The existing domain object to display.") ->
				p
		);
		

Void addControllerNewAction(MClass this, MClass domainObject) :
	let o = makeControllerAction("newAction") :
		// add comment to discribe the operation
		o.makeComment("Displays a form for creating a new domain object.") ->
		o.parameter.add(
			let p = makeParameter(o, domainObject.name( namingContextObject() ), "NULL", "in", domainObject) :
				p.makeComment("A fresh domain object to display.") ->
				p
		);


Void addControllerCreateAction(MClass this, MClass domainObject) :
	let o = makeControllerAction("createAction") :
		// add comment to discribe the operation
		o.makeComment("Creates a new domain object.") ->
		o.parameter.add(
			let p = makeParameter(o, domainObject.name( namingContextObject() ), "", "in", domainObject) :
				p.makeComment("The new domain object to create.") ->
				p
		);


Void addControllerEditAction(MClass this, MClass domainObject) :
	let o = makeControllerAction("editAction") :
		// add comment to discribe the operation
		o.makeComment("Displays a form for editing an existing domain object.") ->
		o.parameter.add(
			let p = makeParameter(o, domainObject.name( namingContextObject() ), "", "in", domainObject) :
				p.makeComment("The existing domain object to display.") ->
				p
		);


Void addControllerUpdateAction(MClass this, MClass domainObject) :
	let o = makeControllerAction("updateAction") :
		// add comment to discribe the operation
		o.makeComment("Updates an existing domain object.") ->
		o.parameter.add(
			let p = makeParameter(o, domainObject.name( namingContextObject() ), "", "in", domainObject) :
				p.makeComment("The existing domain object to update") ->
				p
		);


Void addControllerDeleteAction(MClass this, MClass domainObject) :
	let o = makeControllerAction("deleteAction") :
		// add comment to discribe the operation
		o.makeComment("Deletes an existing domain object.") ->
		o.parameter.add(
			let p = makeParameter(o, domainObject.name( namingContextObject() ), "", "in", domainObject) :
				p.makeComment("The existing domain object to delete") ->
				p
		);


private MOperation makeControllerAction(MClass this, String name) :
	let o = makeOperation(name, "protected", false, false, false) :
		o.setReturn(
			let return = makeParameter( o, o.xmiGuid + "." + "return", "", "", "return", createPrimitiveTypeString(model()) ) :
				// add comment to discribe the parameter
				return.makeComment("The rendered view for this action.") ->
				return
		) ->
		o.stereotype.add( 
			makeStereotype( model(), "http://www.genesez.org/TYPO3/TYPO3v4/controller/" + name, "http://www.genesez.org/TYPO3/TYPO3v4/controller/" + name ) 
		) ->
		o;


/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	TYPO3 MVC Extbase Factory additions
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/


/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	TYPO3 MVC Extbase Model entity additions
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

/**
 * Model additions for an TYPO3 MVC Extbase entity.
 */
Void entityAdditions(MClass entity) :
	logTrace("call entityAdditions for entity: " + entity.name) ->
	// add super entity type
	entity.addEntityType() ->
	// make controller if it should
	entity.makeController() ->
	// make repository if it should
	entity.makeRepository() ->
	// make plugin if it should
	entity.makePlugin() ->
	// make validator if it should
	entity.makeValidator(); 


/**
 * Add the super entity type to the entity class.
 */
Void addEntityType(MClass this) :
	logTrace("call addEntityType for entity: " + name) ->
	// checks if the class has a stereotype 
	hasT3ExtbaseEntityStereotype()
		// if true, then create the super entity type which is specified
		? (	let entityType = getT3ExtbaseEntityEntityType() :
				switch {
					// check, if no super entity type should be generated 
					case entityType == prT3ExtbaseEntityTypeNone() :
						Void
					case generalization.isEmpty :
						generalization.add( createExternal( navModel(), entityType ) )
					default : Void
				}
		)
		// else create the default one
		: (	generalization.isEmpty 
				? generalization.add( createExternal( navModel(), prT3ExtbaseEntityTypeExtbaseAbstractEntity() ) )
				: Void
		);


/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	TYPO3 MVC Extbase Model value object additions
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/


/**
 * Model additions for an TYPO3 MVC Extbase value object.
 */
Void valueObjectAdditions(MClass valueObject) :
	logTrace("call valueObjectAdditions for value object: " + valueObject.name) ->
	// add super value object type
	valueObject.addValueObjectType() ->
	// make controller if it should
	valueObject.makeController() ->
	// make repository if it should
	valueObject.makeRepository() ->
	// make plugin if it should
	valueObject.makePlugin() ->
	// make validator if it should
	valueObject.makeValidator(); 


/**
 * Add the super value object type to the value object class.
 */
Void addValueObjectType(MClass this) :
	logTrace("call addValueObjectType for value object: " + name) ->
	// checks if the class has a stereotype 
	hasT3ExtbaseValueObjectStereotype()
		// if true, then create the super value object type which is specified
		? ( let valueObjectType = getT3ExtbaseValueObjectValueObjectType() :
				switch {
					// check, if no super value object type should be generated 
					case valueObjectType == prT3ExtbaseValueObjectTypeNone() :
						Void
					case generalization.isEmpty :
						generalization.add( createExternal( navModel(), valueObjectType ) )
					default : Void
				}
		)
		// else create the default one
		: (	generalization.isEmpty 
				? generalization.add( createExternal( navModel(), prT3ExtbaseValueObjectTypeExtbaseAbstractValueObject() ) )
				: Void 
		);


/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	TYPO3 MVC Extbase Repository additions
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

/**
 * Model additions for an TYPO3 MVC Extbase repository.
 */
Void repositoryAdditions(MClass repository) :
	logTrace("call repositoryAdditions for repository: " + repository.name) ->
	// add super repository type
	repository.addRepositoryType() ->
	// add 'initalizeObject' if it should
	repository.addRepositoryInitializeObject();


cached MClass makeRepository(MClass domainObject) :
	logTrace("call makeRepository for domain object: " + domainObject.name) ->
	// checks if the respository doesn't already exists
	( domainObject.hasT3ExtbaseDomainObjectCreateRepository("true") || domainObject.hasT3ExtbaseDomainObjectCreateController("true") ) &&
	!domainObject.existsRepository()
		? (	let c = createClass( domainObject.navModel(), domainObject.xmiGuid + ".repository", domainObject.asRepositoryName() ) :
				logTrace("create new repository class for domain object: " + domainObject.name) ->
				c.processRepository(domainObject)
		) : domainObject.navModel().allRepositories().selectFirst( e | e.nameS() == domainObject.asRepositoryName() );


MClass processRepository(MClass this, MClass domainObject) :
	logTrace("call processRepository for class: " + name) ->
	// (visibility, abstract, final)
	processClassifier("public", false, false) ->
	// add comment to discribe the controller
	makeComment("Respository for a domain object.") ->
	// add super repository type
	addRepositoryType() ->
	// add stereotype to mark this class as repository
	stereotype.add( 
		makeStereotype( model(), prT3ExtbaseRepository(), prT3ExtbaseRepository() ) 
	) ->
	this;


/**
 * Add the super repository type to the repository class.
 */
Void addRepositoryType(MClass this) :
	logTrace("call addRepositoryType for repository: " + name) ->
	// checks if the class has a stereotype 
	hasT3ExtbaseRepositoryStereotype()
		// if true, then create the super repository type which is specified
		? ( let repositoryType = getT3ExtbaseRepositoryRepositoryType() :
				switch {
					// check, if no super repository type should be generated 
					case repositoryType == prT3ExtbaseRepositoryTypeNone() :
						Void
					case generalization.isEmpty :
						generalization.add( createExternal( navModel(), repositoryType ) )
					default : Void
				} 
		) 
		// else create the default one
		: (	generalization.isEmpty 
				? generalization.add( createExternal( navModel(), prT3ExtbaseRepositoryTypeExtbaseRepository() ) )
				: Void 
		);


/**
 * Add the 'initalizeObject' to the repository class.
 */
Void addRepositoryInitializeObject(MClass this) :
	// checks if the initalize object operation should be created and doesn't already exists
	hasT3ExtbaseRepositoryCreateInitializeObject("true")
	&& operation.select( o | o.name() == "initalizeObject" ).isEmpty
		? ( let o = makeOperation("initalizeObject", "public", false, false, false) :
				// add comment to discribe the operation
				o.makeComment("Life cycle method.")
		) : Void;

/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	TYPO3 MVC Extbase Service additions
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/


/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	TYPO3 MVC Extbase Validator additions
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

/**
 * Model additions for an TYPO3 MVC Extbase repository.
 */
Void validatorAdditions(MClass validator) :
	logTrace("call validatorAdditions for validator: " + validator.name) ->
	// add super validiator type
	validator.addValidatorType() ->
	// add 'isValid' if not exists
	validator.addValidatorIsValid();


cached MClass makeValidator(MClass domainObject) :
	logTrace("call makeValidator for domain object: " + domainObject.name) ->
	domainObject.hasT3ExtbaseDomainObjectCreateValidator("true") &&
	!domainObject.existsValidator()
		? (	let c = createClass( domainObject.navModel(), domainObject.xmiGuid + ".validator", domainObject.asValidatorName() ) :
				logTrace("create new validator class for domain object: " + domainObject.name) ->
				c.processValidator()
		) : domainObject.navModel().allValidators().selectFirst( e | e.nameS() == domainObject.asValidatorName() ); 	


cached MClass makeValidator(MStereotype stereotype) :
	logTrace("call makeValidator for stereotype: " + stereotype.name) ->
	stereotype.isLocalValidator() &&
	!stereotype.existsValidator() 
		? (	let c = createClass(stereotype.navModel(), stereotype.xmiGuid + ".validator", stereotype.asValidatorName() ) :
				logTrace("create new validator class for stereotype: " + stereotype.name) ->
				c.generalization.add(
					makeValidatorGeneralization( stereotype.generalization.first() )
				) ->
				c.processValidator()
		) : stereotype.navModel().allValidators().select( v | v.nameS() == stereotype.asValidatorName() ).first();


MType makeValidatorGeneralization(MStereotype this) :
	isLocalValidator()
	? makeValidator()
	: createExternal( model(), name );


boolean isLocalValidator(MStereotype this) :
	isValidator() && !name.startsWith("T3Extbase");


MClass processValidator(MClass this) :
	logTrace("call processValidator for class: " + name) ->
	// (visibility, abstract, final)
	processClassifier("public", false, false) ->
	// add comment to discribe the validator
	makeComment("Validator for object, property or parameter.") ->
	// add super validator type
	addValidatorType() ->
	// add 'isValid'
	addValidatorIsValid() ->
	// add stereotype to mark this class as validator
	stereotype.add( 
		makeStereotype( navModel(), prT3ExtbaseValidator(), prT3ExtbaseValidator() ) 
	) ->
	this;


/**
 * Add the super validator type to the validator class.
 */
Void addValidatorType(MClass this) :
	logTrace("call addValidatorType for validator: " + name) ->
	// checks if the class has a stereotype
	hasT3ExtbaseValidatorStereotype()
		// if true, then create the super validator type which is specified
		? ( let validatorType = getT3ExtbaseValidatorValidatorType() :
				switch {
					// check, if no super validator type should be generated 
					case validatorType == prT3ExtbaseValidatorTypeNone() :
						Void
					case validatorType == prT3ExtbaseValidatorTypeExtbaseValidatorInterface() :
						realization.add( createExternal( navModel(), validatorType ) )
					case validatorType == prT3ExtbaseValidatorTypeExtbaseObjectValidatorInterface() :
						realization.add( createExternal( navModel(), validatorType ) )
					case generalization.isEmpty :
						generalization.add( createExternal( navModel(), validatorType ) )
					default : Void
				}
		)
		// else create the default one
		: ( generalization.isEmpty 
				? generalization.add( createExternal( navModel(), prT3ExtbaseValidatorTypeExtbaseAbstractValidator() ) )
				: Void 
		);


/**
 * Add the 'isValid' to the validator class.
 */
Void addValidatorIsValid(MClass this) :
	logTrace("call addValidatorIsValid for validator: " + name) ->
	// checks if the isValid method doesn't already exists
	operation.select( o | o.name() == "isValid" ).isEmpty
		? (	let o = makeOperation("isValid", "public", false, false, false) :
				// add comment to discribe the operation
				o.makeComment("Checks if the given value is valid according to the validator.") ->
				o.parameter.add(
					let p = makeParameter(o, "value", "", "in", createPrimitiveType( model(), "mixed" )) :
						// add comment to discribe the parameter
						p.makeComment("The value that should be validated") ->
						p
				) ->
				o.setReturn(
					let return = makeParameter(o, o.xmiGuid + "." + "return", "", "", "return", createPrimitiveTypeBoolean( model() ) ) :
						// add comment to discribe the parameter
						return.makeComment("TRUE if the value is valid, FALSE if an error occured") ->
						return
				)
		) : Void;
		

/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	TYPO3 MVC Extbase Plugin additions
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

cached MClass makePlugin(MClass domainObject) :
	logTrace("call makePlugin for domain object: " + domainObject.name) ->
	// checks if the plugin doesn't already exists
	domainObject.hasT3ExtbaseDomainObjectCreatePlugin("true") &&
	!domainObject.existsPlugin()
		? (	let i = createInterface( domainObject.navModel(), domainObject.xmiGuid + ".plugin", domainObject.asPluginName() ) :
				logTrace("create new plugin interface for domain object: " + domainObject.name) ->
				i.processPlugin(domainObject)
		) : domainObject.navModel().allPlugins().selectFirst( p | p.name() == domainObject.asPluginName() );


MInterface processPlugin(MInterface this, MClass domainObject) :
	logTrace("call processPlugin for interface: " + name) ->
	// (visibility, abstract, final)
	processClassifier("public", false, false) ->
	// add comment to discribe the controller
	makeComment("Plugin for a domain object.") ->
	// add stereotype to mark this interface as plugin
	stereotype.add( 
		let s = makeStereotype( navModel(), prT3ExtbasePlugin(), prT3ExtbasePlugin() ) :
			makeTaggedValue( makeTag( s, prT3ExtbasePluginTitle(), "String" ), domainObject.asPluginName() ) ->
			(	let controller = makeController(domainObject) :
				( 	let controllerActionType = makeTag(s, prT3ExtbasePluginControllerActions(), "Operation") :
						controller.operation.select( e | e.isControllerAction() )
							.addPluginControllerAction(controllerActionType, this)
				) ->
				( 	let uncachedControllerActionType = makeTag(s, prT3ExtbasePluginUncachedControllerActions(), "Operation") :
						controller.operation.select( e | e.isControllerAction() && {"createAction", "updateAction", "deleteAction"}.contains(e.name) )
							.addPluginControllerAction(uncachedControllerActionType, this)
				)
			) ->
			s 
	) ->
	this;


private Void addPluginControllerAction(MOperation controllerAction, MTag controllerActionType, MInterface this) :
	createTaggedValue(controllerActionType, controllerAction);


		
/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	TYPO3 MVC Fluid ViewHelper additions
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

/**
 * Model additions for an TYPO3 MVC Fluid view helper.
 */
Void viewHelperAdditions(MClass this) :
	logTrace("call viewHelperAdditions for view helper: " + name) ->
	// add super view helper type
	addViewHelperType();


Void addViewHelperType(MClass this) :
	logTrace("call addViewHelperType for view helper: " + name) ->
	// checks if the class has a stereotype 
	hasT3FluidViewHelperStereotype()
		// if true, then create the super view helper type which is specified
		? ( let viewHelperType = getT3FluidViewHelperViewHelperType() :
				switch {
					// check, if no super view helper type should be generated 
					case viewHelperType == prT3FluidViewHelperTypeNone() :
						Void
					case generalization.isEmpty :
						generalization.add( createExternal( navModel(), viewHelperType ) )
					default : Void
				} 
		) 
		// else create the default one
		: (	generalization.isEmpty 
				? generalization.add( createExternal( navModel(), prT3FluidViewHelperTypeFluidAbstractViewHelper() ) )
				: Void 
		);


/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	Helper functions
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

private String nameS(MClassifier this) :
	name( namingContextGeneral() ).split("_").last();
	

private String asControllerName(MClassifier domainElement) :
	domainElement.nameS() + "Controller";
	
	
private String asRepositoryName(MClassifier domainElement) :
	domainElement.nameS() + "Repository";


private String asValidatorName(MClassifier domainElement) :
	domainElement.nameS() + "Validator";


private String asValidatorName(MStereotype validator) :
	validator.name.endsWith("Validator") ? validator.name : validator.name + "Validator";
	

private String asPluginName(MClassifier domainElement) :
	domainElement.name.toFirstUpper();

	

private boolean existsController(MClass this) :
	// checks if the controller doesn't already exists
	!navModel().allControllers().select( c | c.nameS() == asControllerName() ).isEmpty;
	

private boolean existsRepository(MClass this) :
	// checks if the respository doesn't already exists
	!navModel().allRepositories().select( r | r.nameS() == asRepositoryName() ).isEmpty;


private boolean existsValidator(MClass this) :
	// checks if the validator doesn't already exists
	!navModel().allValidators().select( v | v.nameS() == asValidatorName() ).isEmpty;

private boolean existsValidator(MStereotype this) :
	// checks if the validator doesn't already exists
	!navModel().allValidators().select( v | v.nameS() == asValidatorName() ).isEmpty;

private boolean existsPlugin(MClass this) :
	// checks if the plugin doesn't already exists
	!navModel().allPlugins().select( p | p.asPluginName() == asPluginName() ).isEmpty;